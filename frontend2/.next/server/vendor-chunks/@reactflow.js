"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reactflow";
exports.ids = ["vendor-chunks/@reactflow"];
exports.modules = {

/***/ "(ssr)/../node_modules/@reactflow/background/dist/esm/index.mjs":
/*!****************************************************************!*\
  !*** ../node_modules/@reactflow/background/dist/esm/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Background: () => (/* binding */ Background$1),\n/* harmony export */   BackgroundVariant: () => (/* binding */ BackgroundVariant)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classcat */ \"(ssr)/../node_modules/classcat/index.js\");\n/* harmony import */ var _reactflow_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reactflow/core */ \"(ssr)/../node_modules/@reactflow/core/dist/esm/index.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/../node_modules/zustand/esm/shallow.mjs\");\n\n\n\n\nvar BackgroundVariant;\n(function(BackgroundVariant) {\n    BackgroundVariant[\"Lines\"] = \"lines\";\n    BackgroundVariant[\"Dots\"] = \"dots\";\n    BackgroundVariant[\"Cross\"] = \"cross\";\n})(BackgroundVariant || (BackgroundVariant = {}));\nfunction LinePattern({ color, dimensions, lineWidth }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        stroke: color,\n        strokeWidth: lineWidth,\n        d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`\n    });\n}\nfunction DotPattern({ color, radius }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n        cx: radius,\n        cy: radius,\n        r: radius,\n        fill: color\n    });\n}\nconst defaultColor = {\n    [BackgroundVariant.Dots]: \"#91919a\",\n    [BackgroundVariant.Lines]: \"#eee\",\n    [BackgroundVariant.Cross]: \"#e2e2e2\"\n};\nconst defaultSize = {\n    [BackgroundVariant.Dots]: 1,\n    [BackgroundVariant.Lines]: 1,\n    [BackgroundVariant.Cross]: 6\n};\nconst selector = (s)=>({\n        transform: s.transform,\n        patternId: `pattern-${s.rfId}`\n    });\nfunction Background({ id, variant = BackgroundVariant.Dots, // only used for dots and cross\ngap = 20, // only used for lines and cross\nsize, lineWidth = 1, offset = 2, color, style, className }) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { transform, patternId } = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_2__.useStore)(selector, zustand_shallow__WEBPACK_IMPORTED_MODULE_3__.shallow);\n    const patternColor = color || defaultColor[variant];\n    const patternSize = size || defaultSize[variant];\n    const isDots = variant === BackgroundVariant.Dots;\n    const isCross = variant === BackgroundVariant.Cross;\n    const gapXY = Array.isArray(gap) ? gap : [\n        gap,\n        gap\n    ];\n    const scaledGap = [\n        gapXY[0] * transform[2] || 1,\n        gapXY[1] * transform[2] || 1\n    ];\n    const scaledSize = patternSize * transform[2];\n    const patternDimensions = isCross ? [\n        scaledSize,\n        scaledSize\n    ] : scaledGap;\n    const patternOffset = isDots ? [\n        scaledSize / offset,\n        scaledSize / offset\n    ] : [\n        patternDimensions[0] / offset,\n        patternDimensions[1] / offset\n    ];\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__background\",\n            className\n        ]),\n        style: {\n            ...style,\n            position: \"absolute\",\n            width: \"100%\",\n            height: \"100%\",\n            top: 0,\n            left: 0\n        },\n        ref: ref,\n        \"data-testid\": \"rf__background\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"pattern\", {\n        id: patternId + id,\n        x: transform[0] % scaledGap[0],\n        y: transform[1] % scaledGap[1],\n        width: scaledGap[0],\n        height: scaledGap[1],\n        patternUnits: \"userSpaceOnUse\",\n        patternTransform: `translate(-${patternOffset[0]},-${patternOffset[1]})`\n    }, isDots ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DotPattern, {\n        color: patternColor,\n        radius: scaledSize / offset\n    }) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LinePattern, {\n        dimensions: patternDimensions,\n        color: patternColor,\n        lineWidth: lineWidth\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        x: \"0\",\n        y: \"0\",\n        width: \"100%\",\n        height: \"100%\",\n        fill: `url(#${patternId + id})`\n    }));\n}\nBackground.displayName = \"Background\";\nvar Background$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(Background);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0ByZWFjdGZsb3cvYmFja2dyb3VuZC9kaXN0L2VzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRDO0FBQ2xCO0FBQ2lCO0FBQ0Q7QUFFMUMsSUFBSU07QUFDSCxVQUFVQSxpQkFBaUI7SUFDeEJBLGlCQUFpQixDQUFDLFFBQVEsR0FBRztJQUM3QkEsaUJBQWlCLENBQUMsT0FBTyxHQUFHO0lBQzVCQSxpQkFBaUIsQ0FBQyxRQUFRLEdBQUc7QUFDakMsR0FBR0EscUJBQXNCQSxDQUFBQSxvQkFBb0IsQ0FBQztBQUU5QyxTQUFTQyxZQUFZLEVBQUVDLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxTQUFTLEVBQUU7SUFDakQscUJBQVFWLGdEQUFtQixDQUFDLFFBQVE7UUFBRVksUUFBUUo7UUFBT0ssYUFBYUg7UUFBV0ksR0FBRyxDQUFDLENBQUMsRUFBRUwsVUFBVSxDQUFDLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRUEsVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUVBLFVBQVUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUVBLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUFDO0FBQzFLO0FBQ0EsU0FBU00sV0FBVyxFQUFFUCxLQUFLLEVBQUVRLE1BQU0sRUFBRTtJQUNqQyxxQkFBT2hCLGdEQUFtQixDQUFDLFVBQVU7UUFBRWlCLElBQUlEO1FBQVFFLElBQUlGO1FBQVFHLEdBQUdIO1FBQVFJLE1BQU1aO0lBQU07QUFDMUY7QUFFQSxNQUFNYSxlQUFlO0lBQ2pCLENBQUNmLGtCQUFrQmdCLElBQUksQ0FBQyxFQUFFO0lBQzFCLENBQUNoQixrQkFBa0JpQixLQUFLLENBQUMsRUFBRTtJQUMzQixDQUFDakIsa0JBQWtCa0IsS0FBSyxDQUFDLEVBQUU7QUFDL0I7QUFDQSxNQUFNQyxjQUFjO0lBQ2hCLENBQUNuQixrQkFBa0JnQixJQUFJLENBQUMsRUFBRTtJQUMxQixDQUFDaEIsa0JBQWtCaUIs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QUFDekIsSUFBSUMsNkJBQWU1RCwyQ0FBSUEsQ0FBQzhCO0FBRWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGxpZmUtZ3JhcGgvZnJvbnRlbmQyLy4uL25vZGVfbW9kdWxlcy9AcmVhY3RmbG93L2JhY2tncm91bmQvZGlzdC9lc20vaW5kZXgubWpzPzRmMzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IG1lbW8sIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjYyBmcm9tICdjbGFzc2NhdCc7XG5pbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ0ByZWFjdGZsb3cvY29yZSc7XG5pbXBvcnQgeyBzaGFsbG93IH0gZnJvbSAnenVzdGFuZC9zaGFsbG93JztcblxudmFyIEJhY2tncm91bmRWYXJpYW50O1xuKGZ1bmN0aW9uIChCYWNrZ3JvdW5kVmFyaWFudCkge1xuICAgIEJhY2tncm91bmRWYXJpYW50W1wiTGluZXNcIl0gPSBcImxpbmVzXCI7XG4gICAgQmFja2dyb3VuZFZhcmlhbnRbXCJEb3RzXCJdID0gXCJkb3RzXCI7XG4gICAgQmFja2dyb3VuZFZhcmlhbnRbXCJDcm9zc1wiXSA9IFwiY3Jvc3NcIjtcbn0pKEJhY2tncm91bmRWYXJpYW50IHx8IChCYWNrZ3JvdW5kVmFyaWFudCA9IHt9KSk7XG5cbmZ1bmN0aW9uIExpbmVQYXR0ZXJuKHsgY29sb3IsIGRpbWVuc2lvbnMsIGxpbmVXaWR0aCB9KSB7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IHN0cm9rZTogY29sb3IsIHN0cm9rZVdpZHRoOiBsaW5lV2lkdGgsIGQ6IGBNJHtkaW1lbnNpb25zWzBdIC8gMn0gMCBWJHtkaW1lbnNpb25zWzFdfSBNMCAke2RpbWVuc2lvbnNbMV0gLyAyfSBIJHtkaW1lbnNpb25zWzBdfWAgfSkpO1xufVxuZnVuY3Rpb24gRG90UGF0dGVybih7IGNvbG9yLCByYWRpdXMgfSkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHsgY3g6IHJhZGl1cywgY3k6IHJhZGl1cywgcjogcmFkaXVzLCBmaWxsOiBjb2xvciB9KTtcbn1cblxuY29uc3QgZGVmYXVsdENvbG9yID0ge1xuICAgIFtCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzXTogJyM5MTkxOWEnLFxuICAgIFtCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc106ICcjZWVlJyxcbiAgICBbQmFja2dyb3VuZFZhcmlhbnQuQ3Jvc3NdOiAnI2UyZTJlMicsXG59O1xuY29uc3QgZGVmYXVsdFNpemUgPSB7XG4gICAgW0JhY2tncm91bmRWYXJpYW50LkRvdHNdOiAxLFxuICAgIFtCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc106IDEsXG4gICAgW0JhY2tncm91bmRWYXJpYW50LkNyb3NzXTogNixcbn07XG5jb25zdCBzZWxlY3RvciA9IChzKSA9PiAoeyB0cmFuc2Zvcm06IHMudHJhbnNmb3JtLCBwYXR0ZXJuSWQ6IGBwYXR0ZXJuLSR7cy5yZklkfWAgfSk7XG5mdW5jdGlvbiBCYWNrZ3JvdW5kKHsgaWQsIHZhcmlhbnQgPSBCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzLCBcbi8vIG9ubHkgdXNlZCBmb3IgZG90cyBhbmQgY3Jvc3NcbmdhcCA9IDIwLCBcbi8vIG9ubHkgdXNlZCBmb3IgbGluZXMgYW5kIGNyb3NzXG5zaXplLCBsaW5lV2lkdGggPSAxLCBvZmZzZXQgPSAyLCBjb2xvciwgc3R5bGUsIGNsYXNzTmFtZSwgfSkge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCB7IHRyYW5zZm9ybSwgcGF0dGVybklkIH0gPSB1c2VTdG9yZShzZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgY29uc3QgcGF0dGVybkNvbG9yID0gY29sb3IgfHwgZGVmYXVsdENvbG9yW3ZhcmlhbnRdO1xuICAgIGNvbnN0IHBhdHRlcm5TaXplID0gc2l6ZSB8fCBkZWZhdWx0U2l6ZVt2YXJpYW50XTtcbiAgICBjb25zdCBpc0RvdHMgPSB2YXJpYW50ID09PSBCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzO1xuICAgIGNvbnN0IGlzQ3Jvc3MgPSB2YXJpYW50ID09PSBCYWNrZ3JvdW5kVmFyaWFudC5Dcm9zcztcbiAgICBjb25zdCBnYXBYWSA9IEFycmF5LmlzQXJyYXkoZ2FwKSA/IGdhcCA6IFtnYXAsIGdhcF07XG4gICAgY29uc3Qgc2NhbGVkR2FwID0gW2dhcFhZWzBdICogdHJhbnNmb3JtWzJdIHx8IDEsIGdhcFhZWzFdICogdHJhbnNmb3JtWzJdIHx8IDFdO1xuICAgIGNvbnN0IHNjYWxlZFNpemUgPSBwYXR0ZXJuU2l6ZSAqIHRyYW5zZm9ybVsyXTtcbiAgICBjb25zdCBwYXR0ZXJuRGltZW5zaW9ucyA9IGlzQ3Jvc3MgPyBbc2NhbGVkU2l6ZSwgc2NhbGVkU2l6ZV0gOiBzY2FsZWRHYXA7XG4gICAgY29uc3QgcGF0dGVybk9mZnNldCA9IGlzRG90c1xuICAgICAgICA/IFtzY2FsZWRTaXplIC8gb2Zmc2V0LCBzY2FsZWRTaXplIC8gb2Zmc2V0XVxuICAgICAgICA6IFtwYXR0ZXJuRGltZW5zaW9uc1swXSAvIG9mZnNldCwgcGF0dGVybkRpbWVuc2lvbnNbMV0gLyBvZmZzZXRdO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19iYWNrZ3JvdW5kJywgY2xhc3NOYW1lXSksIHN0eWxlOiB7XG4gICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgfSwgcmVmOiByZWYsIFwiZGF0YS10ZXN0aWRcIjogXCJyZl9fYmFja2dyb3VuZFwiIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXR0ZXJuXCIsIHsgaWQ6IHBhdHRlcm5JZCArIGlkLCB4OiB0cmFuc2Zvcm1bMF0gJSBzY2FsZWRHYXBbMF0sIHk6IHRyYW5zZm9ybVsxXSAlIHNjYWxlZEdhcFsxXSwgd2lkdGg6IHNjYWxlZEdhcFswXSwgaGVpZ2h0OiBzY2FsZWRHYXBbMV0sIHBhdHRlcm5Vbml0czogXCJ1c2VyU3BhY2VPblVzZVwiLCBwYXR0ZXJuVHJhbnNmb3JtOiBgdHJhbnNsYXRlKC0ke3BhdHRlcm5PZmZzZXRbMF19LC0ke3BhdHRlcm5PZmZzZXRbMV19KWAgfSwgaXNEb3RzID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRG90UGF0dGVybiwgeyBjb2xvcjogcGF0dGVybkNvbG9yLCByYWRpdXM6IHNjYWxlZFNpemUgLyBvZmZzZXQgfSkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGluZVBhdHRlcm4sIHsgZGltZW5zaW9uczogcGF0dGVybkRpbWVuc2lvbnMsIGNvbG9yOiBwYXR0ZXJuQ29sb3IsIGxpbmVXaWR0aDogbGluZVdpZHRoIH0pKSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHsgeDogXCIwXCIsIHk6IFwiMFwiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIsIGZpbGw6IGB1cmwoIyR7cGF0dGVybklkICsgaWR9KWAgfSkpKTtcbn1cbkJhY2tncm91bmQuZGlzcGxheU5hbWUgPSAnQmFja2dyb3VuZCc7XG52YXIgQmFja2dyb3VuZCQxID0gbWVtbyhCYWNrZ3JvdW5kKTtcblxuZXhwb3J0IHsgQmFja2dyb3VuZCQxIGFzIEJhY2tncm91bmQsIEJhY2tncm91bmRWYXJpYW50IH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJtZW1vIiwidXNlUmVmIiwiY2MiLCJ1c2VTdG9yZSIsInNoYWxsb3ciLCJCYWNrZ3JvdW5kVmFyaWFudCIsIkxpbmVQYXR0ZXJuIiwiY29sb3IiLCJkaW1lbnNpb25zIiwibGluZVdpZHRoIiwiY3JlYXRlRWxlbWVudCIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwiZCIsIkRvdFBhdHRlcm4iLCJyYWRpdXMiLCJjeCIsImN5IiwiciIsImZpbGwiLCJkZWZhdWx0Q29sb3IiLCJEb3RzIiwiTGluZXMiLCJDcm9zcyIsImRlZmF1bHRTaXplIiwic2VsZWN0b3IiLCJzIiwidHJhbnNmb3JtIiwicGF0dGVybklkIiwicmZJZCIsIkJhY2tncm91bmQiLCJpZCIsInZhcmlhbnQiLCJnYXAiLCJzaXplIiwib2Zmc2V0Iiwic3R5bGUiLCJjbGFzc05hbWUiLCJyZWYiLCJwYXR0ZXJuQ29sb3IiLCJwYXR0ZXJuU2l6ZSIsImlzRG90cyIsImlzQ3Jvc3MiLCJnYXBYWSIsIkFycmF5IiwiaXNBcnJheSIsInNjYWxlZEdhcCIsInNjYWxlZFNpemUiLCJwYXR0ZXJuRGltZW5zaW9ucyIsInBhdHRlcm5PZmZzZXQiLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwidG9wIiwibGVmdCIsIngiLCJ5IiwicGF0dGVyblVuaXRzIiwicGF0dGVyblRyYW5zZm9ybSIsImRpc3BsYXlOYW1lIiwiQmFja2dyb3VuZCQxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@reactflow/background/dist/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/@reactflow/controls/dist/esm/index.mjs":
/*!**************************************************************!*\
  !*** ../node_modules/@reactflow/controls/dist/esm/index.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ControlButton: () => (/* binding */ ControlButton),\n/* harmony export */   Controls: () => (/* binding */ Controls$1)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classcat */ \"(ssr)/../node_modules/classcat/index.js\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/../node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var _reactflow_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reactflow/core */ \"(ssr)/../node_modules/@reactflow/core/dist/esm/index.mjs\");\n\n\n\n\nfunction PlusIcon() {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 32\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z\"\n    }));\n}\nfunction MinusIcon() {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 5\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M0 0h32v4.2H0z\"\n    }));\n}\nfunction FitViewIcon() {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 30\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z\"\n    }));\n}\nfunction LockIcon() {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z\"\n    }));\n}\nfunction UnlockIcon() {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z\"\n    }));\n}\nconst ControlButton = ({ children, className, ...rest })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", {\n        type: \"button\",\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__controls-button\",\n            className\n        ]),\n        ...rest\n    }, children);\nControlButton.displayName = \"ControlButton\";\nconst selector = (s)=>({\n        isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,\n        minZoomReached: s.transform[2] <= s.minZoom,\n        maxZoomReached: s.transform[2] >= s.maxZoom\n    });\nconst Controls = ({ style, showZoom = true, showFitView = true, showInteractive = true, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children, position = \"bottom-left\" })=>{\n    const store = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_2__.useStoreApi)();\n    const [isVisible, setIsVisible] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const { isInteractive, minZoomReached, maxZoomReached } = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_2__.useStore)(selector, zustand_shallow__WEBPACK_IMPORTED_MODULE_3__.shallow);\n    const { zoomIn, zoomOut, fitView } = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_2__.useReactFlow)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setIsVisible(true);\n    }, []);\n    if (!isVisible) {\n        return null;\n    }\n    const onZoomInHandler = ()=>{\n        zoomIn();\n        onZoomIn?.();\n    };\n    const onZoomOutHandler = ()=>{\n        zoomOut();\n        onZoomOut?.();\n    };\n    const onFitViewHandler = ()=>{\n        fitView(fitViewOptions);\n        onFitView?.();\n    };\n    const onToggleInteractivity = ()=>{\n        store.setState({\n            nodesDraggable: !isInteractive,\n            nodesConnectable: !isInteractive,\n            elementsSelectable: !isInteractive\n        });\n        onInteractiveChange?.(!isInteractive);\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_reactflow_core__WEBPACK_IMPORTED_MODULE_2__.Panel, {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__controls\",\n            className\n        ]),\n        position: position,\n        style: style,\n        \"data-testid\": \"rf__controls\"\n    }, showZoom && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ControlButton, {\n        onClick: onZoomInHandler,\n        className: \"react-flow__controls-zoomin\",\n        title: \"zoom in\",\n        \"aria-label\": \"zoom in\",\n        disabled: maxZoomReached\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PlusIcon, null)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ControlButton, {\n        onClick: onZoomOutHandler,\n        className: \"react-flow__controls-zoomout\",\n        title: \"zoom out\",\n        \"aria-label\": \"zoom out\",\n        disabled: minZoomReached\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MinusIcon, null))), showFitView && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ControlButton, {\n        className: \"react-flow__controls-fitview\",\n        onClick: onFitViewHandler,\n        title: \"fit view\",\n        \"aria-label\": \"fit view\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FitViewIcon, null)), showInteractive && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ControlButton, {\n        className: \"react-flow__controls-interactive\",\n        onClick: onToggleInteractivity,\n        title: \"toggle interactivity\",\n        \"aria-label\": \"toggle interactivity\"\n    }, isInteractive ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(UnlockIcon, null) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LockIcon, null)), children);\n};\nControls.displayName = \"Controls\";\nvar Controls$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(Controls);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0ByZWFjdGZsb3cvY29udHJvbHMvZGlzdC9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF5RDtBQUMvQjtBQUNnQjtBQUNtQztBQUU3RSxTQUFTVTtJQUNMLHFCQUFRVixnREFBbUIsQ0FBQyxPQUFPO1FBQUVZLE9BQU87UUFBOEJDLFNBQVM7SUFBWSxpQkFDM0ZiLGdEQUFtQixDQUFDLFFBQVE7UUFBRWMsR0FBRztJQUF3RTtBQUNqSDtBQUVBLFNBQVNDO0lBQ0wscUJBQVFmLGdEQUFtQixDQUFDLE9BQU87UUFBRVksT0FBTztRQUE4QkMsU0FBUztJQUFXLGlCQUMxRmIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFYyxHQUFHO0lBQWlCO0FBQzFEO0FBRUEsU0FBU0U7SUFDTCxxQkFBUWhCLGdEQUFtQixDQUFDLE9BQU87UUFBRVksT0FBTztRQUE4QkMsU0FBUztJQUFZLGlCQUMzRmIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFYyxHQUFHO0lBQThYO0FBQ3ZhO0FBRUEsU0FBU0c7SUFDTCxxQkFBUWpCLGdEQUFtQixDQUFDLE9BQU87UUFBRVksT0FBTztRQUE4QkMsU0FBUztJQUFZLGlCQUMzRmIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFYyxHQUFHO0lBQWljO0FBQzFlO0FBRUEsU0FBU0k7SUFDTCxxQkFBUWxCLGdEQUFtQixDQUFDLE9BQU87UUFBRVksT0FBTztRQUE4QkMsU0FBUztJQUFZLGlCQUMzRmIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFYyxHQUFHO0lBQXVZO0FBQ2hiO0FBRUEsTUFBTUssZ0JBQWdCLENBQUMsRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQUUsR0FBR0MsTUFBTSxpQkFBTXRCLGdEQUFtQixDQUFDLFVBQVU7UUFBRXVCLE1BQU07UUFBVUYsV0FBV2pCLG9EQUFFQSxDQUFDO1lBQUM7WUFBK0JpQjtTQUFVO1FBQUcsR0FBR0MsSUFBSTtJQUFDLEdBQUdGO0FBQ25MRCxjQUFjSyxXQUFXLEdBQUc7QUFFNUIsTUFBTUMsV0FBVyxDQUFDQyxJQUFPO1FBQ3JCQyxlQUFlRCxFQUFFRSxjQUFjLElBQUlGLEVBQUVHLGdCQUFnQixJQUFJSCxFQUFFSSxrQkFBa0I7UUFDN0VDLGdCQUFnQkwsRUFBRU0sU0FBUyxDQUFDLEVBQUUsSUFBSU4sRUFBRU8sT0FBTztRQUMzQ0MsZ0JBQWdCUixFQUFFTSxTQUFTLENBQUMsRUFBRSxJQUFJTixFQUFFUyxPQUFPO0lBQy9DO0FBQ0EsTUFBTUMsV0FBVyxDQUFDLEVBQUVDLEtBQUssRUFBRUMsV0FBVyxJQUFJLEVBQUVDLGNBQWMsSUFBSSxFQUFFQyxrQkFBa0IsSUFBSSxFQUFFQyxjQUFjLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVDLG1CQUFtQixFQUFFeEIsU0FBUyxFQUFFRCxRQUFRLEVBQUUwQixXQUFXLGFBQWEsRUFBRztJQUN6TSxNQUFNQyxRQUFRekMsNERBQVdBO0lBQ3pCLE1BQU0sQ0FBQzBDLFdBQVdDLGFBQWEsR0FBRy9DLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sRUFBRXlCLGFBQWEsRUFBRUksY0FBYyxFQUFFRyxjQUFjLEVBQUUsR0FBRzNCLHlEQUFRQSxDQUFDa0IsVUFBVXBCLG9EQUFPQTtJQUNwRixNQUFNLEVBQUU2QyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFLEdBQUc1Qyw2REFBWUE7SUFDakRMLGdEQUFTQSxDQUFDO1FBQ044QyxhQUFhO0lBQ2pCLEdBQUcsRUFBRTtJQUNMLElBQUksQ0FBQ0QsV0FBVztRQUNaLE9BQU87SUFDWDtJQUNBLE1BQU1LLGtCQUFrQjtRQUNwQkg7UUFDQVI7SUFDSjtJQUNBLE1BQU1ZLG1CQUFtQjtRQUNyQkg7UUFDQVI7SUFDSjtJQUNBLE1BQU1ZLG1CQUFtQjtRQUNyQkgsUUFBUVg7UUFDUkc7SUFDSjtJQUNBLE1BQU1ZLHdCQUF3QjtRQUMxQlQsTUFBTVUsUUFBUSxDQUFDO1lBQ1g3QixnQkFBZ0IsQ0FBQ0Q7WUFDakJFLGtCQUFrQixDQUFDRjtZQUNuQkcsb0JBQW9CLENBQUNIO1FBQ3pCO1FBQ0FrQixzQkFBc0IsQ0FBQ2xCO0lBQzNCO0lBQ0EscUJBQVEzQixnREFBbUIsQ0FBQ1Msa0RBQUtBLEVBQUU7UUFBRVksV0FBV2pCLG9EQUFFQSxDQUFDO1lBQUM7WUFBd0JpQjtTQUFVO1FBQUd5QixVQUFVQTtRQUFVVCxPQUFPQTtRQUFPLGVBQWU7SUFBZSxHQUNySkMsMEJBQWF0QyxnREFBbUIsQ0FBQ0EsMkNBQWMsRUFBRSxvQkFDN0NBLGdEQUFtQixDQUFDbUIsZUFBZTtRQUFFd0MsU0FBU047UUFBaUJoQyxXQUFXO1FBQStCdUMsT0FBTztRQUFXLGNBQWM7UUFBV0MsVUFBVTNCO0lBQWUsaUJBQ3pLbEMsZ0RBQW1CLENBQUNVLFVBQVUsc0JBQ2xDVixnREFBbUIsQ0FBQ21CLGVBQWU7UUFBRXdDLFNBQVNMO1FBQWtCakMsV0FBVztRQUFnQ3VDLE9BQU87UUFBWSxjQUFjO1FBQVlDLFVBQVU5QjtJQUFlLGlCQUM3Sy9CLGdEQUFtQixDQUFDZSxXQUFXLFNBQ3ZDd0IsNkJBQWdCdkMsZ0RBQW1CLENBQUNtQixlQUFlO1FBQUVFLFdBQVc7UUFBZ0NzQyxTQUFTSjtRQUFrQkssT0FBTztRQUFZLGNBQWM7SUFBVyxpQkFDbks1RCxnREFBbUIsQ0FBQ2dCLGFBQWEsUUFDckN3QixpQ0FBb0J4QyxnREFBbUIsQ0FBQ21CLGVBQWU7UUFBRUUsV0FBVztRQUFvQ3NDLFNBQVNIO1FBQXVCSSxPQUFPO1FBQXdCLGNBQWM7SUFBdUIsR0FBR2pDLDhCQUFnQjNCLGdEQUFtQixDQUFDa0IsWUFBWSxzQkFBUWxCLGdEQUFtQixDQUFDaUIsVUFBVSxRQUNyU0c7QUFDUjtBQUNBZ0IsU0FBU1osV0FBVyxHQUFHO0FBQ3ZCLElBQUlzQywyQkFBYTdELDJDQUFJQSxDQUFDbUM7QUFFMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbGlmZS1ncmFwaC9mcm9udGVuZDIvLi4vbm9kZV9tb2R1bGVzL0ByZWFjdGZsb3cvY29udHJvbHMvZGlzdC9lc20vaW5kZXgubWpzPzYzMDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IG1lbW8sIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2MgZnJvbSAnY2xhc3NjYXQnO1xuaW1wb3J0IHsgc2hhbGxvdyB9IGZyb20gJ3p1c3RhbmQvc2hhbGxvdyc7XG5pbXBvcnQgeyB1c2VTdG9yZUFwaSwgdXNlU3RvcmUsIHVzZVJlYWN0RmxvdywgUGFuZWwgfSBmcm9tICdAcmVhY3RmbG93L2NvcmUnO1xuXG5mdW5jdGlvbiBQbHVzSWNvbigpIHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiAzMlwiIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMzIgMTguMTMzSDE4LjEzM1YzMmgtNC4yNjZWMTguMTMzSDB2LTQuMjY2aDEzLjg2N1YwaDQuMjY2djEzLjg2N0gzMnpcIiB9KSkpO1xufVxuXG5mdW5jdGlvbiBNaW51c0ljb24oKSB7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmlld0JveDogXCIwIDAgMzIgNVwiIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMCAwaDMydjQuMkgwelwiIH0pKSk7XG59XG5cbmZ1bmN0aW9uIEZpdFZpZXdJY29uKCkge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDMyIDMwXCIgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0zLjY5MiA0LjYzYzAtLjUzLjQtLjkzOC45MzktLjkzOGg1LjIxNVYwSDQuNzA4QzIuMTMgMCAwIDIuMDU0IDAgNC42M3Y1LjIxNmgzLjY5MlY0LjYzMXpNMjcuMzU0IDBoLTUuMnYzLjY5Mmg1LjE3Yy41MyAwIC45ODQuNC45ODQuOTM5djUuMjE1SDMyVjQuNjMxQTQuNjI0IDQuNjI0IDAgMDAyNy4zNTQgMHptLjk1NCAyNC44M2MwIC41MzItLjQuOTQtLjkzOS45NGgtNS4yMTV2My43NjhoNS4yMTVjMi41NzcgMCA0LjYzMS0yLjEzIDQuNjMxLTQuNzA3di01LjEzOWgtMy42OTJ2NS4xMzl6bS0yMy42NzcuOTRjLS41MzEgMC0uOTM5LS40LS45MzktLjk0di01LjEzOEgwdjUuMTM5YzAgMi41NzcgMi4xMyA0LjcwNyA0LjcwOCA0LjcwN2g1LjEzOFYyNS43N0g0LjYzMXpcIiB9KSkpO1xufVxuXG5mdW5jdGlvbiBMb2NrSWNvbigpIHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNSAzMlwiIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMjEuMzMzIDEwLjY2N0gxOS44MVY3LjYxOUMxOS44MSAzLjQyOSAxNi4zOCAwIDEyLjE5IDAgOCAwIDQuNTcxIDMuNDI5IDQuNTcxIDcuNjE5djMuMDQ4SDMuMDQ4QTMuMDU2IDMuMDU2IDAgMDAwIDEzLjcxNHYxNS4yMzhBMy4wNTYgMy4wNTYgMCAwMDMuMDQ4IDMyaDE4LjI4NWEzLjA1NiAzLjA1NiAwIDAwMy4wNDgtMy4wNDhWMTMuNzE0YTMuMDU2IDMuMDU2IDAgMDAtMy4wNDgtMy4wNDd6TTEyLjE5IDI0LjUzM2EzLjA1NiAzLjA1NiAwIDAxLTMuMDQ3LTMuMDQ3IDMuMDU2IDMuMDU2IDAgMDEzLjA0Ny0zLjA0OCAzLjA1NiAzLjA1NiAwIDAxMy4wNDggMy4wNDggMy4wNTYgMy4wNTYgMCAwMS0zLjA0OCAzLjA0N3ptNC43MjQtMTMuODY2SDcuNDY3VjcuNjE5YzAtMi41OSAyLjEzMy00LjcyNCA0LjcyMy00LjcyNCAyLjU5MSAwIDQuNzI0IDIuMTMzIDQuNzI0IDQuNzI0djMuMDQ4elwiIH0pKSk7XG59XG5cbmZ1bmN0aW9uIFVubG9ja0ljb24oKSB7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmlld0JveDogXCIwIDAgMjUgMzJcIiB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTIxLjMzMyAxMC42NjdIMTkuODFWNy42MTlDMTkuODEgMy40MjkgMTYuMzggMCAxMi4xOSAwYy00LjExNCAxLjgyOC0xLjM3IDIuMTMzLjMwNSAyLjQzOCAxLjY3Ni4zMDUgNC40MiAyLjU5IDQuNDIgNS4xODF2My4wNDhIMy4wNDdBMy4wNTYgMy4wNTYgMCAwMDAgMTMuNzE0djE1LjIzOEEzLjA1NiAzLjA1NiAwIDAwMy4wNDggMzJoMTguMjg1YTMuMDU2IDMuMDU2IDAgMDAzLjA0OC0zLjA0OFYxMy43MTRhMy4wNTYgMy4wNTYgMCAwMC0zLjA0OC0zLjA0N3pNMTIuMTkgMjQuNTMzYTMuMDU2IDMuMDU2IDAgMDEtMy4wNDctMy4wNDcgMy4wNTYgMy4wNTYgMCAwMTMuMDQ3LTMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEzLjA0OCAzLjA0OCAzLjA1NiAzLjA1NiAwIDAxLTMuMDQ4IDMuMDQ3elwiIH0pKSk7XG59XG5cbmNvbnN0IENvbnRyb2xCdXR0b24gPSAoeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCAuLi5yZXN0IH0pID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2NvbnRyb2xzLWJ1dHRvbicsIGNsYXNzTmFtZV0pLCAuLi5yZXN0IH0sIGNoaWxkcmVuKSk7XG5Db250cm9sQnV0dG9uLmRpc3BsYXlOYW1lID0gJ0NvbnRyb2xCdXR0b24nO1xuXG5jb25zdCBzZWxlY3RvciA9IChzKSA9PiAoe1xuICAgIGlzSW50ZXJhY3RpdmU6IHMubm9kZXNEcmFnZ2FibGUgfHwgcy5ub2Rlc0Nvbm5lY3RhYmxlIHx8IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIG1pblpvb21SZWFjaGVkOiBzLnRyYW5zZm9ybVsyXSA8PSBzLm1pblpvb20sXG4gICAgbWF4Wm9vbVJlYWNoZWQ6IHMudHJhbnNmb3JtWzJdID49IHMubWF4Wm9vbSxcbn0pO1xuY29uc3QgQ29udHJvbHMgPSAoeyBzdHlsZSwgc2hvd1pvb20gPSB0cnVlLCBzaG93Rml0VmlldyA9IHRydWUsIHNob3dJbnRlcmFjdGl2ZSA9IHRydWUsIGZpdFZpZXdPcHRpb25zLCBvblpvb21Jbiwgb25ab29tT3V0LCBvbkZpdFZpZXcsIG9uSW50ZXJhY3RpdmVDaGFuZ2UsIGNsYXNzTmFtZSwgY2hpbGRyZW4sIHBvc2l0aW9uID0gJ2JvdHRvbS1sZWZ0JywgfSkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBbaXNWaXNpYmxlLCBzZXRJc1Zpc2libGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHsgaXNJbnRlcmFjdGl2ZSwgbWluWm9vbVJlYWNoZWQsIG1heFpvb21SZWFjaGVkIH0gPSB1c2VTdG9yZShzZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgY29uc3QgeyB6b29tSW4sIHpvb21PdXQsIGZpdFZpZXcgfSA9IHVzZVJlYWN0RmxvdygpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldElzVmlzaWJsZSh0cnVlKTtcbiAgICB9LCBbXSk7XG4gICAgaWYgKCFpc1Zpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9uWm9vbUluSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgem9vbUluKCk7XG4gICAgICAgIG9uWm9vbUluPy4oKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uWm9vbU91dEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHpvb21PdXQoKTtcbiAgICAgICAgb25ab29tT3V0Py4oKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uRml0Vmlld0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGZpdFZpZXcoZml0Vmlld09wdGlvbnMpO1xuICAgICAgICBvbkZpdFZpZXc/LigpO1xuICAgIH07XG4gICAgY29uc3Qgb25Ub2dnbGVJbnRlcmFjdGl2aXR5ID0gKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBub2Rlc0RyYWdnYWJsZTogIWlzSW50ZXJhY3RpdmUsXG4gICAgICAgICAgICBub2Rlc0Nvbm5lY3RhYmxlOiAhaXNJbnRlcmFjdGl2ZSxcbiAgICAgICAgICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogIWlzSW50ZXJhY3RpdmUsXG4gICAgICAgIH0pO1xuICAgICAgICBvbkludGVyYWN0aXZlQ2hhbmdlPy4oIWlzSW50ZXJhY3RpdmUpO1xuICAgIH07XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFBhbmVsLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19jb250cm9scycsIGNsYXNzTmFtZV0pLCBwb3NpdGlvbjogcG9zaXRpb24sIHN0eWxlOiBzdHlsZSwgXCJkYXRhLXRlc3RpZFwiOiBcInJmX19jb250cm9sc1wiIH0sXG4gICAgICAgIHNob3dab29tICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb250cm9sQnV0dG9uLCB7IG9uQ2xpY2s6IG9uWm9vbUluSGFuZGxlciwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2NvbnRyb2xzLXpvb21pblwiLCB0aXRsZTogXCJ6b29tIGluXCIsIFwiYXJpYS1sYWJlbFwiOiBcInpvb20gaW5cIiwgZGlzYWJsZWQ6IG1heFpvb21SZWFjaGVkIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChQbHVzSWNvbiwgbnVsbCkpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb250cm9sQnV0dG9uLCB7IG9uQ2xpY2s6IG9uWm9vbU91dEhhbmRsZXIsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy16b29tb3V0XCIsIHRpdGxlOiBcInpvb20gb3V0XCIsIFwiYXJpYS1sYWJlbFwiOiBcInpvb20gb3V0XCIsIGRpc2FibGVkOiBtaW5ab29tUmVhY2hlZCB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWludXNJY29uLCBudWxsKSkpKSxcbiAgICAgICAgc2hvd0ZpdFZpZXcgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udHJvbEJ1dHRvbiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtZml0dmlld1wiLCBvbkNsaWNrOiBvbkZpdFZpZXdIYW5kbGVyLCB0aXRsZTogXCJmaXQgdmlld1wiLCBcImFyaWEtbGFiZWxcIjogXCJmaXQgdmlld1wiIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEZpdFZpZXdJY29uLCBudWxsKSkpLFxuICAgICAgICBzaG93SW50ZXJhY3RpdmUgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udHJvbEJ1dHRvbiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtaW50ZXJhY3RpdmVcIiwgb25DbGljazogb25Ub2dnbGVJbnRlcmFjdGl2aXR5LCB0aXRsZTogXCJ0b2dnbGUgaW50ZXJhY3Rpdml0eVwiLCBcImFyaWEtbGFiZWxcIjogXCJ0b2dnbGUgaW50ZXJhY3Rpdml0eVwiIH0sIGlzSW50ZXJhY3RpdmUgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFVubG9ja0ljb24sIG51bGwpIDogUmVhY3QuY3JlYXRlRWxlbWVudChMb2NrSWNvbiwgbnVsbCkpKSxcbiAgICAgICAgY2hpbGRyZW4pKTtcbn07XG5Db250cm9scy5kaXNwbGF5TmFtZSA9ICdDb250cm9scyc7XG52YXIgQ29udHJvbHMkMSA9IG1lbW8oQ29udHJvbHMpO1xuXG5leHBvcnQgeyBDb250cm9sQnV0dG9uLCBDb250cm9scyQxIGFzIENvbnRyb2xzIH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJtZW1vIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJjYyIsInNoYWxsb3ciLCJ1c2VTdG9yZUFwaSIsInVzZVN0b3JlIiwidXNlUmVhY3RGbG93IiwiUGFuZWwiLCJQbHVzSWNvbiIsImNyZWF0ZUVsZW1lbnQiLCJ4bWxucyIsInZpZXdCb3giLCJkIiwiTWludXNJY29uIiwiRml0Vmlld0ljb24iLCJMb2NrSWNvbiIsIlVubG9ja0ljb24iLCJDb250cm9sQnV0dG9uIiwiY2hpbGRyZW4iLCJjbGFzc05hbWUiLCJyZXN0IiwidHlwZSIsImRpc3BsYXlOYW1lIiwic2VsZWN0b3IiLCJzIiwiaXNJbnRlcmFjdGl2ZSIsIm5vZGVzRHJhZ2dhYmxlIiwibm9kZXNDb25uZWN0YWJsZSIsImVsZW1lbnRzU2VsZWN0YWJsZSIsIm1pblpvb21SZWFjaGVkIiwidHJhbnNmb3JtIiwibWluWm9vbSIsIm1heFpvb21SZWFjaGVkIiwibWF4Wm9vbSIsIkNvbnRyb2xzIiwic3R5bGUiLCJzaG93Wm9vbSIsInNob3dGaXRWaWV3Iiwic2hvd0ludGVyYWN0aXZlIiwiZml0Vmlld09wdGlvbnMiLCJvblpvb21JbiIsIm9uWm9vbU91dCIsIm9uRml0VmlldyIsIm9uSW50ZXJhY3RpdmVDaGFuZ2UiLCJwb3NpdGlvbiIsInN0b3JlIiwiaXNWaXNpYmxlIiwic2V0SXNWaXNpYmxlIiwiem9vbUluIiwiem9vbU91dCIsImZpdFZpZXciLCJvblpvb21JbkhhbmRsZXIiLCJvblpvb21PdXRIYW5kbGVyIiwib25GaXRWaWV3SGFuZGxlciIsIm9uVG9nZ2xlSW50ZXJhY3Rpdml0eSIsInNldFN0YXRlIiwiRnJhZ21lbnQiLCJvbkNsaWNrIiwidGl0bGUiLCJkaXNhYmxlZCIsIkNvbnRyb2xzJDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@reactflow/controls/dist/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/@reactflow/core/dist/esm/index.mjs":
/*!**********************************************************!*\
  !*** ../node_modules/@reactflow/core/dist/esm/index.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseEdge: () => (/* binding */ BaseEdge),\n/* harmony export */   BezierEdge: () => (/* binding */ BezierEdge),\n/* harmony export */   ConnectionLineType: () => (/* binding */ ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* binding */ ConnectionMode),\n/* harmony export */   EdgeLabelRenderer: () => (/* binding */ EdgeLabelRenderer),\n/* harmony export */   EdgeText: () => (/* binding */ EdgeText$1),\n/* harmony export */   Handle: () => (/* binding */ Handle$1),\n/* harmony export */   MarkerType: () => (/* binding */ MarkerType),\n/* harmony export */   PanOnScrollMode: () => (/* binding */ PanOnScrollMode),\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   ReactFlow: () => (/* binding */ ReactFlow),\n/* harmony export */   ReactFlowProvider: () => (/* binding */ ReactFlowProvider),\n/* harmony export */   SelectionMode: () => (/* binding */ SelectionMode),\n/* harmony export */   SimpleBezierEdge: () => (/* binding */ SimpleBezierEdge),\n/* harmony export */   SmoothStepEdge: () => (/* binding */ SmoothStepEdge),\n/* harmony export */   StepEdge: () => (/* binding */ StepEdge),\n/* harmony export */   StraightEdge: () => (/* binding */ StraightEdge),\n/* harmony export */   addEdge: () => (/* binding */ addEdge),\n/* harmony export */   applyEdgeChanges: () => (/* binding */ applyEdgeChanges),\n/* harmony export */   applyNodeChanges: () => (/* binding */ applyNodeChanges),\n/* harmony export */   boxToRect: () => (/* binding */ boxToRect),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   getBezierPath: () => (/* binding */ getBezierPath),\n/* harmony export */   getBoundsOfRects: () => (/* binding */ getBoundsOfRects),\n/* harmony export */   getConnectedEdges: () => (/* binding */ getConnectedEdges),\n/* harmony export */   getIncomers: () => (/* binding */ getIncomers),\n/* harmony export */   getMarkerEnd: () => (/* binding */ getMarkerEnd),\n/* harmony export */   getNodePositionWithOrigin: () => (/* binding */ getNodePositionWithOrigin),\n/* harmony export */   getNodesBounds: () => (/* binding */ getNodesBounds),\n/* harmony export */   getOutgoers: () => (/* binding */ getOutgoers),\n/* harmony export */   getRectOfNodes: () => (/* binding */ getRectOfNodes),\n/* harmony export */   getSimpleBezierPath: () => (/* binding */ getSimpleBezierPath),\n/* harmony export */   getSmoothStepPath: () => (/* binding */ getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* binding */ getStraightPath),\n/* harmony export */   getTransformForBounds: () => (/* binding */ getTransformForBounds),\n/* harmony export */   getViewportForBounds: () => (/* binding */ getViewportForBounds),\n/* harmony export */   handleParentExpand: () => (/* binding */ handleParentExpand),\n/* harmony export */   internalsSymbol: () => (/* binding */ internalsSymbol),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   rectToBox: () => (/* binding */ rectToBox),\n/* harmony export */   updateEdge: () => (/* binding */ updateEdge),\n/* harmony export */   useEdges: () => (/* binding */ useEdges),\n/* harmony export */   useEdgesState: () => (/* binding */ useEdgesState),\n/* harmony export */   useGetPointerPosition: () => (/* binding */ useGetPointerPosition),\n/* harmony export */   useKeyPress: () => (/* binding */ useKeyPress),\n/* harmony export */   useNodeId: () => (/* binding */ useNodeId),\n/* harmony export */   useNodes: () => (/* binding */ useNodes),\n/* harmony export */   useNodesInitialized: () => (/* binding */ useNodesInitialized),\n/* harmony export */   useNodesState: () => (/* binding */ useNodesState),\n/* harmony export */   useOnSelectionChange: () => (/* binding */ useOnSelectionChange),\n/* harmony export */   useOnViewportChange: () => (/* binding */ useOnViewportChange),\n/* harmony export */   useReactFlow: () => (/* binding */ useReactFlow),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStoreApi: () => (/* binding */ useStoreApi),\n/* harmony export */   useUpdateNodeInternals: () => (/* binding */ useUpdateNodeInternals),\n/* harmony export */   useViewport: () => (/* binding */ useViewport)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classcat */ \"(ssr)/../node_modules/classcat/index.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/../node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/../node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/../node_modules/d3-zoom/src/index.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ \"(ssr)/../node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-selection */ \"(ssr)/../node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-drag */ \"(ssr)/../node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\n\n\n\n\n\n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst Provider$1 = StoreContext.Provider;\nconst errorMessages = {\n    error001: ()=>\"[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001\",\n    error002: ()=>\"It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.\",\n    error003: (nodeType)=>`Node type \"${nodeType}\" not found. Using fallback type \"default\".`,\n    error004: ()=>\"The React Flow parent container needs a width and a height to render the graph.\",\n    error005: ()=>\"Only child nodes can use a parent extent.\",\n    error006: ()=>\"Can't create edge. An edge needs a source and a target.\",\n    error007: (id)=>`The old edge with id=${id} does not exist.`,\n    error009: (type)=>`Marker type \"${type}\" doesn't exist.`,\n    error008: (sourceHandle, edge)=>`Couldn't create edge for ${!sourceHandle ? \"source\" : \"target\"} handle id: \"${!sourceHandle ? edge.sourceHandle : edge.targetHandle}\", edge id: ${edge.id}.`,\n    error010: ()=>\"Handle: No node id found. Make sure to only use a Handle inside a custom Node.\",\n    error011: (edgeType)=>`Edge type \"${edgeType}\" not found. Using fallback type \"default\".`,\n    error012: (id)=>`Node with id \"${id}\" does not exist, it may have been removed. This can happen when a node is deleted before the \"onNodeClick\" handler is called.`\n};\nconst zustandErrorMessage = errorMessages[\"error001\"]();\nfunction useStore(selector, equalityFn) {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_4__.useStoreWithEqualityFn)(store, selector, equalityFn);\n}\nconst useStoreApi = ()=>{\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            getState: store.getState,\n            setState: store.setState,\n            subscribe: store.subscribe,\n            destroy: store.destroy\n        }), [\n        store\n    ]);\n};\nconst selector$g = (s)=>s.userSelectionActive ? \"none\" : \"all\";\nfunction Panel({ position, children, className, style, ...rest }) {\n    const pointerEvents = useStore(selector$g);\n    const positionClasses = `${position}`.split(\"-\");\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__panel\",\n            className,\n            ...positionClasses\n        ]),\n        style: {\n            ...style,\n            pointerEvents\n        },\n        ...rest\n    }, children);\n}\nfunction Attribution({ proOptions, position = \"bottom-right\" }) {\n    if (proOptions?.hideAttribution) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Panel, {\n        position: position,\n        className: \"react-flow__attribution\",\n        \"data-message\": \"Please only hide this attribution when you are subscribed to React Flow Pro: https://reactflow.dev/pro\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", {\n        href: \"https://reactflow.dev\",\n        target: \"_blank\",\n        rel: \"noopener noreferrer\",\n        \"aria-label\": \"React Flow attribution\"\n    }, \"React Flow\"));\n}\nconst EdgeText = ({ x, y, label, labelStyle = {}, labelShowBg = true, labelBgStyle = {}, labelBgPadding = [\n    2,\n    4\n], labelBgBorderRadius = 2, children, className, ...rest })=>{\n    const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [edgeTextBbox, setEdgeTextBbox] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n    });\n    const edgeTextClasses = (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        \"react-flow__edge-textwrapper\",\n        className\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (edgeRef.current) {\n            const textBbox = edgeRef.current.getBBox();\n            setEdgeTextBbox({\n                x: textBbox.x,\n                y: textBbox.y,\n                width: textBbox.width,\n                height: textBbox.height\n            });\n        }\n    }, [\n        label\n    ]);\n    if (typeof label === \"undefined\" || !label) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n        transform: `translate(${x - edgeTextBbox.width / 2} ${y - edgeTextBbox.height / 2})`,\n        className: edgeTextClasses,\n        visibility: edgeTextBbox.width ? \"visible\" : \"hidden\",\n        ...rest\n    }, labelShowBg && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        width: edgeTextBbox.width + 2 * labelBgPadding[0],\n        x: -labelBgPadding[0],\n        y: -labelBgPadding[1],\n        height: edgeTextBbox.height + 2 * labelBgPadding[1],\n        className: \"react-flow__edge-textbg\",\n        style: labelBgStyle,\n        rx: labelBgBorderRadius,\n        ry: labelBgBorderRadius\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"text\", {\n        className: \"react-flow__edge-text\",\n        y: edgeTextBbox.height / 2,\n        dy: \"0.3em\",\n        ref: edgeRef,\n        style: labelStyle\n    }, label), children);\n};\nvar EdgeText$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(EdgeText);\nconst getDimensions = (node)=>({\n        width: node.offsetWidth,\n        height: node.offsetHeight\n    });\nconst clamp = (val, min = 0, max = 1)=>Math.min(Math.max(val, min), max);\nconst clampPosition = (position = {\n    x: 0,\n    y: 0\n}, extent)=>({\n        x: clamp(position.x, extent[0][0], extent[1][0]),\n        y: clamp(position.y, extent[0][1], extent[1][1])\n    });\n// returns a number between 0 and 1 that represents the velocity of the movement\n// when the mouse is close to the edge of the canvas\nconst calcAutoPanVelocity = (value, min, max)=>{\n    if (value < min) {\n        return clamp(Math.abs(value - min), 1, 50) / 50;\n    } else if (value > max) {\n        return -clamp(Math.abs(value - max), 1, 50) / 50;\n    }\n    return 0;\n};\nconst calcAutoPan = (pos, bounds)=>{\n    const xMovement = calcAutoPanVelocity(pos.x, 35, bounds.width - 35) * 20;\n    const yMovement = calcAutoPanVelocity(pos.y, 35, bounds.height - 35) * 20;\n    return [\n        xMovement,\n        yMovement\n    ];\n};\nconst getHostForElement = (element)=>element.getRootNode?.() || window?.document;\nconst getBoundsOfBoxes = (box1, box2)=>({\n        x: Math.min(box1.x, box2.x),\n        y: Math.min(box1.y, box2.y),\n        x2: Math.max(box1.x2, box2.x2),\n        y2: Math.max(box1.y2, box2.y2)\n    });\nconst rectToBox = ({ x, y, width, height })=>({\n        x,\n        y,\n        x2: x + width,\n        y2: y + height\n    });\nconst boxToRect = ({ x, y, x2, y2 })=>({\n        x,\n        y,\n        width: x2 - x,\n        height: y2 - y\n    });\nconst nodeToRect = (node)=>({\n        ...node.positionAbsolute || {\n            x: 0,\n            y: 0\n        },\n        width: node.width || 0,\n        height: node.height || 0\n    });\nconst getBoundsOfRects = (rect1, rect2)=>boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));\nconst getOverlappingArea = (rectA, rectB)=>{\n    const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n    const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n    return Math.ceil(xOverlap * yOverlap);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isRectObject = (obj)=>isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */ const isNumeric = (n)=>!isNaN(n) && isFinite(n);\nconst internalsSymbol = Symbol.for(\"internals\");\n// used for a11y key board controls for nodes and edges\nconst elementSelectionKeys = [\n    \"Enter\",\n    \" \",\n    \"Escape\"\n];\nconst devWarn = (id, message)=>{\n    if (true) {\n        console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id}`);\n    }\n};\nconst isReactKeyboardEvent = (event)=>\"nativeEvent\" in event;\nfunction isInputDOMNode(event) {\n    const kbEvent = isReactKeyboardEvent(event) ? event.nativeEvent : event;\n    // using composed path for handling shadow dom\n    const target = kbEvent.composedPath?.()?.[0] || event.target;\n    const isInput = [\n        \"INPUT\",\n        \"SELECT\",\n        \"TEXTAREA\"\n    ].includes(target?.nodeName) || target?.hasAttribute(\"contenteditable\");\n    // when an input field is focused we don't want to trigger deletion or movement of nodes\n    return isInput || !!target?.closest(\".nokey\");\n}\nconst isMouseEvent = (event)=>\"clientX\" in event;\nconst getEventPosition = (event, bounds)=>{\n    const isMouseTriggered = isMouseEvent(event);\n    const evtX = isMouseTriggered ? event.clientX : event.touches?.[0].clientX;\n    const evtY = isMouseTriggered ? event.clientY : event.touches?.[0].clientY;\n    return {\n        x: evtX - (bounds?.left ?? 0),\n        y: evtY - (bounds?.top ?? 0)\n    };\n};\nconst isMacOs = ()=>typeof navigator !== \"undefined\" && navigator?.userAgent?.indexOf(\"Mac\") >= 0;\nconst BaseEdge = ({ id, path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth = 20 })=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        id: id,\n        style: style,\n        d: path,\n        fill: \"none\",\n        className: \"react-flow__edge-path\",\n        markerEnd: markerEnd,\n        markerStart: markerStart\n    }), interactionWidth && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: path,\n        fill: \"none\",\n        strokeOpacity: 0,\n        strokeWidth: interactionWidth,\n        className: \"react-flow__edge-interaction\"\n    }), label && isNumeric(labelX) && isNumeric(labelY) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeText$1, {\n        x: labelX,\n        y: labelY,\n        label: label,\n        labelStyle: labelStyle,\n        labelShowBg: labelShowBg,\n        labelBgStyle: labelBgStyle,\n        labelBgPadding: labelBgPadding,\n        labelBgBorderRadius: labelBgBorderRadius\n    }) : null);\n};\nBaseEdge.displayName = \"BaseEdge\";\nconst getMarkerEnd = (markerType, markerEndId)=>{\n    if (typeof markerEndId !== \"undefined\" && markerEndId) {\n        return `url(#${markerEndId})`;\n    }\n    return typeof markerType !== \"undefined\" ? `url(#react-flow__${markerType})` : \"none\";\n};\nfunction getMouseHandler$1(id, getState, handler) {\n    return handler === undefined ? handler : (event)=>{\n        const edge = getState().edges.find((e)=>e.id === id);\n        if (edge) {\n            handler(event, {\n                ...edge\n            });\n        }\n    };\n}\n// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)\nfunction getEdgeCenter({ sourceX, sourceY, targetX, targetY }) {\n    const xOffset = Math.abs(targetX - sourceX) / 2;\n    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;\n    const yOffset = Math.abs(targetY - sourceY) / 2;\n    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;\n    return [\n        centerX,\n        centerY,\n        xOffset,\n        yOffset\n    ];\n}\nfunction getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY }) {\n    // cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate\n    // https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve\n    const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;\n    const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;\n    const offsetX = Math.abs(centerX - sourceX);\n    const offsetY = Math.abs(centerY - sourceY);\n    return [\n        centerX,\n        centerY,\n        offsetX,\n        offsetY\n    ];\n}\nvar ConnectionMode;\n(function(ConnectionMode) {\n    ConnectionMode[\"Strict\"] = \"strict\";\n    ConnectionMode[\"Loose\"] = \"loose\";\n})(ConnectionMode || (ConnectionMode = {}));\nvar PanOnScrollMode;\n(function(PanOnScrollMode) {\n    PanOnScrollMode[\"Free\"] = \"free\";\n    PanOnScrollMode[\"Vertical\"] = \"vertical\";\n    PanOnScrollMode[\"Horizontal\"] = \"horizontal\";\n})(PanOnScrollMode || (PanOnScrollMode = {}));\nvar SelectionMode;\n(function(SelectionMode) {\n    SelectionMode[\"Partial\"] = \"partial\";\n    SelectionMode[\"Full\"] = \"full\";\n})(SelectionMode || (SelectionMode = {}));\nvar ConnectionLineType;\n(function(ConnectionLineType) {\n    ConnectionLineType[\"Bezier\"] = \"default\";\n    ConnectionLineType[\"Straight\"] = \"straight\";\n    ConnectionLineType[\"Step\"] = \"step\";\n    ConnectionLineType[\"SmoothStep\"] = \"smoothstep\";\n    ConnectionLineType[\"SimpleBezier\"] = \"simplebezier\";\n})(ConnectionLineType || (ConnectionLineType = {}));\nvar MarkerType;\n(function(MarkerType) {\n    MarkerType[\"Arrow\"] = \"arrow\";\n    MarkerType[\"ArrowClosed\"] = \"arrowclosed\";\n})(MarkerType || (MarkerType = {}));\nvar Position;\n(function(Position) {\n    Position[\"Left\"] = \"left\";\n    Position[\"Top\"] = \"top\";\n    Position[\"Right\"] = \"right\";\n    Position[\"Bottom\"] = \"bottom\";\n})(Position || (Position = {}));\nfunction getControl({ pos, x1, y1, x2, y2 }) {\n    if (pos === Position.Left || pos === Position.Right) {\n        return [\n            0.5 * (x1 + x2),\n            y1\n        ];\n    }\n    return [\n        x1,\n        0.5 * (y1 + y2)\n    ];\n}\nfunction getSimpleBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top }) {\n    const [sourceControlX, sourceControlY] = getControl({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY\n    });\n    const [targetControlX, targetControlY] = getControl({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nconst SimpleBezierEdge = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n    const [path, labelX, labelY] = getSimpleBezierPath({\n        sourceX,\n        sourceY,\n        sourcePosition,\n        targetX,\n        targetY,\n        targetPosition\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseEdge, {\n        path: path,\n        labelX: labelX,\n        labelY: labelY,\n        label: label,\n        labelStyle: labelStyle,\n        labelShowBg: labelShowBg,\n        labelBgStyle: labelBgStyle,\n        labelBgPadding: labelBgPadding,\n        labelBgBorderRadius: labelBgBorderRadius,\n        style: style,\n        markerEnd: markerEnd,\n        markerStart: markerStart,\n        interactionWidth: interactionWidth\n    });\n});\nSimpleBezierEdge.displayName = \"SimpleBezierEdge\";\nconst handleDirections = {\n    [Position.Left]: {\n        x: -1,\n        y: 0\n    },\n    [Position.Right]: {\n        x: 1,\n        y: 0\n    },\n    [Position.Top]: {\n        x: 0,\n        y: -1\n    },\n    [Position.Bottom]: {\n        x: 0,\n        y: 1\n    }\n};\nconst getDirection = ({ source, sourcePosition = Position.Bottom, target })=>{\n    if (sourcePosition === Position.Left || sourcePosition === Position.Right) {\n        return source.x < target.x ? {\n            x: 1,\n            y: 0\n        } : {\n            x: -1,\n            y: 0\n        };\n    }\n    return source.y < target.y ? {\n        x: 0,\n        y: 1\n    } : {\n        x: 0,\n        y: -1\n    };\n};\nconst distance = (a, b)=>Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n// ith this function we try to mimic a orthogonal edge routing behaviour\n// It's not as good as a real orthogonal edge routing but it's faster and good enough as a default for step and smooth step edges\nfunction getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset }) {\n    const sourceDir = handleDirections[sourcePosition];\n    const targetDir = handleDirections[targetPosition];\n    const sourceGapped = {\n        x: source.x + sourceDir.x * offset,\n        y: source.y + sourceDir.y * offset\n    };\n    const targetGapped = {\n        x: target.x + targetDir.x * offset,\n        y: target.y + targetDir.y * offset\n    };\n    const dir = getDirection({\n        source: sourceGapped,\n        sourcePosition,\n        target: targetGapped\n    });\n    const dirAccessor = dir.x !== 0 ? \"x\" : \"y\";\n    const currDir = dir[dirAccessor];\n    let points = [];\n    let centerX, centerY;\n    const sourceGapOffset = {\n        x: 0,\n        y: 0\n    };\n    const targetGapOffset = {\n        x: 0,\n        y: 0\n    };\n    const [defaultCenterX, defaultCenterY, defaultOffsetX, defaultOffsetY] = getEdgeCenter({\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y\n    });\n    // opposite handle positions, default case\n    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {\n        centerX = center.x || defaultCenterX;\n        centerY = center.y || defaultCenterY;\n        //    --->\n        //    |\n        // >---\n        const verticalSplit = [\n            {\n                x: centerX,\n                y: sourceGapped.y\n            },\n            {\n                x: centerX,\n                y: targetGapped.y\n            }\n        ];\n        //    |\n        //  ---\n        //  |\n        const horizontalSplit = [\n            {\n                x: sourceGapped.x,\n                y: centerY\n            },\n            {\n                x: targetGapped.x,\n                y: centerY\n            }\n        ];\n        if (sourceDir[dirAccessor] === currDir) {\n            points = dirAccessor === \"x\" ? verticalSplit : horizontalSplit;\n        } else {\n            points = dirAccessor === \"x\" ? horizontalSplit : verticalSplit;\n        }\n    } else {\n        // sourceTarget means we take x from source and y from target, targetSource is the opposite\n        const sourceTarget = [\n            {\n                x: sourceGapped.x,\n                y: targetGapped.y\n            }\n        ];\n        const targetSource = [\n            {\n                x: targetGapped.x,\n                y: sourceGapped.y\n            }\n        ];\n        // this handles edges with same handle positions\n        if (dirAccessor === \"x\") {\n            points = sourceDir.x === currDir ? targetSource : sourceTarget;\n        } else {\n            points = sourceDir.y === currDir ? sourceTarget : targetSource;\n        }\n        if (sourcePosition === targetPosition) {\n            const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);\n            // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target\n            if (diff <= offset) {\n                const gapOffset = Math.min(offset - 1, offset - diff);\n                if (sourceDir[dirAccessor] === currDir) {\n                    sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;\n                } else {\n                    targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n            }\n        }\n        // these are conditions for handling mixed handle positions like Right -> Bottom for example\n        if (sourcePosition !== targetPosition) {\n            const dirAccessorOpposite = dirAccessor === \"x\" ? \"y\" : \"x\";\n            const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];\n            const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];\n            const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];\n            const flipSourceTarget = sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo);\n            if (flipSourceTarget) {\n                points = dirAccessor === \"x\" ? sourceTarget : targetSource;\n            }\n        }\n        const sourceGapPoint = {\n            x: sourceGapped.x + sourceGapOffset.x,\n            y: sourceGapped.y + sourceGapOffset.y\n        };\n        const targetGapPoint = {\n            x: targetGapped.x + targetGapOffset.x,\n            y: targetGapped.y + targetGapOffset.y\n        };\n        const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));\n        const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));\n        // we want to place the label on the longest segment of the edge\n        if (maxXDistance >= maxYDistance) {\n            centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;\n            centerY = points[0].y;\n        } else {\n            centerX = points[0].x;\n            centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;\n        }\n    }\n    const pathPoints = [\n        source,\n        {\n            x: sourceGapped.x + sourceGapOffset.x,\n            y: sourceGapped.y + sourceGapOffset.y\n        },\n        ...points,\n        {\n            x: targetGapped.x + targetGapOffset.x,\n            y: targetGapped.y + targetGapOffset.y\n        },\n        target\n    ];\n    return [\n        pathPoints,\n        centerX,\n        centerY,\n        defaultOffsetX,\n        defaultOffsetY\n    ];\n}\nfunction getBend(a, b, c, size) {\n    const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);\n    const { x, y } = b;\n    // no bend\n    if (a.x === x && x === c.x || a.y === y && y === c.y) {\n        return `L${x} ${y}`;\n    }\n    // first segment is horizontal\n    if (a.y === y) {\n        const xDir = a.x < c.x ? -1 : 1;\n        const yDir = a.y < c.y ? 1 : -1;\n        return `L ${x + bendSize * xDir},${y}Q ${x},${y} ${x},${y + bendSize * yDir}`;\n    }\n    const xDir = a.x < c.x ? 1 : -1;\n    const yDir = a.y < c.y ? -1 : 1;\n    return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;\n}\nfunction getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20 }) {\n    const [points, labelX, labelY, offsetX, offsetY] = getPoints({\n        source: {\n            x: sourceX,\n            y: sourceY\n        },\n        sourcePosition,\n        target: {\n            x: targetX,\n            y: targetY\n        },\n        targetPosition,\n        center: {\n            x: centerX,\n            y: centerY\n        },\n        offset\n    });\n    const path = points.reduce((res, p, i)=>{\n        let segment = \"\";\n        if (i > 0 && i < points.length - 1) {\n            segment = getBend(points[i - 1], p, points[i + 1], borderRadius);\n        } else {\n            segment = `${i === 0 ? \"M\" : \"L\"}${p.x} ${p.y}`;\n        }\n        res += segment;\n        return res;\n    }, \"\");\n    return [\n        path,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nconst SmoothStepEdge = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, sourcePosition = Position.Bottom, targetPosition = Position.Top, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n    const [path, labelX, labelY] = getSmoothStepPath({\n        sourceX,\n        sourceY,\n        sourcePosition,\n        targetX,\n        targetY,\n        targetPosition,\n        borderRadius: pathOptions?.borderRadius,\n        offset: pathOptions?.offset\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseEdge, {\n        path: path,\n        labelX: labelX,\n        labelY: labelY,\n        label: label,\n        labelStyle: labelStyle,\n        labelShowBg: labelShowBg,\n        labelBgStyle: labelBgStyle,\n        labelBgPadding: labelBgPadding,\n        labelBgBorderRadius: labelBgBorderRadius,\n        style: style,\n        markerEnd: markerEnd,\n        markerStart: markerStart,\n        interactionWidth: interactionWidth\n    });\n});\nSmoothStepEdge.displayName = \"SmoothStepEdge\";\nconst StepEdge = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)((props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SmoothStepEdge, {\n        ...props,\n        pathOptions: (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                borderRadius: 0,\n                offset: props.pathOptions?.offset\n            }), [\n            props.pathOptions?.offset\n        ])\n    }));\nStepEdge.displayName = \"StepEdge\";\nfunction getStraightPath({ sourceX, sourceY, targetX, targetY }) {\n    const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY\n    });\n    return [\n        `M ${sourceX},${sourceY}L ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nconst StraightEdge = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n    const [path, labelX, labelY] = getStraightPath({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseEdge, {\n        path: path,\n        labelX: labelX,\n        labelY: labelY,\n        label: label,\n        labelStyle: labelStyle,\n        labelShowBg: labelShowBg,\n        labelBgStyle: labelBgStyle,\n        labelBgPadding: labelBgPadding,\n        labelBgBorderRadius: labelBgBorderRadius,\n        style: style,\n        markerEnd: markerEnd,\n        markerStart: markerStart,\n        interactionWidth: interactionWidth\n    });\n});\nStraightEdge.displayName = \"StraightEdge\";\nfunction calculateControlOffset(distance, curvature) {\n    if (distance >= 0) {\n        return 0.5 * distance;\n    }\n    return curvature * 25 * Math.sqrt(-distance);\n}\nfunction getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {\n    switch(pos){\n        case Position.Left:\n            return [\n                x1 - calculateControlOffset(x1 - x2, c),\n                y1\n            ];\n        case Position.Right:\n            return [\n                x1 + calculateControlOffset(x2 - x1, c),\n                y1\n            ];\n        case Position.Top:\n            return [\n                x1,\n                y1 - calculateControlOffset(y1 - y2, c)\n            ];\n        case Position.Bottom:\n            return [\n                x1,\n                y1 + calculateControlOffset(y2 - y1, c)\n            ];\n    }\n}\nfunction getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25 }) {\n    const [sourceControlX, sourceControlY] = getControlWithCurvature({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY,\n        c: curvature\n    });\n    const [targetControlX, targetControlY] = getControlWithCurvature({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY,\n        c: curvature\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nconst BezierEdge = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n    const [path, labelX, labelY] = getBezierPath({\n        sourceX,\n        sourceY,\n        sourcePosition,\n        targetX,\n        targetY,\n        targetPosition,\n        curvature: pathOptions?.curvature\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseEdge, {\n        path: path,\n        labelX: labelX,\n        labelY: labelY,\n        label: label,\n        labelStyle: labelStyle,\n        labelShowBg: labelShowBg,\n        labelBgStyle: labelBgStyle,\n        labelBgPadding: labelBgPadding,\n        labelBgBorderRadius: labelBgBorderRadius,\n        style: style,\n        markerEnd: markerEnd,\n        markerStart: markerStart,\n        interactionWidth: interactionWidth\n    });\n});\nBezierEdge.displayName = \"BezierEdge\";\nconst NodeIdContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst Provider = NodeIdContext.Provider;\nNodeIdContext.Consumer;\nconst useNodeId = ()=>{\n    const nodeId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NodeIdContext);\n    return nodeId;\n};\nconst isEdge = (element)=>\"id\" in element && \"source\" in element && \"target\" in element;\nconst isNode = (element)=>\"id\" in element && !(\"source\" in element) && !(\"target\" in element);\nconst getOutgoers = (node, nodes, edges)=>{\n    if (!isNode(node)) {\n        return [];\n    }\n    const outgoerIds = edges.filter((e)=>e.source === node.id).map((e)=>e.target);\n    return nodes.filter((n)=>outgoerIds.includes(n.id));\n};\nconst getIncomers = (node, nodes, edges)=>{\n    if (!isNode(node)) {\n        return [];\n    }\n    const incomersIds = edges.filter((e)=>e.target === node.id).map((e)=>e.source);\n    return nodes.filter((n)=>incomersIds.includes(n.id));\n};\nconst getEdgeId = ({ source, sourceHandle, target, targetHandle })=>`reactflow__edge-${source}${sourceHandle || \"\"}-${target}${targetHandle || \"\"}`;\nconst getMarkerId = (marker, rfId)=>{\n    if (typeof marker === \"undefined\") {\n        return \"\";\n    }\n    if (typeof marker === \"string\") {\n        return marker;\n    }\n    const idPrefix = rfId ? `${rfId}__` : \"\";\n    return `${idPrefix}${Object.keys(marker).sort().map((key)=>`${key}=${marker[key]}`).join(\"&\")}`;\n};\nconst connectionExists = (edge, edges)=>{\n    return edges.some((el)=>el.source === edge.source && el.target === edge.target && (el.sourceHandle === edge.sourceHandle || !el.sourceHandle && !edge.sourceHandle) && (el.targetHandle === edge.targetHandle || !el.targetHandle && !edge.targetHandle));\n};\nconst addEdge = (edgeParams, edges)=>{\n    if (!edgeParams.source || !edgeParams.target) {\n        devWarn(\"006\", errorMessages[\"error006\"]());\n        return edges;\n    }\n    let edge;\n    if (isEdge(edgeParams)) {\n        edge = {\n            ...edgeParams\n        };\n    } else {\n        edge = {\n            ...edgeParams,\n            id: getEdgeId(edgeParams)\n        };\n    }\n    if (connectionExists(edge, edges)) {\n        return edges;\n    }\n    return edges.concat(edge);\n};\nconst updateEdge = (oldEdge, newConnection, edges, options = {\n    shouldReplaceId: true\n})=>{\n    const { id: oldEdgeId, ...rest } = oldEdge;\n    if (!newConnection.source || !newConnection.target) {\n        devWarn(\"006\", errorMessages[\"error006\"]());\n        return edges;\n    }\n    const foundEdge = edges.find((e)=>e.id === oldEdgeId);\n    if (!foundEdge) {\n        devWarn(\"007\", errorMessages[\"error007\"](oldEdgeId));\n        return edges;\n    }\n    // Remove old edge and create the new edge with parameters of old edge.\n    const edge = {\n        ...rest,\n        id: options.shouldReplaceId ? getEdgeId(newConnection) : oldEdgeId,\n        source: newConnection.source,\n        target: newConnection.target,\n        sourceHandle: newConnection.sourceHandle,\n        targetHandle: newConnection.targetHandle\n    };\n    return edges.filter((e)=>e.id !== oldEdgeId).concat(edge);\n};\nconst pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid, [snapX, snapY])=>{\n    const position = {\n        x: (x - tx) / tScale,\n        y: (y - ty) / tScale\n    };\n    if (snapToGrid) {\n        return {\n            x: snapX * Math.round(position.x / snapX),\n            y: snapY * Math.round(position.y / snapY)\n        };\n    }\n    return position;\n};\nconst rendererPointToPoint = ({ x, y }, [tx, ty, tScale])=>{\n    return {\n        x: x * tScale + tx,\n        y: y * tScale + ty\n    };\n};\nconst getNodePositionWithOrigin = (node, nodeOrigin = [\n    0,\n    0\n])=>{\n    if (!node) {\n        return {\n            x: 0,\n            y: 0,\n            positionAbsolute: {\n                x: 0,\n                y: 0\n            }\n        };\n    }\n    const offsetX = (node.width ?? 0) * nodeOrigin[0];\n    const offsetY = (node.height ?? 0) * nodeOrigin[1];\n    const position = {\n        x: node.position.x - offsetX,\n        y: node.position.y - offsetY\n    };\n    return {\n        ...position,\n        positionAbsolute: node.positionAbsolute ? {\n            x: node.positionAbsolute.x - offsetX,\n            y: node.positionAbsolute.y - offsetY\n        } : position\n    };\n};\nconst getNodesBounds = (nodes, nodeOrigin = [\n    0,\n    0\n])=>{\n    if (nodes.length === 0) {\n        return {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        };\n    }\n    const box = nodes.reduce((currBox, node)=>{\n        const { x, y } = getNodePositionWithOrigin(node, nodeOrigin).positionAbsolute;\n        return getBoundsOfBoxes(currBox, rectToBox({\n            x,\n            y,\n            width: node.width || 0,\n            height: node.height || 0\n        }));\n    }, {\n        x: Infinity,\n        y: Infinity,\n        x2: -Infinity,\n        y2: -Infinity\n    });\n    return boxToRect(box);\n};\n// @deprecated Use `getNodesBounds`.\nconst getRectOfNodes = (nodes, nodeOrigin = [\n    0,\n    0\n])=>{\n    console.warn(\"[DEPRECATED] `getRectOfNodes` is deprecated. Instead use `getNodesBounds` https://reactflow.dev/api-reference/utils/get-nodes-bounds.\");\n    return getNodesBounds(nodes, nodeOrigin);\n};\nconst getNodesInside = (nodeInternals, rect, [tx, ty, tScale] = [\n    0,\n    0,\n    1\n], partially = false, // set excludeNonSelectableNodes if you want to pay attention to the nodes \"selectable\" attribute\nexcludeNonSelectableNodes = false, nodeOrigin = [\n    0,\n    0\n])=>{\n    const paneRect = {\n        x: (rect.x - tx) / tScale,\n        y: (rect.y - ty) / tScale,\n        width: rect.width / tScale,\n        height: rect.height / tScale\n    };\n    const visibleNodes = [];\n    nodeInternals.forEach((node)=>{\n        const { width, height, selectable = true, hidden = false } = node;\n        if (excludeNonSelectableNodes && !selectable || hidden) {\n            return false;\n        }\n        const { positionAbsolute } = getNodePositionWithOrigin(node, nodeOrigin);\n        const nodeRect = {\n            x: positionAbsolute.x,\n            y: positionAbsolute.y,\n            width: width || 0,\n            height: height || 0\n        };\n        const overlappingArea = getOverlappingArea(paneRect, nodeRect);\n        const notInitialized = typeof width === \"undefined\" || typeof height === \"undefined\" || width === null || height === null;\n        const partiallyVisible = partially && overlappingArea > 0;\n        const area = (width || 0) * (height || 0);\n        const isVisible = notInitialized || partiallyVisible || overlappingArea >= area;\n        if (isVisible || node.dragging) {\n            visibleNodes.push(node);\n        }\n    });\n    return visibleNodes;\n};\nconst getConnectedEdges = (nodes, edges)=>{\n    const nodeIds = nodes.map((node)=>node.id);\n    return edges.filter((edge)=>nodeIds.includes(edge.source) || nodeIds.includes(edge.target));\n};\n// @deprecated Use `getViewportForBounds`.\nconst getTransformForBounds = (bounds, width, height, minZoom, maxZoom, padding = 0.1)=>{\n    const { x, y, zoom } = getViewportForBounds(bounds, width, height, minZoom, maxZoom, padding);\n    console.warn(\"[DEPRECATED] `getTransformForBounds` is deprecated. Instead use `getViewportForBounds`. Beware that the return value is type Viewport (`{ x: number, y: number, zoom: number }`) instead of Transform (`[number, number, number]`). https://reactflow.dev/api-reference/utils/get-viewport-for-bounds\");\n    return [\n        x,\n        y,\n        zoom\n    ];\n};\nconst getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding = 0.1)=>{\n    const xZoom = width / (bounds.width * (1 + padding));\n    const yZoom = height / (bounds.height * (1 + padding));\n    const zoom = Math.min(xZoom, yZoom);\n    const clampedZoom = clamp(zoom, minZoom, maxZoom);\n    const boundsCenterX = bounds.x + bounds.width / 2;\n    const boundsCenterY = bounds.y + bounds.height / 2;\n    const x = width / 2 - boundsCenterX * clampedZoom;\n    const y = height / 2 - boundsCenterY * clampedZoom;\n    return {\n        x,\n        y,\n        zoom: clampedZoom\n    };\n};\nconst getD3Transition = (selection, duration = 0)=>{\n    return selection.transition().duration(duration);\n};\n// this functions collects all handles and adds an absolute position\n// so that we can later find the closest handle to the mouse position\nfunction getHandles(node, handleBounds, type, currentHandle) {\n    return (handleBounds[type] || []).reduce((res, h)=>{\n        if (`${node.id}-${h.id}-${type}` !== currentHandle) {\n            res.push({\n                id: h.id || null,\n                type,\n                nodeId: node.id,\n                x: (node.positionAbsolute?.x ?? 0) + h.x + h.width / 2,\n                y: (node.positionAbsolute?.y ?? 0) + h.y + h.height / 2\n            });\n        }\n        return res;\n    }, []);\n}\nfunction getClosestHandle(event, doc, pos, connectionRadius, handles, validator) {\n    // we always want to prioritize the handle below the mouse cursor over the closest distance handle,\n    // because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor\n    const { x, y } = getEventPosition(event);\n    const domNodes = doc.elementsFromPoint(x, y);\n    const handleBelow = domNodes.find((el)=>el.classList.contains(\"react-flow__handle\"));\n    if (handleBelow) {\n        const handleNodeId = handleBelow.getAttribute(\"data-nodeid\");\n        if (handleNodeId) {\n            const handleType = getHandleType(undefined, handleBelow);\n            const handleId = handleBelow.getAttribute(\"data-handleid\");\n            const validHandleResult = validator({\n                nodeId: handleNodeId,\n                id: handleId,\n                type: handleType\n            });\n            if (validHandleResult) {\n                const handle = handles.find((h)=>h.nodeId === handleNodeId && h.type === handleType && h.id === handleId);\n                return {\n                    handle: {\n                        id: handleId,\n                        type: handleType,\n                        nodeId: handleNodeId,\n                        x: handle?.x || pos.x,\n                        y: handle?.y || pos.y\n                    },\n                    validHandleResult\n                };\n            }\n        }\n    }\n    // if we couldn't find a handle below the mouse cursor we look for the closest distance based on the connectionRadius\n    let closestHandles = [];\n    let minDistance = Infinity;\n    handles.forEach((handle)=>{\n        const distance = Math.sqrt((handle.x - pos.x) ** 2 + (handle.y - pos.y) ** 2);\n        if (distance <= connectionRadius) {\n            const validHandleResult = validator(handle);\n            if (distance <= minDistance) {\n                if (distance < minDistance) {\n                    closestHandles = [\n                        {\n                            handle,\n                            validHandleResult\n                        }\n                    ];\n                } else if (distance === minDistance) {\n                    // when multiple handles are on the same distance we collect all of them\n                    closestHandles.push({\n                        handle,\n                        validHandleResult\n                    });\n                }\n                minDistance = distance;\n            }\n        }\n    });\n    if (!closestHandles.length) {\n        return {\n            handle: null,\n            validHandleResult: defaultResult()\n        };\n    }\n    if (closestHandles.length === 1) {\n        return closestHandles[0];\n    }\n    const hasValidHandle = closestHandles.some(({ validHandleResult })=>validHandleResult.isValid);\n    const hasTargetHandle = closestHandles.some(({ handle })=>handle.type === \"target\");\n    // if multiple handles are layouted on top of each other we prefer the one with type = target and the one that is valid\n    return closestHandles.find(({ handle, validHandleResult })=>hasTargetHandle ? handle.type === \"target\" : hasValidHandle ? validHandleResult.isValid : true) || closestHandles[0];\n}\nconst nullConnection = {\n    source: null,\n    target: null,\n    sourceHandle: null,\n    targetHandle: null\n};\nconst defaultResult = ()=>({\n        handleDomNode: null,\n        isValid: false,\n        connection: nullConnection,\n        endHandle: null\n    });\n// checks if  and returns connection in fom of an object { source: 123, target: 312 }\nfunction isValidHandle(handle, connectionMode, fromNodeId, fromHandleId, fromType, isValidConnection, doc) {\n    const isTarget = fromType === \"target\";\n    const handleToCheck = doc.querySelector(`.react-flow__handle[data-id=\"${handle?.nodeId}-${handle?.id}-${handle?.type}\"]`);\n    const result = {\n        ...defaultResult(),\n        handleDomNode: handleToCheck\n    };\n    if (handleToCheck) {\n        const handleType = getHandleType(undefined, handleToCheck);\n        const handleNodeId = handleToCheck.getAttribute(\"data-nodeid\");\n        const handleId = handleToCheck.getAttribute(\"data-handleid\");\n        const connectable = handleToCheck.classList.contains(\"connectable\");\n        const connectableEnd = handleToCheck.classList.contains(\"connectableend\");\n        const connection = {\n            source: isTarget ? handleNodeId : fromNodeId,\n            sourceHandle: isTarget ? handleId : fromHandleId,\n            target: isTarget ? fromNodeId : handleNodeId,\n            targetHandle: isTarget ? fromHandleId : handleId\n        };\n        result.connection = connection;\n        const isConnectable = connectable && connectableEnd;\n        // in strict mode we don't allow target to target or source to source connections\n        const isValid = isConnectable && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === \"source\" || !isTarget && handleType === \"target\" : handleNodeId !== fromNodeId || handleId !== fromHandleId);\n        if (isValid) {\n            result.endHandle = {\n                nodeId: handleNodeId,\n                handleId,\n                type: handleType\n            };\n            result.isValid = isValidConnection(connection);\n        }\n    }\n    return result;\n}\nfunction getHandleLookup({ nodes, nodeId, handleId, handleType }) {\n    return nodes.reduce((res, node)=>{\n        if (node[internalsSymbol]) {\n            const { handleBounds } = node[internalsSymbol];\n            let sourceHandles = [];\n            let targetHandles = [];\n            if (handleBounds) {\n                sourceHandles = getHandles(node, handleBounds, \"source\", `${nodeId}-${handleId}-${handleType}`);\n                targetHandles = getHandles(node, handleBounds, \"target\", `${nodeId}-${handleId}-${handleType}`);\n            }\n            res.push(...sourceHandles, ...targetHandles);\n        }\n        return res;\n    }, []);\n}\nfunction getHandleType(edgeUpdaterType, handleDomNode) {\n    if (edgeUpdaterType) {\n        return edgeUpdaterType;\n    } else if (handleDomNode?.classList.contains(\"target\")) {\n        return \"target\";\n    } else if (handleDomNode?.classList.contains(\"source\")) {\n        return \"source\";\n    }\n    return null;\n}\nfunction resetRecentHandle(handleDomNode) {\n    handleDomNode?.classList.remove(\"valid\", \"connecting\", \"react-flow__handle-valid\", \"react-flow__handle-connecting\");\n}\nfunction getConnectionStatus(isInsideConnectionRadius, isHandleValid) {\n    let connectionStatus = null;\n    if (isHandleValid) {\n        connectionStatus = \"valid\";\n    } else if (isInsideConnectionRadius && !isHandleValid) {\n        connectionStatus = \"invalid\";\n    }\n    return connectionStatus;\n}\nfunction handlePointerDown({ event, handleId, nodeId, onConnect, isTarget, getState, setState, isValidConnection, edgeUpdaterType, onEdgeUpdateEnd }) {\n    // when react-flow is used inside a shadow root we can't use document\n    const doc = getHostForElement(event.target);\n    const { connectionMode, domNode, autoPanOnConnect, connectionRadius, onConnectStart, panBy, getNodes, cancelConnection } = getState();\n    let autoPanId = 0;\n    let closestHandle;\n    const { x, y } = getEventPosition(event);\n    const clickedHandle = doc?.elementFromPoint(x, y);\n    const handleType = getHandleType(edgeUpdaterType, clickedHandle);\n    const containerBounds = domNode?.getBoundingClientRect();\n    if (!containerBounds || !handleType) {\n        return;\n    }\n    let prevActiveHandle;\n    let connectionPosition = getEventPosition(event, containerBounds);\n    let autoPanStarted = false;\n    let connection = null;\n    let isValid = false;\n    let handleDomNode = null;\n    const handleLookup = getHandleLookup({\n        nodes: getNodes(),\n        nodeId,\n        handleId,\n        handleType\n    });\n    // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas\n    const autoPan = ()=>{\n        if (!autoPanOnConnect) {\n            return;\n        }\n        const [xMovement, yMovement] = calcAutoPan(connectionPosition, containerBounds);\n        panBy({\n            x: xMovement,\n            y: yMovement\n        });\n        autoPanId = requestAnimationFrame(autoPan);\n    };\n    setState({\n        connectionPosition,\n        connectionStatus: null,\n        // connectionNodeId etc will be removed in the next major in favor of connectionStartHandle\n        connectionNodeId: nodeId,\n        connectionHandleId: handleId,\n        connectionHandleType: handleType,\n        connectionStartHandle: {\n            nodeId,\n            handleId,\n            type: handleType\n        },\n        connectionEndHandle: null\n    });\n    onConnectStart?.(event, {\n        nodeId,\n        handleId,\n        handleType\n    });\n    function onPointerMove(event) {\n        const { transform } = getState();\n        connectionPosition = getEventPosition(event, containerBounds);\n        const { handle, validHandleResult } = getClosestHandle(event, doc, pointToRendererPoint(connectionPosition, transform, false, [\n            1,\n            1\n        ]), connectionRadius, handleLookup, (handle)=>isValidHandle(handle, connectionMode, nodeId, handleId, isTarget ? \"target\" : \"source\", isValidConnection, doc));\n        closestHandle = handle;\n        if (!autoPanStarted) {\n            autoPan();\n            autoPanStarted = true;\n        }\n        handleDomNode = validHandleResult.handleDomNode;\n        connection = validHandleResult.connection;\n        isValid = validHandleResult.isValid;\n        setState({\n            connectionPosition: closestHandle && isValid ? rendererPointToPoint({\n                x: closestHandle.x,\n                y: closestHandle.y\n            }, transform) : connectionPosition,\n            connectionStatus: getConnectionStatus(!!closestHandle, isValid),\n            connectionEndHandle: validHandleResult.endHandle\n        });\n        if (!closestHandle && !isValid && !handleDomNode) {\n            return resetRecentHandle(prevActiveHandle);\n        }\n        if (connection.source !== connection.target && handleDomNode) {\n            resetRecentHandle(prevActiveHandle);\n            prevActiveHandle = handleDomNode;\n            // @todo: remove the old class names \"react-flow__handle-\" in the next major version\n            handleDomNode.classList.add(\"connecting\", \"react-flow__handle-connecting\");\n            handleDomNode.classList.toggle(\"valid\", isValid);\n            handleDomNode.classList.toggle(\"react-flow__handle-valid\", isValid);\n        }\n    }\n    function onPointerUp(event) {\n        if ((closestHandle || handleDomNode) && connection && isValid) {\n            onConnect?.(connection);\n        }\n        // it's important to get a fresh reference from the store here\n        // in order to get the latest state of onConnectEnd\n        getState().onConnectEnd?.(event);\n        if (edgeUpdaterType) {\n            onEdgeUpdateEnd?.(event);\n        }\n        resetRecentHandle(prevActiveHandle);\n        cancelConnection();\n        cancelAnimationFrame(autoPanId);\n        autoPanStarted = false;\n        isValid = false;\n        connection = null;\n        handleDomNode = null;\n        doc.removeEventListener(\"mousemove\", onPointerMove);\n        doc.removeEventListener(\"mouseup\", onPointerUp);\n        doc.removeEventListener(\"touchmove\", onPointerMove);\n        doc.removeEventListener(\"touchend\", onPointerUp);\n    }\n    doc.addEventListener(\"mousemove\", onPointerMove);\n    doc.addEventListener(\"mouseup\", onPointerUp);\n    doc.addEventListener(\"touchmove\", onPointerMove);\n    doc.addEventListener(\"touchend\", onPointerUp);\n}\nconst alwaysValid = ()=>true;\nconst selector$f = (s)=>({\n        connectionStartHandle: s.connectionStartHandle,\n        connectOnClick: s.connectOnClick,\n        noPanClassName: s.noPanClassName\n    });\nconst connectingSelector = (nodeId, handleId, type)=>(state)=>{\n        const { connectionStartHandle: startHandle, connectionEndHandle: endHandle, connectionClickStartHandle: clickHandle } = state;\n        return {\n            connecting: startHandle?.nodeId === nodeId && startHandle?.handleId === handleId && startHandle?.type === type || endHandle?.nodeId === nodeId && endHandle?.handleId === handleId && endHandle?.type === type,\n            clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.handleId === handleId && clickHandle?.type === type\n        };\n    };\nconst Handle = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ type = \"source\", position = Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id, onConnect, children, className, onMouseDown, onTouchStart, ...rest }, ref)=>{\n    const handleId = id || null;\n    const isTarget = type === \"target\";\n    const store = useStoreApi();\n    const nodeId = useNodeId();\n    const { connectOnClick, noPanClassName } = useStore(selector$f, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const { connecting, clickConnecting } = useStore(connectingSelector(nodeId, handleId, type), zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    if (!nodeId) {\n        store.getState().onError?.(\"010\", errorMessages[\"error010\"]());\n    }\n    const onConnectExtended = (params)=>{\n        const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();\n        const edgeParams = {\n            ...defaultEdgeOptions,\n            ...params\n        };\n        if (hasDefaultEdges) {\n            const { edges, setEdges } = store.getState();\n            setEdges(addEdge(edgeParams, edges));\n        }\n        onConnectAction?.(edgeParams);\n        onConnect?.(edgeParams);\n    };\n    const onPointerDown = (event)=>{\n        if (!nodeId) {\n            return;\n        }\n        const isMouseTriggered = isMouseEvent(event);\n        if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {\n            handlePointerDown({\n                event,\n                handleId,\n                nodeId,\n                onConnect: onConnectExtended,\n                isTarget,\n                getState: store.getState,\n                setState: store.setState,\n                isValidConnection: isValidConnection || store.getState().isValidConnection || alwaysValid\n            });\n        }\n        if (isMouseTriggered) {\n            onMouseDown?.(event);\n        } else {\n            onTouchStart?.(event);\n        }\n    };\n    const onClick = (event)=>{\n        const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore } = store.getState();\n        if (!nodeId || !connectionClickStartHandle && !isConnectableStart) {\n            return;\n        }\n        if (!connectionClickStartHandle) {\n            onClickConnectStart?.(event, {\n                nodeId,\n                handleId,\n                handleType: type\n            });\n            store.setState({\n                connectionClickStartHandle: {\n                    nodeId,\n                    type,\n                    handleId\n                }\n            });\n            return;\n        }\n        const doc = getHostForElement(event.target);\n        const isValidConnectionHandler = isValidConnection || isValidConnectionStore || alwaysValid;\n        const { connection, isValid } = isValidHandle({\n            nodeId,\n            id: handleId,\n            type\n        }, connectionMode, connectionClickStartHandle.nodeId, connectionClickStartHandle.handleId || null, connectionClickStartHandle.type, isValidConnectionHandler, doc);\n        if (isValid) {\n            onConnectExtended(connection);\n        }\n        onClickConnectEnd?.(event);\n        store.setState({\n            connectionClickStartHandle: null\n        });\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        \"data-handleid\": handleId,\n        \"data-nodeid\": nodeId,\n        \"data-handlepos\": position,\n        \"data-id\": `${nodeId}-${handleId}-${type}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__handle\",\n            `react-flow__handle-${position}`,\n            \"nodrag\",\n            noPanClassName,\n            className,\n            {\n                source: !isTarget,\n                target: isTarget,\n                connectable: isConnectable,\n                connectablestart: isConnectableStart,\n                connectableend: isConnectableEnd,\n                connecting: clickConnecting,\n                // this class is used to style the handle when the user is connecting\n                connectionindicator: isConnectable && (isConnectableStart && !connecting || isConnectableEnd && connecting)\n            }\n        ]),\n        onMouseDown: onPointerDown,\n        onTouchStart: onPointerDown,\n        onClick: connectOnClick ? onClick : undefined,\n        ref: ref,\n        ...rest\n    }, children);\n});\nHandle.displayName = \"Handle\";\nvar Handle$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(Handle);\nconst DefaultNode = ({ data, isConnectable, targetPosition = Position.Top, sourcePosition = Position.Bottom })=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Handle$1, {\n        type: \"target\",\n        position: targetPosition,\n        isConnectable: isConnectable\n    }), data?.label, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Handle$1, {\n        type: \"source\",\n        position: sourcePosition,\n        isConnectable: isConnectable\n    }));\n};\nDefaultNode.displayName = \"DefaultNode\";\nvar DefaultNode$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(DefaultNode);\nconst InputNode = ({ data, isConnectable, sourcePosition = Position.Bottom })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, data?.label, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Handle$1, {\n        type: \"source\",\n        position: sourcePosition,\n        isConnectable: isConnectable\n    }));\nInputNode.displayName = \"InputNode\";\nvar InputNode$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(InputNode);\nconst OutputNode = ({ data, isConnectable, targetPosition = Position.Top })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Handle$1, {\n        type: \"target\",\n        position: targetPosition,\n        isConnectable: isConnectable\n    }), data?.label);\nOutputNode.displayName = \"OutputNode\";\nvar OutputNode$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(OutputNode);\nconst GroupNode = ()=>null;\nGroupNode.displayName = \"GroupNode\";\nconst selector$e = (s)=>({\n        selectedNodes: s.getNodes().filter((n)=>n.selected),\n        selectedEdges: s.edges.filter((e)=>e.selected)\n    });\nconst selectId = (obj)=>obj.id;\nfunction areEqual(a, b) {\n    return (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow)(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) && (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow)(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId));\n}\n// This is just a helper component for calling the onSelectionChange listener.\n// @TODO: Now that we have the onNodesChange and on EdgesChange listeners, do we still need this component?\nconst SelectionListener = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ onSelectionChange })=>{\n    const store = useStoreApi();\n    const { selectedNodes, selectedEdges } = useStore(selector$e, areEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const params = {\n            nodes: selectedNodes,\n            edges: selectedEdges\n        };\n        onSelectionChange?.(params);\n        store.getState().onSelectionChange.forEach((fn)=>fn(params));\n    }, [\n        selectedNodes,\n        selectedEdges,\n        onSelectionChange\n    ]);\n    return null;\n});\nSelectionListener.displayName = \"SelectionListener\";\nconst changeSelector = (s)=>!!s.onSelectionChange;\nfunction Wrapper$1({ onSelectionChange }) {\n    const storeHasSelectionChange = useStore(changeSelector);\n    if (onSelectionChange || storeHasSelectionChange) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SelectionListener, {\n            onSelectionChange: onSelectionChange\n        });\n    }\n    return null;\n}\nconst selector$d = (s)=>({\n        setNodes: s.setNodes,\n        setEdges: s.setEdges,\n        setDefaultNodesAndEdges: s.setDefaultNodesAndEdges,\n        setMinZoom: s.setMinZoom,\n        setMaxZoom: s.setMaxZoom,\n        setTranslateExtent: s.setTranslateExtent,\n        setNodeExtent: s.setNodeExtent,\n        reset: s.reset\n    });\nfunction useStoreUpdater(value, setStoreState) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (typeof value !== \"undefined\") {\n            setStoreState(value);\n        }\n    }, [\n        value\n    ]);\n}\n// updates with values in store that don't have a dedicated setter function\nfunction useDirectStoreUpdater(key, value, setState) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (typeof value !== \"undefined\") {\n            setState({\n                [key]: value\n            });\n        }\n    }, [\n        value\n    ]);\n}\nconst StoreUpdater = ({ nodes, edges, defaultNodes, defaultEdges, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, nodesDraggable, nodesConnectable, nodesFocusable, edgesFocusable, edgesUpdatable, elevateNodesOnSelect, minZoom, maxZoom, nodeExtent, onNodesChange, onEdgesChange, elementsSelectable, connectionMode, snapGrid, snapToGrid, translateExtent, connectOnClick, defaultEdgeOptions, fitView, fitViewOptions, onNodesDelete, onEdgesDelete, onNodeDrag, onNodeDragStart, onNodeDragStop, onSelectionDrag, onSelectionDragStart, onSelectionDragStop, noPanClassName, nodeOrigin, rfId, autoPanOnConnect, autoPanOnNodeDrag, onError, connectionRadius, isValidConnection, nodeDragThreshold })=>{\n    const { setNodes, setEdges, setDefaultNodesAndEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset } = useStore(selector$d, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const edgesWithDefaults = defaultEdges?.map((e)=>({\n                ...e,\n                ...defaultEdgeOptions\n            }));\n        setDefaultNodesAndEdges(defaultNodes, edgesWithDefaults);\n        return ()=>{\n            reset();\n        };\n    }, []);\n    useDirectStoreUpdater(\"defaultEdgeOptions\", defaultEdgeOptions, store.setState);\n    useDirectStoreUpdater(\"connectionMode\", connectionMode, store.setState);\n    useDirectStoreUpdater(\"onConnect\", onConnect, store.setState);\n    useDirectStoreUpdater(\"onConnectStart\", onConnectStart, store.setState);\n    useDirectStoreUpdater(\"onConnectEnd\", onConnectEnd, store.setState);\n    useDirectStoreUpdater(\"onClickConnectStart\", onClickConnectStart, store.setState);\n    useDirectStoreUpdater(\"onClickConnectEnd\", onClickConnectEnd, store.setState);\n    useDirectStoreUpdater(\"nodesDraggable\", nodesDraggable, store.setState);\n    useDirectStoreUpdater(\"nodesConnectable\", nodesConnectable, store.setState);\n    useDirectStoreUpdater(\"nodesFocusable\", nodesFocusable, store.setState);\n    useDirectStoreUpdater(\"edgesFocusable\", edgesFocusable, store.setState);\n    useDirectStoreUpdater(\"edgesUpdatable\", edgesUpdatable, store.setState);\n    useDirectStoreUpdater(\"elementsSelectable\", elementsSelectable, store.setState);\n    useDirectStoreUpdater(\"elevateNodesOnSelect\", elevateNodesOnSelect, store.setState);\n    useDirectStoreUpdater(\"snapToGrid\", snapToGrid, store.setState);\n    useDirectStoreUpdater(\"snapGrid\", snapGrid, store.setState);\n    useDirectStoreUpdater(\"onNodesChange\", onNodesChange, store.setState);\n    useDirectStoreUpdater(\"onEdgesChange\", onEdgesChange, store.setState);\n    useDirectStoreUpdater(\"connectOnClick\", connectOnClick, store.setState);\n    useDirectStoreUpdater(\"fitViewOnInit\", fitView, store.setState);\n    useDirectStoreUpdater(\"fitViewOnInitOptions\", fitViewOptions, store.setState);\n    useDirectStoreUpdater(\"onNodesDelete\", onNodesDelete, store.setState);\n    useDirectStoreUpdater(\"onEdgesDelete\", onEdgesDelete, store.setState);\n    useDirectStoreUpdater(\"onNodeDrag\", onNodeDrag, store.setState);\n    useDirectStoreUpdater(\"onNodeDragStart\", onNodeDragStart, store.setState);\n    useDirectStoreUpdater(\"onNodeDragStop\", onNodeDragStop, store.setState);\n    useDirectStoreUpdater(\"onSelectionDrag\", onSelectionDrag, store.setState);\n    useDirectStoreUpdater(\"onSelectionDragStart\", onSelectionDragStart, store.setState);\n    useDirectStoreUpdater(\"onSelectionDragStop\", onSelectionDragStop, store.setState);\n    useDirectStoreUpdater(\"noPanClassName\", noPanClassName, store.setState);\n    useDirectStoreUpdater(\"nodeOrigin\", nodeOrigin, store.setState);\n    useDirectStoreUpdater(\"rfId\", rfId, store.setState);\n    useDirectStoreUpdater(\"autoPanOnConnect\", autoPanOnConnect, store.setState);\n    useDirectStoreUpdater(\"autoPanOnNodeDrag\", autoPanOnNodeDrag, store.setState);\n    useDirectStoreUpdater(\"onError\", onError, store.setState);\n    useDirectStoreUpdater(\"connectionRadius\", connectionRadius, store.setState);\n    useDirectStoreUpdater(\"isValidConnection\", isValidConnection, store.setState);\n    useDirectStoreUpdater(\"nodeDragThreshold\", nodeDragThreshold, store.setState);\n    useStoreUpdater(nodes, setNodes);\n    useStoreUpdater(edges, setEdges);\n    useStoreUpdater(minZoom, setMinZoom);\n    useStoreUpdater(maxZoom, setMaxZoom);\n    useStoreUpdater(translateExtent, setTranslateExtent);\n    useStoreUpdater(nodeExtent, setNodeExtent);\n    return null;\n};\nconst style = {\n    display: \"none\"\n};\nconst ariaLiveStyle = {\n    position: \"absolute\",\n    width: 1,\n    height: 1,\n    margin: -1,\n    border: 0,\n    padding: 0,\n    overflow: \"hidden\",\n    clip: \"rect(0px, 0px, 0px, 0px)\",\n    clipPath: \"inset(100%)\"\n};\nconst ARIA_NODE_DESC_KEY = \"react-flow__node-desc\";\nconst ARIA_EDGE_DESC_KEY = \"react-flow__edge-desc\";\nconst ARIA_LIVE_MESSAGE = \"react-flow__aria-live\";\nconst selector$c = (s)=>s.ariaLiveMessage;\nfunction AriaLiveMessage({ rfId }) {\n    const ariaLiveMessage = useStore(selector$c);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        id: `${ARIA_LIVE_MESSAGE}-${rfId}`,\n        \"aria-live\": \"assertive\",\n        \"aria-atomic\": \"true\",\n        style: ariaLiveStyle\n    }, ariaLiveMessage);\n}\nfunction A11yDescriptions({ rfId, disableKeyboardA11y }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        id: `${ARIA_NODE_DESC_KEY}-${rfId}`,\n        style: style\n    }, \"Press enter or space to select a node.\", !disableKeyboardA11y && \"You can then use the arrow keys to move the node around.\", \" Press delete to remove it and escape to cancel.\", \" \"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        id: `${ARIA_EDGE_DESC_KEY}-${rfId}`,\n        style: style\n    }, \"Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.\"), !disableKeyboardA11y && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AriaLiveMessage, {\n        rfId: rfId\n    }));\n}\n// the keycode can be a string 'a' or an array of strings ['a', 'a+d']\n// a string means a single key 'a' or a combination when '+' is used 'a+d'\n// an array means different possibilities. Explainer: ['a', 'd+s'] here the\n// user can use the single key 'a' or the combination 'd' + 's'\nvar useKeyPress = (keyCode = null, options = {\n    actInsideInputWithModifier: true\n})=>{\n    const [keyPressed, setKeyPressed] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // we need to remember if a modifier key is pressed in order to track it\n    const modifierPressed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // we need to remember the pressed keys in order to support combinations\n    const pressedKeys = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Set([]));\n    // keyCodes = array with single keys [['a']] or key combinations [['a', 's']]\n    // keysToWatch = array with all keys flattened ['a', 'd', 'ShiftLeft']\n    // used to check if we store event.code or event.key. When the code is in the list of keysToWatch\n    // we use the code otherwise the key. Explainer: When you press the left \"command\" key, the code is \"MetaLeft\"\n    // and the key is \"Meta\". We want users to be able to pass keys and codes so we assume that the key is meant when\n    // we can't find it in the list of keysToWatch.\n    const [keyCodes, keysToWatch] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (keyCode !== null) {\n            const keyCodeArr = Array.isArray(keyCode) ? keyCode : [\n                keyCode\n            ];\n            const keys = keyCodeArr.filter((kc)=>typeof kc === \"string\").map((kc)=>kc.split(\"+\"));\n            const keysFlat = keys.reduce((res, item)=>res.concat(...item), []);\n            return [\n                keys,\n                keysFlat\n            ];\n        }\n        return [\n            [],\n            []\n        ];\n    }, [\n        keyCode\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const doc = typeof document !== \"undefined\" ? document : null;\n        const target = options?.target || doc;\n        if (keyCode !== null) {\n            const downHandler = (event)=>{\n                modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey;\n                const preventAction = (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && isInputDOMNode(event);\n                if (preventAction) {\n                    return false;\n                }\n                const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                pressedKeys.current.add(event[keyOrCode]);\n                if (isMatchingKey(keyCodes, pressedKeys.current, false)) {\n                    event.preventDefault();\n                    setKeyPressed(true);\n                }\n            };\n            const upHandler = (event)=>{\n                const preventAction = (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && isInputDOMNode(event);\n                if (preventAction) {\n                    return false;\n                }\n                const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                if (isMatchingKey(keyCodes, pressedKeys.current, true)) {\n                    setKeyPressed(false);\n                    pressedKeys.current.clear();\n                } else {\n                    pressedKeys.current.delete(event[keyOrCode]);\n                }\n                // fix for Mac: when cmd key is pressed, keyup is not triggered for any other key, see: https://stackoverflow.com/questions/27380018/when-cmd-key-is-kept-pressed-keyup-is-not-triggered-for-any-other-key\n                if (event.key === \"Meta\") {\n                    pressedKeys.current.clear();\n                }\n                modifierPressed.current = false;\n            };\n            const resetHandler = ()=>{\n                pressedKeys.current.clear();\n                setKeyPressed(false);\n            };\n            target?.addEventListener(\"keydown\", downHandler);\n            target?.addEventListener(\"keyup\", upHandler);\n            window.addEventListener(\"blur\", resetHandler);\n            return ()=>{\n                target?.removeEventListener(\"keydown\", downHandler);\n                target?.removeEventListener(\"keyup\", upHandler);\n                window.removeEventListener(\"blur\", resetHandler);\n            };\n        }\n    }, [\n        keyCode,\n        setKeyPressed\n    ]);\n    return keyPressed;\n};\n// utils\nfunction isMatchingKey(keyCodes, pressedKeys, isUp) {\n    return keyCodes// we only want to compare same sizes of keyCode definitions\n    // and pressed keys. When the user specified 'Meta' as a key somewhere\n    // this would also be truthy without this filter when user presses 'Meta' + 'r'\n    .filter((keys)=>isUp || keys.length === pressedKeys.size)// since we want to support multiple possibilities only one of the\n    // combinations need to be part of the pressed keys\n    .some((keys)=>keys.every((k)=>pressedKeys.has(k)));\n}\nfunction useKeyOrCode(eventCode, keysToWatch) {\n    return keysToWatch.includes(eventCode) ? \"code\" : \"key\";\n}\nfunction calculateXYZPosition(node, nodeInternals, result, nodeOrigin) {\n    if (!node.parentNode) {\n        return result;\n    }\n    const parentNode = nodeInternals.get(node.parentNode);\n    const parentNodePosition = getNodePositionWithOrigin(parentNode, nodeOrigin);\n    return calculateXYZPosition(parentNode, nodeInternals, {\n        x: (result.x ?? 0) + parentNodePosition.x,\n        y: (result.y ?? 0) + parentNodePosition.y,\n        z: (parentNode[internalsSymbol]?.z ?? 0) > (result.z ?? 0) ? parentNode[internalsSymbol]?.z ?? 0 : result.z ?? 0\n    }, nodeOrigin);\n}\nfunction updateAbsoluteNodePositions(nodeInternals, nodeOrigin, parentNodes) {\n    nodeInternals.forEach((node)=>{\n        if (node.parentNode && !nodeInternals.has(node.parentNode)) {\n            throw new Error(`Parent node ${node.parentNode} not found`);\n        }\n        if (node.parentNode || parentNodes?.[node.id]) {\n            const { x, y, z } = calculateXYZPosition(node, nodeInternals, {\n                ...node.position,\n                z: node[internalsSymbol]?.z ?? 0\n            }, nodeOrigin);\n            node.positionAbsolute = {\n                x,\n                y\n            };\n            node[internalsSymbol].z = z;\n            if (parentNodes?.[node.id]) {\n                node[internalsSymbol].isParent = true;\n            }\n        }\n    });\n}\nfunction createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect) {\n    const nextNodeInternals = new Map();\n    const parentNodes = {};\n    const selectedNodeZ = elevateNodesOnSelect ? 1000 : 0;\n    nodes.forEach((node)=>{\n        const z = (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);\n        const currInternals = nodeInternals.get(node.id);\n        const internals = {\n            width: currInternals?.width,\n            height: currInternals?.height,\n            ...node,\n            positionAbsolute: {\n                x: node.position.x,\n                y: node.position.y\n            }\n        };\n        if (node.parentNode) {\n            internals.parentNode = node.parentNode;\n            parentNodes[node.parentNode] = true;\n        }\n        Object.defineProperty(internals, internalsSymbol, {\n            enumerable: false,\n            value: {\n                handleBounds: currInternals?.[internalsSymbol]?.handleBounds,\n                z\n            }\n        });\n        nextNodeInternals.set(node.id, internals);\n    });\n    updateAbsoluteNodePositions(nextNodeInternals, nodeOrigin, parentNodes);\n    return nextNodeInternals;\n}\nfunction fitView(get, options = {}) {\n    const { getNodes, width, height, minZoom, maxZoom, d3Zoom, d3Selection, fitViewOnInitDone, fitViewOnInit, nodeOrigin } = get();\n    const isInitialFitView = options.initial && !fitViewOnInitDone && fitViewOnInit;\n    const d3initialized = d3Zoom && d3Selection;\n    if (d3initialized && (isInitialFitView || !options.initial)) {\n        const nodes = getNodes().filter((n)=>{\n            const isVisible = options.includeHiddenNodes ? n.width && n.height : !n.hidden;\n            if (options.nodes?.length) {\n                return isVisible && options.nodes.some((optionNode)=>optionNode.id === n.id);\n            }\n            return isVisible;\n        });\n        const nodesInitialized = nodes.every((n)=>n.width && n.height);\n        if (nodes.length > 0 && nodesInitialized) {\n            const bounds = getNodesBounds(nodes, nodeOrigin);\n            const { x, y, zoom } = getViewportForBounds(bounds, width, height, options.minZoom ?? minZoom, options.maxZoom ?? maxZoom, options.padding ?? 0.1);\n            const nextTransform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(x, y).scale(zoom);\n            if (typeof options.duration === \"number\" && options.duration > 0) {\n                d3Zoom.transform(getD3Transition(d3Selection, options.duration), nextTransform);\n            } else {\n                d3Zoom.transform(d3Selection, nextTransform);\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction handleControlledNodeSelectionChange(nodeChanges, nodeInternals) {\n    nodeChanges.forEach((change)=>{\n        const node = nodeInternals.get(change.id);\n        if (node) {\n            nodeInternals.set(node.id, {\n                ...node,\n                [internalsSymbol]: node[internalsSymbol],\n                selected: change.selected\n            });\n        }\n    });\n    return new Map(nodeInternals);\n}\nfunction handleControlledEdgeSelectionChange(edgeChanges, edges) {\n    return edges.map((e)=>{\n        const change = edgeChanges.find((change)=>change.id === e.id);\n        if (change) {\n            e.selected = change.selected;\n        }\n        return e;\n    });\n}\nfunction updateNodesAndEdgesSelections({ changedNodes, changedEdges, get, set }) {\n    const { nodeInternals, edges, onNodesChange, onEdgesChange, hasDefaultNodes, hasDefaultEdges } = get();\n    if (changedNodes?.length) {\n        if (hasDefaultNodes) {\n            set({\n                nodeInternals: handleControlledNodeSelectionChange(changedNodes, nodeInternals)\n            });\n        }\n        onNodesChange?.(changedNodes);\n    }\n    if (changedEdges?.length) {\n        if (hasDefaultEdges) {\n            set({\n                edges: handleControlledEdgeSelectionChange(changedEdges, edges)\n            });\n        }\n        onEdgesChange?.(changedEdges);\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop = ()=>{};\nconst initialViewportHelper = {\n    zoomIn: noop,\n    zoomOut: noop,\n    zoomTo: noop,\n    getZoom: ()=>1,\n    setViewport: noop,\n    getViewport: ()=>({\n            x: 0,\n            y: 0,\n            zoom: 1\n        }),\n    fitView: ()=>false,\n    setCenter: noop,\n    fitBounds: noop,\n    project: (position)=>position,\n    screenToFlowPosition: (position)=>position,\n    flowToScreenPosition: (position)=>position,\n    viewportInitialized: false\n};\nconst selector$b = (s)=>({\n        d3Zoom: s.d3Zoom,\n        d3Selection: s.d3Selection\n    });\nconst useViewportHelper = ()=>{\n    const store = useStoreApi();\n    const { d3Zoom, d3Selection } = useStore(selector$b, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const viewportHelperFunctions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (d3Selection && d3Zoom) {\n            return {\n                zoomIn: (options)=>d3Zoom.scaleBy(getD3Transition(d3Selection, options?.duration), 1.2),\n                zoomOut: (options)=>d3Zoom.scaleBy(getD3Transition(d3Selection, options?.duration), 1 / 1.2),\n                zoomTo: (zoomLevel, options)=>d3Zoom.scaleTo(getD3Transition(d3Selection, options?.duration), zoomLevel),\n                getZoom: ()=>store.getState().transform[2],\n                setViewport: (transform, options)=>{\n                    const [x, y, zoom] = store.getState().transform;\n                    const nextTransform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(transform.x ?? x, transform.y ?? y).scale(transform.zoom ?? zoom);\n                    d3Zoom.transform(getD3Transition(d3Selection, options?.duration), nextTransform);\n                },\n                getViewport: ()=>{\n                    const [x, y, zoom] = store.getState().transform;\n                    return {\n                        x,\n                        y,\n                        zoom\n                    };\n                },\n                fitView: (options)=>fitView(store.getState, options),\n                setCenter: (x, y, options)=>{\n                    const { width, height, maxZoom } = store.getState();\n                    const nextZoom = typeof options?.zoom !== \"undefined\" ? options.zoom : maxZoom;\n                    const centerX = width / 2 - x * nextZoom;\n                    const centerY = height / 2 - y * nextZoom;\n                    const transform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(centerX, centerY).scale(nextZoom);\n                    d3Zoom.transform(getD3Transition(d3Selection, options?.duration), transform);\n                },\n                fitBounds: (bounds, options)=>{\n                    const { width, height, minZoom, maxZoom } = store.getState();\n                    const { x, y, zoom } = getViewportForBounds(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);\n                    const transform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(x, y).scale(zoom);\n                    d3Zoom.transform(getD3Transition(d3Selection, options?.duration), transform);\n                },\n                // @deprecated Use `screenToFlowPosition`.\n                project: (position)=>{\n                    const { transform, snapToGrid, snapGrid } = store.getState();\n                    console.warn(\"[DEPRECATED] `project` is deprecated. Instead use `screenToFlowPosition`. There is no need to subtract the react flow bounds anymore! https://reactflow.dev/api-reference/types/react-flow-instance#screen-to-flow-position\");\n                    return pointToRendererPoint(position, transform, snapToGrid, snapGrid);\n                },\n                screenToFlowPosition: (position)=>{\n                    const { transform, snapToGrid, snapGrid, domNode } = store.getState();\n                    if (!domNode) {\n                        return position;\n                    }\n                    const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                    const relativePosition = {\n                        x: position.x - domX,\n                        y: position.y - domY\n                    };\n                    return pointToRendererPoint(relativePosition, transform, snapToGrid, snapGrid);\n                },\n                flowToScreenPosition: (position)=>{\n                    const { transform, domNode } = store.getState();\n                    if (!domNode) {\n                        return position;\n                    }\n                    const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                    const rendererPosition = rendererPointToPoint(position, transform);\n                    return {\n                        x: rendererPosition.x + domX,\n                        y: rendererPosition.y + domY\n                    };\n                },\n                viewportInitialized: true\n            };\n        }\n        return initialViewportHelper;\n    }, [\n        d3Zoom,\n        d3Selection\n    ]);\n    return viewportHelperFunctions;\n};\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */ function useReactFlow() {\n    const viewportHelper = useViewportHelper();\n    const store = useStoreApi();\n    const getNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        return store.getState().getNodes().map((n)=>({\n                ...n\n            }));\n    }, []);\n    const getNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        return store.getState().nodeInternals.get(id);\n    }, []);\n    const getEdges = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const { edges = [] } = store.getState();\n        return edges.map((e)=>({\n                ...e\n            }));\n    }, []);\n    const getEdge = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        const { edges = [] } = store.getState();\n        return edges.find((e)=>e.id === id);\n    }, []);\n    const setNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((payload)=>{\n        const { getNodes, setNodes, hasDefaultNodes, onNodesChange } = store.getState();\n        const nodes = getNodes();\n        const nextNodes = typeof payload === \"function\" ? payload(nodes) : payload;\n        if (hasDefaultNodes) {\n            setNodes(nextNodes);\n        } else if (onNodesChange) {\n            const changes = nextNodes.length === 0 ? nodes.map((node)=>({\n                    type: \"remove\",\n                    id: node.id\n                })) : nextNodes.map((node)=>({\n                    item: node,\n                    type: \"reset\"\n                }));\n            onNodesChange(changes);\n        }\n    }, []);\n    const setEdges = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((payload)=>{\n        const { edges = [], setEdges, hasDefaultEdges, onEdgesChange } = store.getState();\n        const nextEdges = typeof payload === \"function\" ? payload(edges) : payload;\n        if (hasDefaultEdges) {\n            setEdges(nextEdges);\n        } else if (onEdgesChange) {\n            const changes = nextEdges.length === 0 ? edges.map((edge)=>({\n                    type: \"remove\",\n                    id: edge.id\n                })) : nextEdges.map((edge)=>({\n                    item: edge,\n                    type: \"reset\"\n                }));\n            onEdgesChange(changes);\n        }\n    }, []);\n    const addNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((payload)=>{\n        const nodes = Array.isArray(payload) ? payload : [\n            payload\n        ];\n        const { getNodes, setNodes, hasDefaultNodes, onNodesChange } = store.getState();\n        if (hasDefaultNodes) {\n            const currentNodes = getNodes();\n            const nextNodes = [\n                ...currentNodes,\n                ...nodes\n            ];\n            setNodes(nextNodes);\n        } else if (onNodesChange) {\n            const changes = nodes.map((node)=>({\n                    item: node,\n                    type: \"add\"\n                }));\n            onNodesChange(changes);\n        }\n    }, []);\n    const addEdges = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((payload)=>{\n        const nextEdges = Array.isArray(payload) ? payload : [\n            payload\n        ];\n        const { edges = [], setEdges, hasDefaultEdges, onEdgesChange } = store.getState();\n        if (hasDefaultEdges) {\n            setEdges([\n                ...edges,\n                ...nextEdges\n            ]);\n        } else if (onEdgesChange) {\n            const changes = nextEdges.map((edge)=>({\n                    item: edge,\n                    type: \"add\"\n                }));\n            onEdgesChange(changes);\n        }\n    }, []);\n    const toObject = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const { getNodes, edges = [], transform } = store.getState();\n        const [x, y, zoom] = transform;\n        return {\n            nodes: getNodes().map((n)=>({\n                    ...n\n                })),\n            edges: edges.map((e)=>({\n                    ...e\n                })),\n            viewport: {\n                x,\n                y,\n                zoom\n            }\n        };\n    }, []);\n    const deleteElements = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ nodes: nodesDeleted, edges: edgesDeleted })=>{\n        const { nodeInternals, getNodes, edges, hasDefaultNodes, hasDefaultEdges, onNodesDelete, onEdgesDelete, onNodesChange, onEdgesChange } = store.getState();\n        const nodeIds = (nodesDeleted || []).map((node)=>node.id);\n        const edgeIds = (edgesDeleted || []).map((edge)=>edge.id);\n        const nodesToRemove = getNodes().reduce((res, node)=>{\n            const parentHit = !nodeIds.includes(node.id) && node.parentNode && res.find((n)=>n.id === node.parentNode);\n            const deletable = typeof node.deletable === \"boolean\" ? node.deletable : true;\n            if (deletable && (nodeIds.includes(node.id) || parentHit)) {\n                res.push(node);\n            }\n            return res;\n        }, []);\n        const deletableEdges = edges.filter((e)=>typeof e.deletable === \"boolean\" ? e.deletable : true);\n        const initialHitEdges = deletableEdges.filter((e)=>edgeIds.includes(e.id));\n        if (nodesToRemove || initialHitEdges) {\n            const connectedEdges = getConnectedEdges(nodesToRemove, deletableEdges);\n            const edgesToRemove = [\n                ...initialHitEdges,\n                ...connectedEdges\n            ];\n            const edgeIdsToRemove = edgesToRemove.reduce((res, edge)=>{\n                if (!res.includes(edge.id)) {\n                    res.push(edge.id);\n                }\n                return res;\n            }, []);\n            if (hasDefaultEdges || hasDefaultNodes) {\n                if (hasDefaultEdges) {\n                    store.setState({\n                        edges: edges.filter((e)=>!edgeIdsToRemove.includes(e.id))\n                    });\n                }\n                if (hasDefaultNodes) {\n                    nodesToRemove.forEach((node)=>{\n                        nodeInternals.delete(node.id);\n                    });\n                    store.setState({\n                        nodeInternals: new Map(nodeInternals)\n                    });\n                }\n            }\n            if (edgeIdsToRemove.length > 0) {\n                onEdgesDelete?.(edgesToRemove);\n                if (onEdgesChange) {\n                    onEdgesChange(edgeIdsToRemove.map((id)=>({\n                            id,\n                            type: \"remove\"\n                        })));\n                }\n            }\n            if (nodesToRemove.length > 0) {\n                onNodesDelete?.(nodesToRemove);\n                if (onNodesChange) {\n                    const nodeChanges = nodesToRemove.map((n)=>({\n                            id: n.id,\n                            type: \"remove\"\n                        }));\n                    onNodesChange(nodeChanges);\n                }\n            }\n        }\n    }, []);\n    const getNodeRect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodeOrRect)=>{\n        const isRect = isRectObject(nodeOrRect);\n        const node = isRect ? null : store.getState().nodeInternals.get(nodeOrRect.id);\n        const nodeRect = isRect ? nodeOrRect : nodeToRect(node);\n        return [\n            nodeRect,\n            node,\n            isRect\n        ];\n    }, []);\n    const getIntersectingNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodeOrRect, partially = true, nodes)=>{\n        const [nodeRect, node, isRect] = getNodeRect(nodeOrRect);\n        if (!nodeRect) {\n            return [];\n        }\n        return (nodes || store.getState().getNodes()).filter((n)=>{\n            if (!isRect && (n.id === node.id || !n.positionAbsolute)) {\n                return false;\n            }\n            const currNodeRect = nodeToRect(n);\n            const overlappingArea = getOverlappingArea(currNodeRect, nodeRect);\n            const partiallyVisible = partially && overlappingArea > 0;\n            return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;\n        });\n    }, []);\n    const isNodeIntersecting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodeOrRect, area, partially = true)=>{\n        const [nodeRect] = getNodeRect(nodeOrRect);\n        if (!nodeRect) {\n            return false;\n        }\n        const overlappingArea = getOverlappingArea(nodeRect, area);\n        const partiallyVisible = partially && overlappingArea > 0;\n        return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;\n    }, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            ...viewportHelper,\n            getNodes,\n            getNode,\n            getEdges,\n            getEdge,\n            setNodes,\n            setEdges,\n            addNodes,\n            addEdges,\n            toObject,\n            deleteElements,\n            getIntersectingNodes,\n            isNodeIntersecting\n        };\n    }, [\n        viewportHelper,\n        getNodes,\n        getNode,\n        getEdges,\n        getEdge,\n        setNodes,\n        setEdges,\n        addNodes,\n        addEdges,\n        toObject,\n        deleteElements,\n        getIntersectingNodes,\n        isNodeIntersecting\n    ]);\n}\nconst deleteKeyOptions = {\n    actInsideInputWithModifier: false\n};\nvar useGlobalKeyHandler = ({ deleteKeyCode, multiSelectionKeyCode })=>{\n    const store = useStoreApi();\n    const { deleteElements } = useReactFlow();\n    const deleteKeyPressed = useKeyPress(deleteKeyCode, deleteKeyOptions);\n    const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (deleteKeyPressed) {\n            const { edges, getNodes } = store.getState();\n            const selectedNodes = getNodes().filter((node)=>node.selected);\n            const selectedEdges = edges.filter((edge)=>edge.selected);\n            deleteElements({\n                nodes: selectedNodes,\n                edges: selectedEdges\n            });\n            store.setState({\n                nodesSelectionActive: false\n            });\n        }\n    }, [\n        deleteKeyPressed\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        store.setState({\n            multiSelectionActive: multiSelectionKeyPressed\n        });\n    }, [\n        multiSelectionKeyPressed\n    ]);\n};\nfunction useResizeHandler(rendererNode) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let resizeObserver;\n        const updateDimensions = ()=>{\n            if (!rendererNode.current) {\n                return;\n            }\n            const size = getDimensions(rendererNode.current);\n            if (size.height === 0 || size.width === 0) {\n                store.getState().onError?.(\"004\", errorMessages[\"error004\"]());\n            }\n            store.setState({\n                width: size.width || 500,\n                height: size.height || 500\n            });\n        };\n        updateDimensions();\n        window.addEventListener(\"resize\", updateDimensions);\n        if (rendererNode.current) {\n            resizeObserver = new ResizeObserver(()=>updateDimensions());\n            resizeObserver.observe(rendererNode.current);\n        }\n        return ()=>{\n            window.removeEventListener(\"resize\", updateDimensions);\n            if (resizeObserver && rendererNode.current) {\n                resizeObserver.unobserve(rendererNode.current);\n            }\n        };\n    }, []);\n}\nconst containerStyle = {\n    position: \"absolute\",\n    width: \"100%\",\n    height: \"100%\",\n    top: 0,\n    left: 0\n};\n/* eslint-disable @typescript-eslint/ban-ts-comment */ const viewChanged = (prevViewport, eventTransform)=>prevViewport.x !== eventTransform.x || prevViewport.y !== eventTransform.y || prevViewport.zoom !== eventTransform.k;\nconst eventToFlowTransform = (eventTransform)=>({\n        x: eventTransform.x,\n        y: eventTransform.y,\n        zoom: eventTransform.k\n    });\nconst isWrappedWithClass = (event, className)=>event.target.closest(`.${className}`);\nconst isRightClickPan = (panOnDrag, usedButton)=>usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);\nconst wheelDelta = (event)=>{\n    const factor = event.ctrlKey && isMacOs() ? 10 : 1;\n    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;\n};\nconst selector$a = (s)=>({\n        d3Zoom: s.d3Zoom,\n        d3Selection: s.d3Selection,\n        d3ZoomHandler: s.d3ZoomHandler,\n        userSelectionActive: s.userSelectionActive\n    });\nconst ZoomPane = ({ onMove, onMoveStart, onMoveEnd, onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = true, elementsSelectable, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children, noWheelClassName, noPanClassName })=>{\n    const timerId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const store = useStoreApi();\n    const isZoomingOrPanning = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const zoomedWithRightMouseButton = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const zoomPane = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const prevTransform = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0,\n        zoom: 0\n    });\n    const { d3Zoom, d3Selection, d3ZoomHandler, userSelectionActive } = useStore(selector$a, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);\n    const mouseButton = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const isPanScrolling = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const panScrollTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    useResizeHandler(zoomPane);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (zoomPane.current) {\n            const bbox = zoomPane.current.getBoundingClientRect();\n            const d3ZoomInstance = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoom)().scaleExtent([\n                minZoom,\n                maxZoom\n            ]).translateExtent(translateExtent);\n            const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(zoomPane.current).call(d3ZoomInstance);\n            const updatedTransform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(defaultViewport.x, defaultViewport.y).scale(clamp(defaultViewport.zoom, minZoom, maxZoom));\n            const extent = [\n                [\n                    0,\n                    0\n                ],\n                [\n                    bbox.width,\n                    bbox.height\n                ]\n            ];\n            const constrainedTransform = d3ZoomInstance.constrain()(updatedTransform, extent, translateExtent);\n            d3ZoomInstance.transform(selection, constrainedTransform);\n            d3ZoomInstance.wheelDelta(wheelDelta);\n            store.setState({\n                d3Zoom: d3ZoomInstance,\n                d3Selection: selection,\n                d3ZoomHandler: selection.on(\"wheel.zoom\"),\n                // we need to pass transform because zoom handler is not registered when we set the initial transform\n                transform: [\n                    constrainedTransform.x,\n                    constrainedTransform.y,\n                    constrainedTransform.k\n                ],\n                domNode: zoomPane.current.closest(\".react-flow\")\n            });\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (d3Selection && d3Zoom) {\n            if (panOnScroll && !zoomActivationKeyPressed && !userSelectionActive) {\n                d3Selection.on(\"wheel.zoom\", (event)=>{\n                    if (isWrappedWithClass(event, noWheelClassName)) {\n                        return false;\n                    }\n                    event.preventDefault();\n                    event.stopImmediatePropagation();\n                    const currentZoom = d3Selection.property(\"__zoom\").k || 1;\n                    const _isMacOs = isMacOs();\n                    // macos sets ctrlKey=true for pinch gesture on a trackpad\n                    if (event.ctrlKey && zoomOnPinch && _isMacOs) {\n                        const point = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(event);\n                        const pinchDelta = wheelDelta(event);\n                        const zoom = currentZoom * Math.pow(2, pinchDelta);\n                        // @ts-ignore\n                        d3Zoom.scaleTo(d3Selection, zoom, point, event);\n                        return;\n                    }\n                    // increase scroll speed in firefox\n                    // firefox: deltaMode === 1; chrome: deltaMode === 0\n                    const deltaNormalize = event.deltaMode === 1 ? 20 : 1;\n                    let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;\n                    let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;\n                    // this enables vertical scrolling with shift + scroll on windows\n                    if (!_isMacOs && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {\n                        deltaX = event.deltaY * deltaNormalize;\n                        deltaY = 0;\n                    }\n                    d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed, // @ts-ignore\n                    {\n                        internal: true\n                    });\n                    const nextViewport = eventToFlowTransform(d3Selection.property(\"__zoom\"));\n                    const { onViewportChangeStart, onViewportChange, onViewportChangeEnd } = store.getState();\n                    clearTimeout(panScrollTimeout.current);\n                    // for pan on scroll we need to handle the event calls on our own\n                    // we can't use the start, zoom and end events from d3-zoom\n                    // because start and move gets called on every scroll event and not once at the beginning\n                    if (!isPanScrolling.current) {\n                        isPanScrolling.current = true;\n                        onMoveStart?.(event, nextViewport);\n                        onViewportChangeStart?.(nextViewport);\n                    }\n                    if (isPanScrolling.current) {\n                        onMove?.(event, nextViewport);\n                        onViewportChange?.(nextViewport);\n                        panScrollTimeout.current = setTimeout(()=>{\n                            onMoveEnd?.(event, nextViewport);\n                            onViewportChangeEnd?.(nextViewport);\n                            isPanScrolling.current = false;\n                        }, 150);\n                    }\n                }, {\n                    passive: false\n                });\n            } else if (typeof d3ZoomHandler !== \"undefined\") {\n                d3Selection.on(\"wheel.zoom\", function(event, d) {\n                    if (!preventScrolling || isWrappedWithClass(event, noWheelClassName)) {\n                        return null;\n                    }\n                    event.preventDefault();\n                    d3ZoomHandler.call(this, event, d);\n                }, {\n                    passive: false\n                });\n            }\n        }\n    }, [\n        userSelectionActive,\n        panOnScroll,\n        panOnScrollMode,\n        d3Selection,\n        d3Zoom,\n        d3ZoomHandler,\n        zoomActivationKeyPressed,\n        zoomOnPinch,\n        preventScrolling,\n        noWheelClassName,\n        onMoveStart,\n        onMove,\n        onMoveEnd\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (d3Zoom) {\n            d3Zoom.on(\"start\", (event)=>{\n                if (!event.sourceEvent || event.sourceEvent.internal) {\n                    return null;\n                }\n                // we need to remember it here, because it's always 0 in the \"zoom\" event\n                mouseButton.current = event.sourceEvent?.button;\n                const { onViewportChangeStart } = store.getState();\n                const flowTransform = eventToFlowTransform(event.transform);\n                isZoomingOrPanning.current = true;\n                prevTransform.current = flowTransform;\n                if (event.sourceEvent?.type === \"mousedown\") {\n                    store.setState({\n                        paneDragging: true\n                    });\n                }\n                onViewportChangeStart?.(flowTransform);\n                onMoveStart?.(event.sourceEvent, flowTransform);\n            });\n        }\n    }, [\n        d3Zoom,\n        onMoveStart\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (d3Zoom) {\n            if (userSelectionActive && !isZoomingOrPanning.current) {\n                d3Zoom.on(\"zoom\", null);\n            } else if (!userSelectionActive) {\n                d3Zoom.on(\"zoom\", (event)=>{\n                    const { onViewportChange } = store.getState();\n                    store.setState({\n                        transform: [\n                            event.transform.x,\n                            event.transform.y,\n                            event.transform.k\n                        ]\n                    });\n                    zoomedWithRightMouseButton.current = !!(onPaneContextMenu && isRightClickPan(panOnDrag, mouseButton.current ?? 0));\n                    if ((onMove || onViewportChange) && !event.sourceEvent?.internal) {\n                        const flowTransform = eventToFlowTransform(event.transform);\n                        onViewportChange?.(flowTransform);\n                        onMove?.(event.sourceEvent, flowTransform);\n                    }\n                });\n            }\n        }\n    }, [\n        userSelectionActive,\n        d3Zoom,\n        onMove,\n        panOnDrag,\n        onPaneContextMenu\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (d3Zoom) {\n            d3Zoom.on(\"end\", (event)=>{\n                if (!event.sourceEvent || event.sourceEvent.internal) {\n                    return null;\n                }\n                const { onViewportChangeEnd } = store.getState();\n                isZoomingOrPanning.current = false;\n                store.setState({\n                    paneDragging: false\n                });\n                if (onPaneContextMenu && isRightClickPan(panOnDrag, mouseButton.current ?? 0) && !zoomedWithRightMouseButton.current) {\n                    onPaneContextMenu(event.sourceEvent);\n                }\n                zoomedWithRightMouseButton.current = false;\n                if ((onMoveEnd || onViewportChangeEnd) && viewChanged(prevTransform.current, event.transform)) {\n                    const flowTransform = eventToFlowTransform(event.transform);\n                    prevTransform.current = flowTransform;\n                    clearTimeout(timerId.current);\n                    timerId.current = setTimeout(()=>{\n                        onViewportChangeEnd?.(flowTransform);\n                        onMoveEnd?.(event.sourceEvent, flowTransform);\n                    }, panOnScroll ? 150 : 0);\n                }\n            });\n        }\n    }, [\n        d3Zoom,\n        panOnScroll,\n        panOnDrag,\n        onMoveEnd,\n        onPaneContextMenu\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (d3Zoom) {\n            d3Zoom.filter((event)=>{\n                const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;\n                const pinchZoom = zoomOnPinch && event.ctrlKey;\n                if ((panOnDrag === true || Array.isArray(panOnDrag) && panOnDrag.includes(1)) && event.button === 1 && event.type === \"mousedown\" && (isWrappedWithClass(event, \"react-flow__node\") || isWrappedWithClass(event, \"react-flow__edge\"))) {\n                    return true;\n                }\n                // if all interactions are disabled, we prevent all zoom events\n                if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {\n                    return false;\n                }\n                // during a selection we prevent all other interactions\n                if (userSelectionActive) {\n                    return false;\n                }\n                // if zoom on double click is disabled, we prevent the double click event\n                if (!zoomOnDoubleClick && event.type === \"dblclick\") {\n                    return false;\n                }\n                // if the target element is inside an element with the nowheel class, we prevent zooming\n                if (isWrappedWithClass(event, noWheelClassName) && event.type === \"wheel\") {\n                    return false;\n                }\n                // if the target element is inside an element with the nopan class, we prevent panning\n                if (isWrappedWithClass(event, noPanClassName) && (event.type !== \"wheel\" || panOnScroll && event.type === \"wheel\" && !zoomActivationKeyPressed)) {\n                    return false;\n                }\n                if (!zoomOnPinch && event.ctrlKey && event.type === \"wheel\") {\n                    return false;\n                }\n                // when there is no scroll handling enabled, we prevent all wheel events\n                if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === \"wheel\") {\n                    return false;\n                }\n                // if the pane is not movable, we prevent dragging it with mousestart or touchstart\n                if (!panOnDrag && (event.type === \"mousedown\" || event.type === \"touchstart\")) {\n                    return false;\n                }\n                // if the pane is only movable using allowed clicks\n                if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && (event.type === \"mousedown\" || event.type === \"touchstart\")) {\n                    return false;\n                }\n                // We only allow right clicks if pan on drag is set to right click\n                const buttonAllowed = Array.isArray(panOnDrag) && panOnDrag.includes(event.button) || !event.button || event.button <= 1;\n                // default filter for d3-zoom\n                return (!event.ctrlKey || event.type === \"wheel\") && buttonAllowed;\n            });\n        }\n    }, [\n        userSelectionActive,\n        d3Zoom,\n        zoomOnScroll,\n        zoomOnPinch,\n        panOnScroll,\n        zoomOnDoubleClick,\n        panOnDrag,\n        elementsSelectable,\n        zoomActivationKeyPressed\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"react-flow__renderer\",\n        ref: zoomPane,\n        style: containerStyle\n    }, children);\n};\nconst selector$9 = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        userSelectionRect: s.userSelectionRect\n    });\nfunction UserSelection() {\n    const { userSelectionActive, userSelectionRect } = useStore(selector$9, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const isActive = userSelectionActive && userSelectionRect;\n    if (!isActive) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"react-flow__selection react-flow__container\",\n        style: {\n            width: userSelectionRect.width,\n            height: userSelectionRect.height,\n            transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`\n        }\n    });\n}\nfunction handleParentExpand(res, updateItem) {\n    const parent = res.find((e)=>e.id === updateItem.parentNode);\n    if (parent) {\n        const extendWidth = updateItem.position.x + updateItem.width - parent.width;\n        const extendHeight = updateItem.position.y + updateItem.height - parent.height;\n        if (extendWidth > 0 || extendHeight > 0 || updateItem.position.x < 0 || updateItem.position.y < 0) {\n            parent.style = {\n                ...parent.style\n            } || {};\n            parent.style.width = parent.style.width ?? parent.width;\n            parent.style.height = parent.style.height ?? parent.height;\n            if (extendWidth > 0) {\n                parent.style.width += extendWidth;\n            }\n            if (extendHeight > 0) {\n                parent.style.height += extendHeight;\n            }\n            if (updateItem.position.x < 0) {\n                const xDiff = Math.abs(updateItem.position.x);\n                parent.position.x = parent.position.x - xDiff;\n                parent.style.width += xDiff;\n                updateItem.position.x = 0;\n            }\n            if (updateItem.position.y < 0) {\n                const yDiff = Math.abs(updateItem.position.y);\n                parent.position.y = parent.position.y - yDiff;\n                parent.style.height += yDiff;\n                updateItem.position.y = 0;\n            }\n            parent.width = parent.style.width;\n            parent.height = parent.style.height;\n        }\n    }\n}\nfunction applyChanges(changes, elements) {\n    // we need this hack to handle the setNodes and setEdges function of the useReactFlow hook for controlled flows\n    if (changes.some((c)=>c.type === \"reset\")) {\n        return changes.filter((c)=>c.type === \"reset\").map((c)=>c.item);\n    }\n    const initElements = changes.filter((c)=>c.type === \"add\").map((c)=>c.item);\n    return elements.reduce((res, item)=>{\n        const currentChanges = changes.filter((c)=>c.id === item.id);\n        if (currentChanges.length === 0) {\n            res.push(item);\n            return res;\n        }\n        const updateItem = {\n            ...item\n        };\n        for (const currentChange of currentChanges){\n            if (currentChange) {\n                switch(currentChange.type){\n                    case \"select\":\n                        {\n                            updateItem.selected = currentChange.selected;\n                            break;\n                        }\n                    case \"position\":\n                        {\n                            if (typeof currentChange.position !== \"undefined\") {\n                                updateItem.position = currentChange.position;\n                            }\n                            if (typeof currentChange.positionAbsolute !== \"undefined\") {\n                                updateItem.positionAbsolute = currentChange.positionAbsolute;\n                            }\n                            if (typeof currentChange.dragging !== \"undefined\") {\n                                updateItem.dragging = currentChange.dragging;\n                            }\n                            if (updateItem.expandParent) {\n                                handleParentExpand(res, updateItem);\n                            }\n                            break;\n                        }\n                    case \"dimensions\":\n                        {\n                            if (typeof currentChange.dimensions !== \"undefined\") {\n                                updateItem.width = currentChange.dimensions.width;\n                                updateItem.height = currentChange.dimensions.height;\n                            }\n                            if (typeof currentChange.updateStyle !== \"undefined\") {\n                                updateItem.style = {\n                                    ...updateItem.style || {},\n                                    ...currentChange.dimensions\n                                };\n                            }\n                            if (typeof currentChange.resizing === \"boolean\") {\n                                updateItem.resizing = currentChange.resizing;\n                            }\n                            if (updateItem.expandParent) {\n                                handleParentExpand(res, updateItem);\n                            }\n                            break;\n                        }\n                    case \"remove\":\n                        {\n                            return res;\n                        }\n                }\n            }\n        }\n        res.push(updateItem);\n        return res;\n    }, initElements);\n}\nfunction applyNodeChanges(changes, nodes) {\n    return applyChanges(changes, nodes);\n}\nfunction applyEdgeChanges(changes, edges) {\n    return applyChanges(changes, edges);\n}\nconst createSelectionChange = (id, selected)=>({\n        id,\n        type: \"select\",\n        selected\n    });\nfunction getSelectionChanges(items, selectedIds) {\n    return items.reduce((res, item)=>{\n        const willBeSelected = selectedIds.includes(item.id);\n        if (!item.selected && willBeSelected) {\n            item.selected = true;\n            res.push(createSelectionChange(item.id, true));\n        } else if (item.selected && !willBeSelected) {\n            item.selected = false;\n            res.push(createSelectionChange(item.id, false));\n        }\n        return res;\n    }, []);\n}\n/**\n * The user selection rectangle gets displayed when a user drags the mouse while pressing shift\n */ const wrapHandler = (handler, containerRef)=>{\n    return (event)=>{\n        if (event.target !== containerRef.current) {\n            return;\n        }\n        handler?.(event);\n    };\n};\nconst selector$8 = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        elementsSelectable: s.elementsSelectable,\n        dragging: s.paneDragging\n    });\nconst Pane = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ isSelecting, selectionMode = SelectionMode.Full, panOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children })=>{\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const store = useStoreApi();\n    const prevSelectedNodesCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const prevSelectedEdgesCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const { userSelectionActive, elementsSelectable, dragging } = useStore(selector$8, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const resetUserSelection = ()=>{\n        store.setState({\n            userSelectionActive: false,\n            userSelectionRect: null\n        });\n        prevSelectedNodesCount.current = 0;\n        prevSelectedEdgesCount.current = 0;\n    };\n    const onClick = (event)=>{\n        onPaneClick?.(event);\n        store.getState().resetSelectedElements();\n        store.setState({\n            nodesSelectionActive: false\n        });\n    };\n    const onContextMenu = (event)=>{\n        if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {\n            event.preventDefault();\n            return;\n        }\n        onPaneContextMenu?.(event);\n    };\n    const onWheel = onPaneScroll ? (event)=>onPaneScroll(event) : undefined;\n    const onMouseDown = (event)=>{\n        const { resetSelectedElements, domNode } = store.getState();\n        containerBounds.current = domNode?.getBoundingClientRect();\n        if (!elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container.current || !containerBounds.current) {\n            return;\n        }\n        const { x, y } = getEventPosition(event, containerBounds.current);\n        resetSelectedElements();\n        store.setState({\n            userSelectionRect: {\n                width: 0,\n                height: 0,\n                startX: x,\n                startY: y,\n                x,\n                y\n            }\n        });\n        onSelectionStart?.(event);\n    };\n    const onMouseMove = (event)=>{\n        const { userSelectionRect, nodeInternals, edges, transform, onNodesChange, onEdgesChange, nodeOrigin, getNodes } = store.getState();\n        if (!isSelecting || !containerBounds.current || !userSelectionRect) {\n            return;\n        }\n        store.setState({\n            userSelectionActive: true,\n            nodesSelectionActive: false\n        });\n        const mousePos = getEventPosition(event, containerBounds.current);\n        const startX = userSelectionRect.startX ?? 0;\n        const startY = userSelectionRect.startY ?? 0;\n        const nextUserSelectRect = {\n            ...userSelectionRect,\n            x: mousePos.x < startX ? mousePos.x : startX,\n            y: mousePos.y < startY ? mousePos.y : startY,\n            width: Math.abs(mousePos.x - startX),\n            height: Math.abs(mousePos.y - startY)\n        };\n        const nodes = getNodes();\n        const selectedNodes = getNodesInside(nodeInternals, nextUserSelectRect, transform, selectionMode === SelectionMode.Partial, true, nodeOrigin);\n        const selectedEdgeIds = getConnectedEdges(selectedNodes, edges).map((e)=>e.id);\n        const selectedNodeIds = selectedNodes.map((n)=>n.id);\n        if (prevSelectedNodesCount.current !== selectedNodeIds.length) {\n            prevSelectedNodesCount.current = selectedNodeIds.length;\n            const changes = getSelectionChanges(nodes, selectedNodeIds);\n            if (changes.length) {\n                onNodesChange?.(changes);\n            }\n        }\n        if (prevSelectedEdgesCount.current !== selectedEdgeIds.length) {\n            prevSelectedEdgesCount.current = selectedEdgeIds.length;\n            const changes = getSelectionChanges(edges, selectedEdgeIds);\n            if (changes.length) {\n                onEdgesChange?.(changes);\n            }\n        }\n        store.setState({\n            userSelectionRect: nextUserSelectRect\n        });\n    };\n    const onMouseUp = (event)=>{\n        if (event.button !== 0) {\n            return;\n        }\n        const { userSelectionRect } = store.getState();\n        // We only want to trigger click functions when in selection mode if\n        // the user did not move the mouse.\n        if (!userSelectionActive && userSelectionRect && event.target === container.current) {\n            onClick?.(event);\n        }\n        store.setState({\n            nodesSelectionActive: prevSelectedNodesCount.current > 0\n        });\n        resetUserSelection();\n        onSelectionEnd?.(event);\n    };\n    const onMouseLeave = (event)=>{\n        if (userSelectionActive) {\n            store.setState({\n                nodesSelectionActive: prevSelectedNodesCount.current > 0\n            });\n            onSelectionEnd?.(event);\n        }\n        resetUserSelection();\n    };\n    const hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__pane\",\n            {\n                dragging,\n                selection: isSelecting\n            }\n        ]),\n        onClick: hasActiveSelection ? undefined : wrapHandler(onClick, container),\n        onContextMenu: wrapHandler(onContextMenu, container),\n        onWheel: wrapHandler(onWheel, container),\n        onMouseEnter: hasActiveSelection ? undefined : onPaneMouseEnter,\n        onMouseDown: hasActiveSelection ? onMouseDown : undefined,\n        onMouseMove: hasActiveSelection ? onMouseMove : onPaneMouseMove,\n        onMouseUp: hasActiveSelection ? onMouseUp : undefined,\n        onMouseLeave: hasActiveSelection ? onMouseLeave : onPaneMouseLeave,\n        ref: container,\n        style: containerStyle\n    }, children, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(UserSelection, null));\n});\nPane.displayName = \"Pane\";\nfunction isParentSelected(node, nodeInternals) {\n    if (!node.parentNode) {\n        return false;\n    }\n    const parentNode = nodeInternals.get(node.parentNode);\n    if (!parentNode) {\n        return false;\n    }\n    if (parentNode.selected) {\n        return true;\n    }\n    return isParentSelected(parentNode, nodeInternals);\n}\nfunction hasSelector(target, selector, nodeRef) {\n    let current = target;\n    do {\n        if (current?.matches(selector)) return true;\n        if (current === nodeRef.current) return false;\n        current = current.parentElement;\n    }while (current);\n    return false;\n}\n// looks for all selected nodes and created a NodeDragItem for each of them\nfunction getDragItems(nodeInternals, nodesDraggable, mousePos, nodeId) {\n    return Array.from(nodeInternals.values()).filter((n)=>(n.selected || n.id === nodeId) && (!n.parentNode || !isParentSelected(n, nodeInternals)) && (n.draggable || nodesDraggable && typeof n.draggable === \"undefined\")).map((n)=>({\n            id: n.id,\n            position: n.position || {\n                x: 0,\n                y: 0\n            },\n            positionAbsolute: n.positionAbsolute || {\n                x: 0,\n                y: 0\n            },\n            distance: {\n                x: mousePos.x - (n.positionAbsolute?.x ?? 0),\n                y: mousePos.y - (n.positionAbsolute?.y ?? 0)\n            },\n            delta: {\n                x: 0,\n                y: 0\n            },\n            extent: n.extent,\n            parentNode: n.parentNode,\n            width: n.width,\n            height: n.height,\n            expandParent: n.expandParent\n        }));\n}\nfunction clampNodeExtent(node, extent) {\n    if (!extent || extent === \"parent\") {\n        return extent;\n    }\n    return [\n        extent[0],\n        [\n            extent[1][0] - (node.width || 0),\n            extent[1][1] - (node.height || 0)\n        ]\n    ];\n}\nfunction calcNextPosition(node, nextPosition, nodeInternals, nodeExtent, nodeOrigin = [\n    0,\n    0\n], onError) {\n    const clampedNodeExtent = clampNodeExtent(node, node.extent || nodeExtent);\n    let currentExtent = clampedNodeExtent;\n    if (node.extent === \"parent\" && !node.expandParent) {\n        if (node.parentNode && node.width && node.height) {\n            const parent = nodeInternals.get(node.parentNode);\n            const { x: parentX, y: parentY } = getNodePositionWithOrigin(parent, nodeOrigin).positionAbsolute;\n            currentExtent = parent && isNumeric(parentX) && isNumeric(parentY) && isNumeric(parent.width) && isNumeric(parent.height) ? [\n                [\n                    parentX + node.width * nodeOrigin[0],\n                    parentY + node.height * nodeOrigin[1]\n                ],\n                [\n                    parentX + parent.width - node.width + node.width * nodeOrigin[0],\n                    parentY + parent.height - node.height + node.height * nodeOrigin[1]\n                ]\n            ] : currentExtent;\n        } else {\n            onError?.(\"005\", errorMessages[\"error005\"]());\n            currentExtent = clampedNodeExtent;\n        }\n    } else if (node.extent && node.parentNode && node.extent !== \"parent\") {\n        const parent = nodeInternals.get(node.parentNode);\n        const { x: parentX, y: parentY } = getNodePositionWithOrigin(parent, nodeOrigin).positionAbsolute;\n        currentExtent = [\n            [\n                node.extent[0][0] + parentX,\n                node.extent[0][1] + parentY\n            ],\n            [\n                node.extent[1][0] + parentX,\n                node.extent[1][1] + parentY\n            ]\n        ];\n    }\n    let parentPosition = {\n        x: 0,\n        y: 0\n    };\n    if (node.parentNode) {\n        const parentNode = nodeInternals.get(node.parentNode);\n        parentPosition = getNodePositionWithOrigin(parentNode, nodeOrigin).positionAbsolute;\n    }\n    const positionAbsolute = currentExtent && currentExtent !== \"parent\" ? clampPosition(nextPosition, currentExtent) : nextPosition;\n    return {\n        position: {\n            x: positionAbsolute.x - parentPosition.x,\n            y: positionAbsolute.y - parentPosition.y\n        },\n        positionAbsolute\n    };\n}\n// returns two params:\n// 1. the dragged node (or the first of the list, if we are dragging a node selection)\n// 2. array of selected nodes (for multi selections)\nfunction getEventHandlerParams({ nodeId, dragItems, nodeInternals }) {\n    const extentedDragItems = dragItems.map((n)=>{\n        const node = nodeInternals.get(n.id);\n        return {\n            ...node,\n            position: n.position,\n            positionAbsolute: n.positionAbsolute\n        };\n    });\n    return [\n        nodeId ? extentedDragItems.find((n)=>n.id === nodeId) : extentedDragItems[0],\n        extentedDragItems\n    ];\n}\nconst getHandleBounds = (selector, nodeElement, zoom, nodeOrigin)=>{\n    const handles = nodeElement.querySelectorAll(selector);\n    if (!handles || !handles.length) {\n        return null;\n    }\n    const handlesArray = Array.from(handles);\n    const nodeBounds = nodeElement.getBoundingClientRect();\n    const nodeOffset = {\n        x: nodeBounds.width * nodeOrigin[0],\n        y: nodeBounds.height * nodeOrigin[1]\n    };\n    return handlesArray.map((handle)=>{\n        const handleBounds = handle.getBoundingClientRect();\n        return {\n            id: handle.getAttribute(\"data-handleid\"),\n            position: handle.getAttribute(\"data-handlepos\"),\n            x: (handleBounds.left - nodeBounds.left - nodeOffset.x) / zoom,\n            y: (handleBounds.top - nodeBounds.top - nodeOffset.y) / zoom,\n            ...getDimensions(handle)\n        };\n    });\n};\nfunction getMouseHandler(id, getState, handler) {\n    return handler === undefined ? handler : (event)=>{\n        const node = getState().nodeInternals.get(id);\n        if (node) {\n            handler(event, {\n                ...node\n            });\n        }\n    };\n}\n// this handler is called by\n// 1. the click handler when node is not draggable or selectNodesOnDrag = false\n// or\n// 2. the on drag start handler when node is draggable and selectNodesOnDrag = true\nfunction handleNodeClick({ id, store, unselect = false, nodeRef }) {\n    const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeInternals, onError } = store.getState();\n    const node = nodeInternals.get(id);\n    if (!node) {\n        onError?.(\"012\", errorMessages[\"error012\"](id));\n        return;\n    }\n    store.setState({\n        nodesSelectionActive: false\n    });\n    if (!node.selected) {\n        addSelectedNodes([\n            id\n        ]);\n    } else if (unselect || node.selected && multiSelectionActive) {\n        unselectNodesAndEdges({\n            nodes: [\n                node\n            ],\n            edges: []\n        });\n        requestAnimationFrame(()=>nodeRef?.current?.blur());\n    }\n}\nfunction useGetPointerPosition() {\n    const store = useStoreApi();\n    // returns the pointer position projected to the RF coordinate system\n    const getPointerPosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ sourceEvent })=>{\n        const { transform, snapGrid, snapToGrid } = store.getState();\n        const x = sourceEvent.touches ? sourceEvent.touches[0].clientX : sourceEvent.clientX;\n        const y = sourceEvent.touches ? sourceEvent.touches[0].clientY : sourceEvent.clientY;\n        const pointerPos = {\n            x: (x - transform[0]) / transform[2],\n            y: (y - transform[1]) / transform[2]\n        };\n        // we need the snapped position in order to be able to skip unnecessary drag events\n        return {\n            xSnapped: snapToGrid ? snapGrid[0] * Math.round(pointerPos.x / snapGrid[0]) : pointerPos.x,\n            ySnapped: snapToGrid ? snapGrid[1] * Math.round(pointerPos.y / snapGrid[1]) : pointerPos.y,\n            ...pointerPos\n        };\n    }, []);\n    return getPointerPosition;\n}\nfunction wrapSelectionDragFunc(selectionFunc) {\n    return (event, _, nodes)=>selectionFunc?.(event, nodes);\n}\nfunction useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, selectNodesOnDrag }) {\n    const store = useStoreApi();\n    const [dragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const dragItems = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const lastPos = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: null,\n        y: null\n    });\n    const autoPanId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const mousePosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0\n    });\n    const dragEvent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const autoPanStarted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const dragStarted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const getPointerPosition = useGetPointerPosition();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (nodeRef?.current) {\n            const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(nodeRef.current);\n            const updateNodes = ({ x, y })=>{\n                const { nodeInternals, onNodeDrag, onSelectionDrag, updateNodePositions, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onError } = store.getState();\n                lastPos.current = {\n                    x,\n                    y\n                };\n                let hasChange = false;\n                let nodesBox = {\n                    x: 0,\n                    y: 0,\n                    x2: 0,\n                    y2: 0\n                };\n                if (dragItems.current.length > 1 && nodeExtent) {\n                    const rect = getNodesBounds(dragItems.current, nodeOrigin);\n                    nodesBox = rectToBox(rect);\n                }\n                dragItems.current = dragItems.current.map((n)=>{\n                    const nextPosition = {\n                        x: x - n.distance.x,\n                        y: y - n.distance.y\n                    };\n                    if (snapToGrid) {\n                        nextPosition.x = snapGrid[0] * Math.round(nextPosition.x / snapGrid[0]);\n                        nextPosition.y = snapGrid[1] * Math.round(nextPosition.y / snapGrid[1]);\n                    }\n                    // if there is selection with multiple nodes and a node extent is set, we need to adjust the node extent for each node\n                    // based on its position so that the node stays at it's position relative to the selection.\n                    const adjustedNodeExtent = [\n                        [\n                            nodeExtent[0][0],\n                            nodeExtent[0][1]\n                        ],\n                        [\n                            nodeExtent[1][0],\n                            nodeExtent[1][1]\n                        ]\n                    ];\n                    if (dragItems.current.length > 1 && nodeExtent && !n.extent) {\n                        adjustedNodeExtent[0][0] = n.positionAbsolute.x - nodesBox.x + nodeExtent[0][0];\n                        adjustedNodeExtent[1][0] = n.positionAbsolute.x + (n.width ?? 0) - nodesBox.x2 + nodeExtent[1][0];\n                        adjustedNodeExtent[0][1] = n.positionAbsolute.y - nodesBox.y + nodeExtent[0][1];\n                        adjustedNodeExtent[1][1] = n.positionAbsolute.y + (n.height ?? 0) - nodesBox.y2 + nodeExtent[1][1];\n                    }\n                    const updatedPos = calcNextPosition(n, nextPosition, nodeInternals, adjustedNodeExtent, nodeOrigin, onError);\n                    // we want to make sure that we only fire a change event when there is a change\n                    hasChange = hasChange || n.position.x !== updatedPos.position.x || n.position.y !== updatedPos.position.y;\n                    n.position = updatedPos.position;\n                    n.positionAbsolute = updatedPos.positionAbsolute;\n                    return n;\n                });\n                if (!hasChange) {\n                    return;\n                }\n                updateNodePositions(dragItems.current, true, true);\n                setDragging(true);\n                const onDrag = nodeId ? onNodeDrag : wrapSelectionDragFunc(onSelectionDrag);\n                if (onDrag && dragEvent.current) {\n                    const [currentNode, nodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems: dragItems.current,\n                        nodeInternals\n                    });\n                    onDrag(dragEvent.current, currentNode, nodes);\n                }\n            };\n            const autoPan = ()=>{\n                if (!containerBounds.current) {\n                    return;\n                }\n                const [xMovement, yMovement] = calcAutoPan(mousePosition.current, containerBounds.current);\n                if (xMovement !== 0 || yMovement !== 0) {\n                    const { transform, panBy } = store.getState();\n                    lastPos.current.x = (lastPos.current.x ?? 0) - xMovement / transform[2];\n                    lastPos.current.y = (lastPos.current.y ?? 0) - yMovement / transform[2];\n                    if (panBy({\n                        x: xMovement,\n                        y: yMovement\n                    })) {\n                        updateNodes(lastPos.current);\n                    }\n                }\n                autoPanId.current = requestAnimationFrame(autoPan);\n            };\n            const startDrag = (event)=>{\n                const { nodeInternals, multiSelectionActive, nodesDraggable, unselectNodesAndEdges, onNodeDragStart, onSelectionDragStart } = store.getState();\n                dragStarted.current = true;\n                const onStart = nodeId ? onNodeDragStart : wrapSelectionDragFunc(onSelectionDragStart);\n                if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {\n                    if (!nodeInternals.get(nodeId)?.selected) {\n                        // we need to reset selected nodes when selectNodesOnDrag=false\n                        unselectNodesAndEdges();\n                    }\n                }\n                if (nodeId && isSelectable && selectNodesOnDrag) {\n                    handleNodeClick({\n                        id: nodeId,\n                        store,\n                        nodeRef: nodeRef\n                    });\n                }\n                const pointerPos = getPointerPosition(event);\n                lastPos.current = pointerPos;\n                dragItems.current = getDragItems(nodeInternals, nodesDraggable, pointerPos, nodeId);\n                if (onStart && dragItems.current) {\n                    const [currentNode, nodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems: dragItems.current,\n                        nodeInternals\n                    });\n                    onStart(event.sourceEvent, currentNode, nodes);\n                }\n            };\n            if (disabled) {\n                selection.on(\".drag\", null);\n            } else {\n                const dragHandler = (0,d3_drag__WEBPACK_IMPORTED_MODULE_8__[\"default\"])().on(\"start\", (event)=>{\n                    const { domNode, nodeDragThreshold } = store.getState();\n                    if (nodeDragThreshold === 0) {\n                        startDrag(event);\n                    }\n                    const pointerPos = getPointerPosition(event);\n                    lastPos.current = pointerPos;\n                    containerBounds.current = domNode?.getBoundingClientRect() || null;\n                    mousePosition.current = getEventPosition(event.sourceEvent, containerBounds.current);\n                }).on(\"drag\", (event)=>{\n                    const pointerPos = getPointerPosition(event);\n                    const { autoPanOnNodeDrag, nodeDragThreshold } = store.getState();\n                    if (!autoPanStarted.current && dragStarted.current && autoPanOnNodeDrag) {\n                        autoPanStarted.current = true;\n                        autoPan();\n                    }\n                    if (!dragStarted.current) {\n                        const x = pointerPos.xSnapped - (lastPos?.current?.x ?? 0);\n                        const y = pointerPos.ySnapped - (lastPos?.current?.y ?? 0);\n                        const distance = Math.sqrt(x * x + y * y);\n                        if (distance > nodeDragThreshold) {\n                            startDrag(event);\n                        }\n                    }\n                    // skip events without movement\n                    if ((lastPos.current.x !== pointerPos.xSnapped || lastPos.current.y !== pointerPos.ySnapped) && dragItems.current && dragStarted.current) {\n                        dragEvent.current = event.sourceEvent;\n                        mousePosition.current = getEventPosition(event.sourceEvent, containerBounds.current);\n                        updateNodes(pointerPos);\n                    }\n                }).on(\"end\", (event)=>{\n                    if (!dragStarted.current) {\n                        return;\n                    }\n                    setDragging(false);\n                    autoPanStarted.current = false;\n                    dragStarted.current = false;\n                    cancelAnimationFrame(autoPanId.current);\n                    if (dragItems.current) {\n                        const { updateNodePositions, nodeInternals, onNodeDragStop, onSelectionDragStop } = store.getState();\n                        const onStop = nodeId ? onNodeDragStop : wrapSelectionDragFunc(onSelectionDragStop);\n                        updateNodePositions(dragItems.current, false, false);\n                        if (onStop) {\n                            const [currentNode, nodes] = getEventHandlerParams({\n                                nodeId,\n                                dragItems: dragItems.current,\n                                nodeInternals\n                            });\n                            onStop(event.sourceEvent, currentNode, nodes);\n                        }\n                    }\n                }).filter((event)=>{\n                    const target = event.target;\n                    const isDraggable = !event.button && (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, nodeRef)) && (!handleSelector || hasSelector(target, handleSelector, nodeRef));\n                    return isDraggable;\n                });\n                selection.call(dragHandler);\n                return ()=>{\n                    selection.on(\".drag\", null);\n                };\n            }\n        }\n    }, [\n        nodeRef,\n        disabled,\n        noDragClassName,\n        handleSelector,\n        isSelectable,\n        store,\n        nodeId,\n        selectNodesOnDrag,\n        getPointerPosition\n    ]);\n    return dragging;\n}\nfunction useUpdateNodePositions() {\n    const store = useStoreApi();\n    const updatePositions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((params)=>{\n        const { nodeInternals, nodeExtent, updateNodePositions, getNodes, snapToGrid, snapGrid, onError, nodesDraggable } = store.getState();\n        const selectedNodes = getNodes().filter((n)=>n.selected && (n.draggable || nodesDraggable && typeof n.draggable === \"undefined\"));\n        // by default a node moves 5px on each key press, or 20px if shift is pressed\n        // if snap grid is enabled, we use that for the velocity.\n        const xVelo = snapToGrid ? snapGrid[0] : 5;\n        const yVelo = snapToGrid ? snapGrid[1] : 5;\n        const factor = params.isShiftPressed ? 4 : 1;\n        const positionDiffX = params.x * xVelo * factor;\n        const positionDiffY = params.y * yVelo * factor;\n        const nodeUpdates = selectedNodes.map((n)=>{\n            if (n.positionAbsolute) {\n                const nextPosition = {\n                    x: n.positionAbsolute.x + positionDiffX,\n                    y: n.positionAbsolute.y + positionDiffY\n                };\n                if (snapToGrid) {\n                    nextPosition.x = snapGrid[0] * Math.round(nextPosition.x / snapGrid[0]);\n                    nextPosition.y = snapGrid[1] * Math.round(nextPosition.y / snapGrid[1]);\n                }\n                const { positionAbsolute, position } = calcNextPosition(n, nextPosition, nodeInternals, nodeExtent, undefined, onError);\n                n.position = position;\n                n.positionAbsolute = positionAbsolute;\n            }\n            return n;\n        });\n        updateNodePositions(nodeUpdates, true, false);\n    }, []);\n    return updatePositions;\n}\nconst arrowKeyDiffs = {\n    ArrowUp: {\n        x: 0,\n        y: -1\n    },\n    ArrowDown: {\n        x: 0,\n        y: 1\n    },\n    ArrowLeft: {\n        x: -1,\n        y: 0\n    },\n    ArrowRight: {\n        x: 1,\n        y: 0\n    }\n};\nvar wrapNode = (NodeComponent)=>{\n    const NodeWrapper = ({ id, type, data, xPos, yPos, xPosOrigin, yPosOrigin, selected, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, style, className, isDraggable, isSelectable, isConnectable, isFocusable, selectNodesOnDrag, sourcePosition, targetPosition, hidden, resizeObserver, dragHandle, zIndex, isParent, noDragClassName, noPanClassName, initialized, disableKeyboardA11y, ariaLabel, rfId })=>{\n        const store = useStoreApi();\n        const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n        const prevSourcePosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(sourcePosition);\n        const prevTargetPosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(targetPosition);\n        const prevType = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(type);\n        const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;\n        const updatePositions = useUpdateNodePositions();\n        const onMouseEnterHandler = getMouseHandler(id, store.getState, onMouseEnter);\n        const onMouseMoveHandler = getMouseHandler(id, store.getState, onMouseMove);\n        const onMouseLeaveHandler = getMouseHandler(id, store.getState, onMouseLeave);\n        const onContextMenuHandler = getMouseHandler(id, store.getState, onContextMenu);\n        const onDoubleClickHandler = getMouseHandler(id, store.getState, onDoubleClick);\n        const onSelectNodeHandler = (event)=>{\n            const { nodeDragThreshold } = store.getState();\n            if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {\n                // this handler gets called within the drag start event when selectNodesOnDrag=true\n                handleNodeClick({\n                    id,\n                    store,\n                    nodeRef\n                });\n            }\n            if (onClick) {\n                const node = store.getState().nodeInternals.get(id);\n                if (node) {\n                    onClick(event, {\n                        ...node\n                    });\n                }\n            }\n        };\n        const onKeyDown = (event)=>{\n            if (isInputDOMNode(event)) {\n                return;\n            }\n            if (elementSelectionKeys.includes(event.key) && isSelectable) {\n                const unselect = event.key === \"Escape\";\n                handleNodeClick({\n                    id,\n                    store,\n                    unselect,\n                    nodeRef\n                });\n            } else if (!disableKeyboardA11y && isDraggable && selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n                store.setState({\n                    ariaLiveMessage: `Moved selected node ${event.key.replace(\"Arrow\", \"\").toLowerCase()}. New position, x: ${~~xPos}, y: ${~~yPos}`\n                });\n                updatePositions({\n                    x: arrowKeyDiffs[event.key].x,\n                    y: arrowKeyDiffs[event.key].y,\n                    isShiftPressed: event.shiftKey\n                });\n            }\n        };\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            if (nodeRef.current && !hidden) {\n                const currNode = nodeRef.current;\n                resizeObserver?.observe(currNode);\n                return ()=>resizeObserver?.unobserve(currNode);\n            }\n        }, [\n            hidden\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            // when the user programmatically changes the source or handle position, we re-initialize the node\n            const typeChanged = prevType.current !== type;\n            const sourcePosChanged = prevSourcePosition.current !== sourcePosition;\n            const targetPosChanged = prevTargetPosition.current !== targetPosition;\n            if (nodeRef.current && (typeChanged || sourcePosChanged || targetPosChanged)) {\n                if (typeChanged) {\n                    prevType.current = type;\n                }\n                if (sourcePosChanged) {\n                    prevSourcePosition.current = sourcePosition;\n                }\n                if (targetPosChanged) {\n                    prevTargetPosition.current = targetPosition;\n                }\n                store.getState().updateNodeDimensions([\n                    {\n                        id,\n                        nodeElement: nodeRef.current,\n                        forceUpdate: true\n                    }\n                ]);\n            }\n        }, [\n            id,\n            type,\n            sourcePosition,\n            targetPosition\n        ]);\n        const dragging = useDrag({\n            nodeRef,\n            disabled: hidden || !isDraggable,\n            noDragClassName,\n            handleSelector: dragHandle,\n            nodeId: id,\n            isSelectable,\n            selectNodesOnDrag\n        });\n        if (hidden) {\n            return null;\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                \"react-flow__node\",\n                `react-flow__node-${type}`,\n                {\n                    // this is overwritable by passing `nopan` as a class name\n                    [noPanClassName]: isDraggable\n                },\n                className,\n                {\n                    selected,\n                    selectable: isSelectable,\n                    parent: isParent,\n                    dragging\n                }\n            ]),\n            ref: nodeRef,\n            style: {\n                zIndex,\n                transform: `translate(${xPosOrigin}px,${yPosOrigin}px)`,\n                pointerEvents: hasPointerEvents ? \"all\" : \"none\",\n                visibility: initialized ? \"visible\" : \"hidden\",\n                ...style\n            },\n            \"data-id\": id,\n            \"data-testid\": `rf__node-${id}`,\n            onMouseEnter: onMouseEnterHandler,\n            onMouseMove: onMouseMoveHandler,\n            onMouseLeave: onMouseLeaveHandler,\n            onContextMenu: onContextMenuHandler,\n            onClick: onSelectNodeHandler,\n            onDoubleClick: onDoubleClickHandler,\n            onKeyDown: isFocusable ? onKeyDown : undefined,\n            tabIndex: isFocusable ? 0 : undefined,\n            role: isFocusable ? \"button\" : undefined,\n            \"aria-describedby\": disableKeyboardA11y ? undefined : `${ARIA_NODE_DESC_KEY}-${rfId}`,\n            \"aria-label\": ariaLabel\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Provider, {\n            value: id\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NodeComponent, {\n            id: id,\n            data: data,\n            type: type,\n            xPos: xPos,\n            yPos: yPos,\n            selected: selected,\n            isConnectable: isConnectable,\n            sourcePosition: sourcePosition,\n            targetPosition: targetPosition,\n            dragging: dragging,\n            dragHandle: dragHandle,\n            zIndex: zIndex\n        })));\n    };\n    NodeWrapper.displayName = \"NodeWrapper\";\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(NodeWrapper);\n};\n/**\n * The nodes selection rectangle gets displayed when a user\n * made a selection with on or several nodes\n */ const selector$7 = (s)=>{\n    const selectedNodes = s.getNodes().filter((n)=>n.selected);\n    return {\n        ...getNodesBounds(selectedNodes, s.nodeOrigin),\n        transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`,\n        userSelectionActive: s.userSelectionActive\n    };\n};\nfunction NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {\n    const store = useStoreApi();\n    const { width, height, x: left, y: top, transformString, userSelectionActive } = useStore(selector$7, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const updatePositions = useUpdateNodePositions();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!disableKeyboardA11y) {\n            nodeRef.current?.focus({\n                preventScroll: true\n            });\n        }\n    }, [\n        disableKeyboardA11y\n    ]);\n    useDrag({\n        nodeRef\n    });\n    if (userSelectionActive || !width || !height) {\n        return null;\n    }\n    const onContextMenu = onSelectionContextMenu ? (event)=>{\n        const selectedNodes = store.getState().getNodes().filter((n)=>n.selected);\n        onSelectionContextMenu(event, selectedNodes);\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            updatePositions({\n                x: arrowKeyDiffs[event.key].x,\n                y: arrowKeyDiffs[event.key].y,\n                isShiftPressed: event.shiftKey\n            });\n        }\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__nodesselection\",\n            \"react-flow__container\",\n            noPanClassName\n        ]),\n        style: {\n            transform: transformString\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: nodeRef,\n        className: \"react-flow__nodesselection-rect\",\n        onContextMenu: onContextMenu,\n        tabIndex: disableKeyboardA11y ? undefined : -1,\n        onKeyDown: disableKeyboardA11y ? undefined : onKeyDown,\n        style: {\n            width,\n            height,\n            top,\n            left\n        }\n    }));\n}\nvar NodesSelection$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(NodesSelection);\nconst selector$6 = (s)=>s.nodesSelectionActive;\nconst FlowRenderer = ({ children, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, deleteKeyCode, onMove, onMoveStart, onMoveEnd, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y })=>{\n    const nodesSelectionActive = useStore(selector$6);\n    const selectionKeyPressed = useKeyPress(selectionKeyCode);\n    const panActivationKeyPressed = useKeyPress(panActivationKeyCode);\n    const panOnDrag = panActivationKeyPressed || _panOnDrag;\n    const panOnScroll = panActivationKeyPressed || _panOnScroll;\n    const isSelecting = selectionKeyPressed || selectionOnDrag && panOnDrag !== true;\n    useGlobalKeyHandler({\n        deleteKeyCode,\n        multiSelectionKeyCode\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ZoomPane, {\n        onMove: onMove,\n        onMoveStart: onMoveStart,\n        onMoveEnd: onMoveEnd,\n        onPaneContextMenu: onPaneContextMenu,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnDrag: !selectionKeyPressed && panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        preventScrolling: preventScrolling,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Pane, {\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneContextMenu: onPaneContextMenu,\n        onPaneScroll: onPaneScroll,\n        panOnDrag: panOnDrag,\n        isSelecting: !!isSelecting,\n        selectionMode: selectionMode\n    }, children, nodesSelectionActive && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NodesSelection$1, {\n        onSelectionContextMenu: onSelectionContextMenu,\n        noPanClassName: noPanClassName,\n        disableKeyboardA11y: disableKeyboardA11y\n    })));\n};\nFlowRenderer.displayName = \"FlowRenderer\";\nvar FlowRenderer$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(FlowRenderer);\nfunction useVisibleNodes(onlyRenderVisible) {\n    const nodes = useStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((s)=>onlyRenderVisible ? getNodesInside(s.nodeInternals, {\n            x: 0,\n            y: 0,\n            width: s.width,\n            height: s.height\n        }, s.transform, true) : s.getNodes(), [\n        onlyRenderVisible\n    ]));\n    return nodes;\n}\nfunction createNodeTypes(nodeTypes) {\n    const standardTypes = {\n        input: wrapNode(nodeTypes.input || InputNode$1),\n        default: wrapNode(nodeTypes.default || DefaultNode$1),\n        output: wrapNode(nodeTypes.output || OutputNode$1),\n        group: wrapNode(nodeTypes.group || GroupNode)\n    };\n    const wrappedTypes = {};\n    const specialTypes = Object.keys(nodeTypes).filter((k)=>![\n            \"input\",\n            \"default\",\n            \"output\",\n            \"group\"\n        ].includes(k)).reduce((res, key)=>{\n        res[key] = wrapNode(nodeTypes[key] || DefaultNode$1);\n        return res;\n    }, wrappedTypes);\n    return {\n        ...standardTypes,\n        ...specialTypes\n    };\n}\nconst getPositionWithOrigin = ({ x, y, width, height, origin })=>{\n    if (!width || !height) {\n        return {\n            x,\n            y\n        };\n    }\n    if (origin[0] < 0 || origin[1] < 0 || origin[0] > 1 || origin[1] > 1) {\n        return {\n            x,\n            y\n        };\n    }\n    return {\n        x: x - width * origin[0],\n        y: y - height * origin[1]\n    };\n};\nconst selector$5 = (s)=>({\n        nodesDraggable: s.nodesDraggable,\n        nodesConnectable: s.nodesConnectable,\n        nodesFocusable: s.nodesFocusable,\n        elementsSelectable: s.elementsSelectable,\n        updateNodeDimensions: s.updateNodeDimensions,\n        onError: s.onError\n    });\nconst NodeRenderer = (props)=>{\n    const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, updateNodeDimensions, onError } = useStore(selector$5, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const nodes = useVisibleNodes(props.onlyRenderVisibleElements);\n    const resizeObserverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const resizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (typeof ResizeObserver === \"undefined\") {\n            return null;\n        }\n        const observer = new ResizeObserver((entries)=>{\n            const updates = entries.map((entry)=>({\n                    id: entry.target.getAttribute(\"data-id\"),\n                    nodeElement: entry.target,\n                    forceUpdate: true\n                }));\n            updateNodeDimensions(updates);\n        });\n        resizeObserverRef.current = observer;\n        return observer;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            resizeObserverRef?.current?.disconnect();\n        };\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"react-flow__nodes\",\n        style: containerStyle\n    }, nodes.map((node)=>{\n        let nodeType = node.type || \"default\";\n        if (!props.nodeTypes[nodeType]) {\n            onError?.(\"003\", errorMessages[\"error003\"](nodeType));\n            nodeType = \"default\";\n        }\n        const NodeComponent = props.nodeTypes[nodeType] || props.nodeTypes.default;\n        const isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === \"undefined\");\n        const isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === \"undefined\");\n        const isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === \"undefined\");\n        const isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable === \"undefined\");\n        const clampedPosition = props.nodeExtent ? clampPosition(node.positionAbsolute, props.nodeExtent) : node.positionAbsolute;\n        const posX = clampedPosition?.x ?? 0;\n        const posY = clampedPosition?.y ?? 0;\n        const posOrigin = getPositionWithOrigin({\n            x: posX,\n            y: posY,\n            width: node.width ?? 0,\n            height: node.height ?? 0,\n            origin: props.nodeOrigin\n        });\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NodeComponent, {\n            key: node.id,\n            id: node.id,\n            className: node.className,\n            style: node.style,\n            type: nodeType,\n            data: node.data,\n            sourcePosition: node.sourcePosition || Position.Bottom,\n            targetPosition: node.targetPosition || Position.Top,\n            hidden: node.hidden,\n            xPos: posX,\n            yPos: posY,\n            xPosOrigin: posOrigin.x,\n            yPosOrigin: posOrigin.y,\n            selectNodesOnDrag: props.selectNodesOnDrag,\n            onClick: props.onNodeClick,\n            onMouseEnter: props.onNodeMouseEnter,\n            onMouseMove: props.onNodeMouseMove,\n            onMouseLeave: props.onNodeMouseLeave,\n            onContextMenu: props.onNodeContextMenu,\n            onDoubleClick: props.onNodeDoubleClick,\n            selected: !!node.selected,\n            isDraggable: isDraggable,\n            isSelectable: isSelectable,\n            isConnectable: isConnectable,\n            isFocusable: isFocusable,\n            resizeObserver: resizeObserver,\n            dragHandle: node.dragHandle,\n            zIndex: node[internalsSymbol]?.z ?? 0,\n            isParent: !!node[internalsSymbol]?.isParent,\n            noDragClassName: props.noDragClassName,\n            noPanClassName: props.noPanClassName,\n            initialized: !!node.width && !!node.height,\n            rfId: props.rfId,\n            disableKeyboardA11y: props.disableKeyboardA11y,\n            ariaLabel: node.ariaLabel\n        });\n    }));\n};\nNodeRenderer.displayName = \"NodeRenderer\";\nvar NodeRenderer$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(NodeRenderer);\nconst shiftX = (x, shift, position)=>{\n    if (position === Position.Left) return x - shift;\n    if (position === Position.Right) return x + shift;\n    return x;\n};\nconst shiftY = (y, shift, position)=>{\n    if (position === Position.Top) return y - shift;\n    if (position === Position.Bottom) return y + shift;\n    return y;\n};\nconst EdgeUpdaterClassName = \"react-flow__edgeupdater\";\nconst EdgeAnchor = ({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            EdgeUpdaterClassName,\n            `${EdgeUpdaterClassName}-${type}`\n        ]),\n        cx: shiftX(centerX, radius, position),\n        cy: shiftY(centerY, radius, position),\n        r: radius,\n        stroke: \"transparent\",\n        fill: \"transparent\"\n    });\nconst alwaysValidConnection = ()=>true;\nvar wrapEdge = (EdgeComponent)=>{\n    const EdgeWrapper = ({ id, className, type, data, onClick, onEdgeDoubleClick, selected, animated, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, source, target, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, elementsSelectable, hidden, sourceHandleId, targetHandleId, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, edgeUpdaterRadius, onEdgeUpdate, onEdgeUpdateStart, onEdgeUpdateEnd, markerEnd, markerStart, rfId, ariaLabel, isFocusable, isUpdatable, pathOptions, interactionWidth })=>{\n        const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n        const [updateHover, setUpdateHover] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n        const [updating, setUpdating] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n        const store = useStoreApi();\n        const markerStartUrl = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`url(#${getMarkerId(markerStart, rfId)})`, [\n            markerStart,\n            rfId\n        ]);\n        const markerEndUrl = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`url(#${getMarkerId(markerEnd, rfId)})`, [\n            markerEnd,\n            rfId\n        ]);\n        if (hidden) {\n            return null;\n        }\n        const onEdgeClick = (event)=>{\n            const { edges, addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();\n            const edge = edges.find((e)=>e.id === id);\n            if (!edge) {\n                return;\n            }\n            if (elementsSelectable) {\n                store.setState({\n                    nodesSelectionActive: false\n                });\n                if (edge.selected && multiSelectionActive) {\n                    unselectNodesAndEdges({\n                        nodes: [],\n                        edges: [\n                            edge\n                        ]\n                    });\n                    edgeRef.current?.blur();\n                } else {\n                    addSelectedEdges([\n                        id\n                    ]);\n                }\n            }\n            if (onClick) {\n                onClick(event, edge);\n            }\n        };\n        const onEdgeDoubleClickHandler = getMouseHandler$1(id, store.getState, onEdgeDoubleClick);\n        const onEdgeContextMenu = getMouseHandler$1(id, store.getState, onContextMenu);\n        const onEdgeMouseEnter = getMouseHandler$1(id, store.getState, onMouseEnter);\n        const onEdgeMouseMove = getMouseHandler$1(id, store.getState, onMouseMove);\n        const onEdgeMouseLeave = getMouseHandler$1(id, store.getState, onMouseLeave);\n        const handleEdgeUpdater = (event, isSourceHandle)=>{\n            // avoid triggering edge updater if mouse btn is not left\n            if (event.button !== 0) {\n                return;\n            }\n            const { edges, isValidConnection: isValidConnectionStore } = store.getState();\n            const nodeId = isSourceHandle ? target : source;\n            const handleId = (isSourceHandle ? targetHandleId : sourceHandleId) || null;\n            const handleType = isSourceHandle ? \"target\" : \"source\";\n            const isValidConnection = isValidConnectionStore || alwaysValidConnection;\n            const isTarget = isSourceHandle;\n            const edge = edges.find((e)=>e.id === id);\n            setUpdating(true);\n            onEdgeUpdateStart?.(event, edge, handleType);\n            const _onEdgeUpdateEnd = (evt)=>{\n                setUpdating(false);\n                onEdgeUpdateEnd?.(evt, edge, handleType);\n            };\n            const onConnectEdge = (connection)=>onEdgeUpdate?.(edge, connection);\n            handlePointerDown({\n                event,\n                handleId,\n                nodeId,\n                onConnect: onConnectEdge,\n                isTarget,\n                getState: store.getState,\n                setState: store.setState,\n                isValidConnection,\n                edgeUpdaterType: handleType,\n                onEdgeUpdateEnd: _onEdgeUpdateEnd\n            });\n        };\n        const onEdgeUpdaterSourceMouseDown = (event)=>handleEdgeUpdater(event, true);\n        const onEdgeUpdaterTargetMouseDown = (event)=>handleEdgeUpdater(event, false);\n        const onEdgeUpdaterMouseEnter = ()=>setUpdateHover(true);\n        const onEdgeUpdaterMouseOut = ()=>setUpdateHover(false);\n        const inactive = !elementsSelectable && !onClick;\n        const onKeyDown = (event)=>{\n            if (elementSelectionKeys.includes(event.key) && elementsSelectable) {\n                const { unselectNodesAndEdges, addSelectedEdges, edges } = store.getState();\n                const unselect = event.key === \"Escape\";\n                if (unselect) {\n                    edgeRef.current?.blur();\n                    unselectNodesAndEdges({\n                        edges: [\n                            edges.find((e)=>e.id === id)\n                        ]\n                    });\n                } else {\n                    addSelectedEdges([\n                        id\n                    ]);\n                }\n            }\n        };\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                \"react-flow__edge\",\n                `react-flow__edge-${type}`,\n                className,\n                {\n                    selected,\n                    animated,\n                    inactive,\n                    updating: updateHover\n                }\n            ]),\n            onClick: onEdgeClick,\n            onDoubleClick: onEdgeDoubleClickHandler,\n            onContextMenu: onEdgeContextMenu,\n            onMouseEnter: onEdgeMouseEnter,\n            onMouseMove: onEdgeMouseMove,\n            onMouseLeave: onEdgeMouseLeave,\n            onKeyDown: isFocusable ? onKeyDown : undefined,\n            tabIndex: isFocusable ? 0 : undefined,\n            role: isFocusable ? \"button\" : \"img\",\n            \"data-testid\": `rf__edge-${id}`,\n            \"aria-label\": ariaLabel === null ? undefined : ariaLabel ? ariaLabel : `Edge from ${source} to ${target}`,\n            \"aria-describedby\": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : undefined,\n            ref: edgeRef\n        }, !updating && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeComponent, {\n            id: id,\n            source: source,\n            target: target,\n            selected: selected,\n            animated: animated,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            data: data,\n            style: style,\n            sourceX: sourceX,\n            sourceY: sourceY,\n            targetX: targetX,\n            targetY: targetY,\n            sourcePosition: sourcePosition,\n            targetPosition: targetPosition,\n            sourceHandleId: sourceHandleId,\n            targetHandleId: targetHandleId,\n            markerStart: markerStartUrl,\n            markerEnd: markerEndUrl,\n            pathOptions: pathOptions,\n            interactionWidth: interactionWidth\n        }), isUpdatable && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (isUpdatable === \"source\" || isUpdatable === true) && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeAnchor, {\n            position: sourcePosition,\n            centerX: sourceX,\n            centerY: sourceY,\n            radius: edgeUpdaterRadius,\n            onMouseDown: onEdgeUpdaterSourceMouseDown,\n            onMouseEnter: onEdgeUpdaterMouseEnter,\n            onMouseOut: onEdgeUpdaterMouseOut,\n            type: \"source\"\n        }), (isUpdatable === \"target\" || isUpdatable === true) && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeAnchor, {\n            position: targetPosition,\n            centerX: targetX,\n            centerY: targetY,\n            radius: edgeUpdaterRadius,\n            onMouseDown: onEdgeUpdaterTargetMouseDown,\n            onMouseEnter: onEdgeUpdaterMouseEnter,\n            onMouseOut: onEdgeUpdaterMouseOut,\n            type: \"target\"\n        })));\n    };\n    EdgeWrapper.displayName = \"EdgeWrapper\";\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(EdgeWrapper);\n};\nfunction createEdgeTypes(edgeTypes) {\n    const standardTypes = {\n        default: wrapEdge(edgeTypes.default || BezierEdge),\n        straight: wrapEdge(edgeTypes.bezier || StraightEdge),\n        step: wrapEdge(edgeTypes.step || StepEdge),\n        smoothstep: wrapEdge(edgeTypes.step || SmoothStepEdge),\n        simplebezier: wrapEdge(edgeTypes.simplebezier || SimpleBezierEdge)\n    };\n    const wrappedTypes = {};\n    const specialTypes = Object.keys(edgeTypes).filter((k)=>![\n            \"default\",\n            \"bezier\"\n        ].includes(k)).reduce((res, key)=>{\n        res[key] = wrapEdge(edgeTypes[key] || BezierEdge);\n        return res;\n    }, wrappedTypes);\n    return {\n        ...standardTypes,\n        ...specialTypes\n    };\n}\nfunction getHandlePosition(position, nodeRect, handle = null) {\n    const x = (handle?.x || 0) + nodeRect.x;\n    const y = (handle?.y || 0) + nodeRect.y;\n    const width = handle?.width || nodeRect.width;\n    const height = handle?.height || nodeRect.height;\n    switch(position){\n        case Position.Top:\n            return {\n                x: x + width / 2,\n                y\n            };\n        case Position.Right:\n            return {\n                x: x + width,\n                y: y + height / 2\n            };\n        case Position.Bottom:\n            return {\n                x: x + width / 2,\n                y: y + height\n            };\n        case Position.Left:\n            return {\n                x,\n                y: y + height / 2\n            };\n    }\n}\nfunction getHandle(bounds, handleId) {\n    if (!bounds) {\n        return null;\n    }\n    if (bounds.length === 1 || !handleId) {\n        return bounds[0];\n    } else if (handleId) {\n        return bounds.find((d)=>d.id === handleId) || null;\n    }\n    return null;\n}\nconst getEdgePositions = (sourceNodeRect, sourceHandle, sourcePosition, targetNodeRect, targetHandle, targetPosition)=>{\n    const sourceHandlePos = getHandlePosition(sourcePosition, sourceNodeRect, sourceHandle);\n    const targetHandlePos = getHandlePosition(targetPosition, targetNodeRect, targetHandle);\n    return {\n        sourceX: sourceHandlePos.x,\n        sourceY: sourceHandlePos.y,\n        targetX: targetHandlePos.x,\n        targetY: targetHandlePos.y\n    };\n};\nfunction isEdgeVisible({ sourcePos, targetPos, sourceWidth, sourceHeight, targetWidth, targetHeight, width, height, transform }) {\n    const edgeBox = {\n        x: Math.min(sourcePos.x, targetPos.x),\n        y: Math.min(sourcePos.y, targetPos.y),\n        x2: Math.max(sourcePos.x + sourceWidth, targetPos.x + targetWidth),\n        y2: Math.max(sourcePos.y + sourceHeight, targetPos.y + targetHeight)\n    };\n    if (edgeBox.x === edgeBox.x2) {\n        edgeBox.x2 += 1;\n    }\n    if (edgeBox.y === edgeBox.y2) {\n        edgeBox.y2 += 1;\n    }\n    const viewBox = rectToBox({\n        x: (0 - transform[0]) / transform[2],\n        y: (0 - transform[1]) / transform[2],\n        width: width / transform[2],\n        height: height / transform[2]\n    });\n    const xOverlap = Math.max(0, Math.min(viewBox.x2, edgeBox.x2) - Math.max(viewBox.x, edgeBox.x));\n    const yOverlap = Math.max(0, Math.min(viewBox.y2, edgeBox.y2) - Math.max(viewBox.y, edgeBox.y));\n    const overlappingArea = Math.ceil(xOverlap * yOverlap);\n    return overlappingArea > 0;\n}\nfunction getNodeData(node) {\n    const handleBounds = node?.[internalsSymbol]?.handleBounds || null;\n    const isValid = handleBounds && node?.width && node?.height && typeof node?.positionAbsolute?.x !== \"undefined\" && typeof node?.positionAbsolute?.y !== \"undefined\";\n    return [\n        {\n            x: node?.positionAbsolute?.x || 0,\n            y: node?.positionAbsolute?.y || 0,\n            width: node?.width || 0,\n            height: node?.height || 0\n        },\n        handleBounds,\n        !!isValid\n    ];\n}\nconst defaultEdgeTree = [\n    {\n        level: 0,\n        isMaxLevel: true,\n        edges: []\n    }\n];\nfunction groupEdgesByZLevel(edges, nodeInternals, elevateEdgesOnSelect = false) {\n    let maxLevel = -1;\n    const levelLookup = edges.reduce((tree, edge)=>{\n        const hasZIndex = isNumeric(edge.zIndex);\n        let z = hasZIndex ? edge.zIndex : 0;\n        if (elevateEdgesOnSelect) {\n            const targetNode = nodeInternals.get(edge.target);\n            const sourceNode = nodeInternals.get(edge.source);\n            const edgeOrConnectedNodeSelected = edge.selected || targetNode?.selected || sourceNode?.selected;\n            const selectedZIndex = Math.max(sourceNode?.[internalsSymbol]?.z || 0, targetNode?.[internalsSymbol]?.z || 0, 1000);\n            z = (hasZIndex ? edge.zIndex : 0) + (edgeOrConnectedNodeSelected ? selectedZIndex : 0);\n        }\n        if (tree[z]) {\n            tree[z].push(edge);\n        } else {\n            tree[z] = [\n                edge\n            ];\n        }\n        maxLevel = z > maxLevel ? z : maxLevel;\n        return tree;\n    }, {});\n    const edgeTree = Object.entries(levelLookup).map(([key, edges])=>{\n        const level = +key;\n        return {\n            edges,\n            level,\n            isMaxLevel: level === maxLevel\n        };\n    });\n    if (edgeTree.length === 0) {\n        return defaultEdgeTree;\n    }\n    return edgeTree;\n}\nfunction useVisibleEdges(onlyRenderVisible, nodeInternals, elevateEdgesOnSelect) {\n    const edges = useStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((s)=>{\n        if (!onlyRenderVisible) {\n            return s.edges;\n        }\n        return s.edges.filter((e)=>{\n            const sourceNode = nodeInternals.get(e.source);\n            const targetNode = nodeInternals.get(e.target);\n            return sourceNode?.width && sourceNode?.height && targetNode?.width && targetNode?.height && isEdgeVisible({\n                sourcePos: sourceNode.positionAbsolute || {\n                    x: 0,\n                    y: 0\n                },\n                targetPos: targetNode.positionAbsolute || {\n                    x: 0,\n                    y: 0\n                },\n                sourceWidth: sourceNode.width,\n                sourceHeight: sourceNode.height,\n                targetWidth: targetNode.width,\n                targetHeight: targetNode.height,\n                width: s.width,\n                height: s.height,\n                transform: s.transform\n            });\n        });\n    }, [\n        onlyRenderVisible,\n        nodeInternals\n    ]));\n    return groupEdgesByZLevel(edges, nodeInternals, elevateEdgesOnSelect);\n}\nconst ArrowSymbol = ({ color = \"none\", strokeWidth = 1 })=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"polyline\", {\n        style: {\n            stroke: color,\n            strokeWidth\n        },\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        fill: \"none\",\n        points: \"-5,-4 0,0 -5,4\"\n    });\n};\nconst ArrowClosedSymbol = ({ color = \"none\", strokeWidth = 1 })=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"polyline\", {\n        style: {\n            stroke: color,\n            fill: color,\n            strokeWidth\n        },\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4 -5,-4\"\n    });\n};\nconst MarkerSymbols = {\n    [MarkerType.Arrow]: ArrowSymbol,\n    [MarkerType.ArrowClosed]: ArrowClosedSymbol\n};\nfunction useMarkerSymbol(type) {\n    const store = useStoreApi();\n    const symbol = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);\n        if (!symbolExists) {\n            store.getState().onError?.(\"009\", errorMessages[\"error009\"](type));\n            return null;\n        }\n        return MarkerSymbols[type];\n    }, [\n        type\n    ]);\n    return symbol;\n}\nconst Marker = ({ id, type, color, width = 12.5, height = 12.5, markerUnits = \"strokeWidth\", strokeWidth, orient = \"auto-start-reverse\" })=>{\n    const Symbol1 = useMarkerSymbol(type);\n    if (!Symbol1) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"marker\", {\n        className: \"react-flow__arrowhead\",\n        id: id,\n        markerWidth: `${width}`,\n        markerHeight: `${height}`,\n        viewBox: \"-10 -10 20 20\",\n        markerUnits: markerUnits,\n        orient: orient,\n        refX: \"0\",\n        refY: \"0\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Symbol1, {\n        color: color,\n        strokeWidth: strokeWidth\n    }));\n};\nconst markerSelector = ({ defaultColor, rfId })=>(s)=>{\n        const ids = [];\n        return s.edges.reduce((markers, edge)=>{\n            [\n                edge.markerStart,\n                edge.markerEnd\n            ].forEach((marker)=>{\n                if (marker && typeof marker === \"object\") {\n                    const markerId = getMarkerId(marker, rfId);\n                    if (!ids.includes(markerId)) {\n                        markers.push({\n                            id: markerId,\n                            color: marker.color || defaultColor,\n                            ...marker\n                        });\n                        ids.push(markerId);\n                    }\n                }\n            });\n            return markers;\n        }, []).sort((a, b)=>a.id.localeCompare(b.id));\n    };\n// when you have multiple flows on a page and you hide the first one, the other ones have no markers anymore\n// when they do have markers with the same ids. To prevent this the user can pass a unique id to the react flow wrapper\n// that we can then use for creating our unique marker ids\nconst MarkerDefinitions = ({ defaultColor, rfId })=>{\n    const markers = useStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(markerSelector({\n        defaultColor,\n        rfId\n    }), [\n        defaultColor,\n        rfId\n    ]), // the id includes all marker options, so we just need to look at that part of the marker\n    (a, b)=>!(a.length !== b.length || a.some((m, i)=>m.id !== b[i].id)));\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"defs\", null, markers.map((marker)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Marker, {\n            id: marker.id,\n            key: marker.id,\n            type: marker.type,\n            color: marker.color,\n            width: marker.width,\n            height: marker.height,\n            markerUnits: marker.markerUnits,\n            strokeWidth: marker.strokeWidth,\n            orient: marker.orient\n        })));\n};\nMarkerDefinitions.displayName = \"MarkerDefinitions\";\nvar MarkerDefinitions$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(MarkerDefinitions);\nconst selector$4 = (s)=>({\n        nodesConnectable: s.nodesConnectable,\n        edgesFocusable: s.edgesFocusable,\n        edgesUpdatable: s.edgesUpdatable,\n        elementsSelectable: s.elementsSelectable,\n        width: s.width,\n        height: s.height,\n        connectionMode: s.connectionMode,\n        nodeInternals: s.nodeInternals,\n        onError: s.onError\n    });\nconst EdgeRenderer = ({ defaultMarkerColor, onlyRenderVisibleElements, elevateEdgesOnSelect, rfId, edgeTypes, noPanClassName, onEdgeUpdate, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, edgeUpdaterRadius, onEdgeDoubleClick, onEdgeUpdateStart, onEdgeUpdateEnd, children })=>{\n    const { edgesFocusable, edgesUpdatable, elementsSelectable, width, height, connectionMode, nodeInternals, onError } = useStore(selector$4, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const edgeTree = useVisibleEdges(onlyRenderVisibleElements, nodeInternals, elevateEdgesOnSelect);\n    if (!width) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, edgeTree.map(({ level, edges, isMaxLevel })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n            key: level,\n            style: {\n                zIndex: level\n            },\n            width: width,\n            height: height,\n            className: \"react-flow__edges react-flow__container\"\n        }, isMaxLevel && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkerDefinitions$1, {\n            defaultColor: defaultMarkerColor,\n            rfId: rfId\n        }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", null, edges.map((edge)=>{\n            const [sourceNodeRect, sourceHandleBounds, sourceIsValid] = getNodeData(nodeInternals.get(edge.source));\n            const [targetNodeRect, targetHandleBounds, targetIsValid] = getNodeData(nodeInternals.get(edge.target));\n            if (!sourceIsValid || !targetIsValid) {\n                return null;\n            }\n            let edgeType = edge.type || \"default\";\n            if (!edgeTypes[edgeType]) {\n                onError?.(\"011\", errorMessages[\"error011\"](edgeType));\n                edgeType = \"default\";\n            }\n            const EdgeComponent = edgeTypes[edgeType] || edgeTypes.default;\n            // when connection type is loose we can define all handles as sources and connect source -> source\n            const targetNodeHandles = connectionMode === ConnectionMode.Strict ? targetHandleBounds.target : (targetHandleBounds.target ?? []).concat(targetHandleBounds.source ?? []);\n            const sourceHandle = getHandle(sourceHandleBounds.source, edge.sourceHandle);\n            const targetHandle = getHandle(targetNodeHandles, edge.targetHandle);\n            const sourcePosition = sourceHandle?.position || Position.Bottom;\n            const targetPosition = targetHandle?.position || Position.Top;\n            const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable === \"undefined\");\n            const isUpdatable = typeof onEdgeUpdate !== \"undefined\" && (edge.updatable || edgesUpdatable && typeof edge.updatable === \"undefined\");\n            if (!sourceHandle || !targetHandle) {\n                onError?.(\"008\", errorMessages[\"error008\"](sourceHandle, edge));\n                return null;\n            }\n            const { sourceX, sourceY, targetX, targetY } = getEdgePositions(sourceNodeRect, sourceHandle, sourcePosition, targetNodeRect, targetHandle, targetPosition);\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeComponent, {\n                key: edge.id,\n                id: edge.id,\n                className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                    edge.className,\n                    noPanClassName\n                ]),\n                type: edgeType,\n                data: edge.data,\n                selected: !!edge.selected,\n                animated: !!edge.animated,\n                hidden: !!edge.hidden,\n                label: edge.label,\n                labelStyle: edge.labelStyle,\n                labelShowBg: edge.labelShowBg,\n                labelBgStyle: edge.labelBgStyle,\n                labelBgPadding: edge.labelBgPadding,\n                labelBgBorderRadius: edge.labelBgBorderRadius,\n                style: edge.style,\n                source: edge.source,\n                target: edge.target,\n                sourceHandleId: edge.sourceHandle,\n                targetHandleId: edge.targetHandle,\n                markerEnd: edge.markerEnd,\n                markerStart: edge.markerStart,\n                sourceX: sourceX,\n                sourceY: sourceY,\n                targetX: targetX,\n                targetY: targetY,\n                sourcePosition: sourcePosition,\n                targetPosition: targetPosition,\n                elementsSelectable: elementsSelectable,\n                onEdgeUpdate: onEdgeUpdate,\n                onContextMenu: onEdgeContextMenu,\n                onMouseEnter: onEdgeMouseEnter,\n                onMouseMove: onEdgeMouseMove,\n                onMouseLeave: onEdgeMouseLeave,\n                onClick: onEdgeClick,\n                edgeUpdaterRadius: edgeUpdaterRadius,\n                onEdgeDoubleClick: onEdgeDoubleClick,\n                onEdgeUpdateStart: onEdgeUpdateStart,\n                onEdgeUpdateEnd: onEdgeUpdateEnd,\n                rfId: rfId,\n                ariaLabel: edge.ariaLabel,\n                isFocusable: isFocusable,\n                isUpdatable: isUpdatable,\n                pathOptions: \"pathOptions\" in edge ? edge.pathOptions : undefined,\n                interactionWidth: edge.interactionWidth\n            });\n        })))), children);\n};\nEdgeRenderer.displayName = \"EdgeRenderer\";\nvar EdgeRenderer$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(EdgeRenderer);\nconst selector$3 = (s)=>`translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;\nfunction Viewport({ children }) {\n    const transform = useStore(selector$3);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"react-flow__viewport react-flow__container\",\n        style: {\n            transform\n        }\n    }, children);\n}\nfunction useOnInitHandler(onInit) {\n    const rfInstance = useReactFlow();\n    const isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {\n            setTimeout(()=>onInit(rfInstance), 1);\n            isInitialized.current = true;\n        }\n    }, [\n        onInit,\n        rfInstance.viewportInitialized\n    ]);\n}\nconst oppositePosition = {\n    [Position.Left]: Position.Right,\n    [Position.Right]: Position.Left,\n    [Position.Top]: Position.Bottom,\n    [Position.Bottom]: Position.Top\n};\nconst ConnectionLine = ({ nodeId, handleType, style, type = ConnectionLineType.Bezier, CustomComponent, connectionStatus })=>{\n    const { fromNode, handleId, toX, toY, connectionMode } = useStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((s)=>({\n            fromNode: s.nodeInternals.get(nodeId),\n            handleId: s.connectionHandleId,\n            toX: (s.connectionPosition.x - s.transform[0]) / s.transform[2],\n            toY: (s.connectionPosition.y - s.transform[1]) / s.transform[2],\n            connectionMode: s.connectionMode\n        }), [\n        nodeId\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const fromHandleBounds = fromNode?.[internalsSymbol]?.handleBounds;\n    let handleBounds = fromHandleBounds?.[handleType];\n    if (connectionMode === ConnectionMode.Loose) {\n        handleBounds = handleBounds ? handleBounds : fromHandleBounds?.[handleType === \"source\" ? \"target\" : \"source\"];\n    }\n    if (!fromNode || !handleBounds) {\n        return null;\n    }\n    const fromHandle = handleId ? handleBounds.find((d)=>d.id === handleId) : handleBounds[0];\n    const fromHandleX = fromHandle ? fromHandle.x + fromHandle.width / 2 : (fromNode.width ?? 0) / 2;\n    const fromHandleY = fromHandle ? fromHandle.y + fromHandle.height / 2 : fromNode.height ?? 0;\n    const fromX = (fromNode.positionAbsolute?.x ?? 0) + fromHandleX;\n    const fromY = (fromNode.positionAbsolute?.y ?? 0) + fromHandleY;\n    const fromPosition = fromHandle?.position;\n    const toPosition = fromPosition ? oppositePosition[fromPosition] : null;\n    if (!fromPosition || !toPosition) {\n        return null;\n    }\n    if (CustomComponent) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CustomComponent, {\n            connectionLineType: type,\n            connectionLineStyle: style,\n            fromNode: fromNode,\n            fromHandle: fromHandle,\n            fromX: fromX,\n            fromY: fromY,\n            toX: toX,\n            toY: toY,\n            fromPosition: fromPosition,\n            toPosition: toPosition,\n            connectionStatus: connectionStatus\n        });\n    }\n    let dAttr = \"\";\n    const pathParams = {\n        sourceX: fromX,\n        sourceY: fromY,\n        sourcePosition: fromPosition,\n        targetX: toX,\n        targetY: toY,\n        targetPosition: toPosition\n    };\n    if (type === ConnectionLineType.Bezier) {\n        // we assume the destination position is opposite to the source position\n        [dAttr] = getBezierPath(pathParams);\n    } else if (type === ConnectionLineType.Step) {\n        [dAttr] = getSmoothStepPath({\n            ...pathParams,\n            borderRadius: 0\n        });\n    } else if (type === ConnectionLineType.SmoothStep) {\n        [dAttr] = getSmoothStepPath(pathParams);\n    } else if (type === ConnectionLineType.SimpleBezier) {\n        [dAttr] = getSimpleBezierPath(pathParams);\n    } else {\n        dAttr = `M${fromX},${fromY} ${toX},${toY}`;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: dAttr,\n        fill: \"none\",\n        className: \"react-flow__connection-path\",\n        style: style\n    });\n};\nConnectionLine.displayName = \"ConnectionLine\";\nconst selector$2 = (s)=>({\n        nodeId: s.connectionNodeId,\n        handleType: s.connectionHandleType,\n        nodesConnectable: s.nodesConnectable,\n        connectionStatus: s.connectionStatus,\n        width: s.width,\n        height: s.height\n    });\nfunction ConnectionLineWrapper({ containerStyle, style, type, component }) {\n    const { nodeId, handleType, nodesConnectable, width, height, connectionStatus } = useStore(selector$2, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const isValid = !!(nodeId && handleType && width && nodesConnectable);\n    if (!isValid) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        style: containerStyle,\n        width: width,\n        height: height,\n        className: \"react-flow__edges react-flow__connectionline react-flow__container\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__connection\",\n            connectionStatus\n        ])\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConnectionLine, {\n        nodeId: nodeId,\n        handleType: handleType,\n        style: style,\n        type: type,\n        CustomComponent: component,\n        connectionStatus: connectionStatus\n    })));\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodeOrEdgeTypes(nodeOrEdgeTypes, createTypes) {\n    const typesKeysRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const store = useStoreApi();\n    const typesParsed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (true) {\n            const typeKeys = Object.keys(nodeOrEdgeTypes);\n            if ((0,zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow)(typesKeysRef.current, typeKeys)) {\n                store.getState().onError?.(\"002\", errorMessages[\"error002\"]());\n            }\n            typesKeysRef.current = typeKeys;\n        }\n        return createTypes(nodeOrEdgeTypes);\n    }, [\n        nodeOrEdgeTypes\n    ]);\n    return typesParsed;\n}\nconst GraphView = ({ nodeTypes, edgeTypes, onMove, onMoveStart, onMoveEnd, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, selectNodesOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, onEdgeUpdate, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, edgeUpdaterRadius, onEdgeUpdateStart, onEdgeUpdateEnd, noDragClassName, noWheelClassName, noPanClassName, elevateEdgesOnSelect, disableKeyboardA11y, nodeOrigin, nodeExtent, rfId })=>{\n    const nodeTypesWrapped = useNodeOrEdgeTypes(nodeTypes, createNodeTypes);\n    const edgeTypesWrapped = useNodeOrEdgeTypes(edgeTypes, createEdgeTypes);\n    useOnInitHandler(onInit);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FlowRenderer$1, {\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneContextMenu: onPaneContextMenu,\n        onPaneScroll: onPaneScroll,\n        deleteKeyCode: deleteKeyCode,\n        selectionKeyCode: selectionKeyCode,\n        selectionOnDrag: selectionOnDrag,\n        selectionMode: selectionMode,\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        multiSelectionKeyCode: multiSelectionKeyCode,\n        panActivationKeyCode: panActivationKeyCode,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        elementsSelectable: elementsSelectable,\n        onMove: onMove,\n        onMoveStart: onMoveStart,\n        onMoveEnd: onMoveEnd,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        panOnDrag: panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        onSelectionContextMenu: onSelectionContextMenu,\n        preventScrolling: preventScrolling,\n        noDragClassName: noDragClassName,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        disableKeyboardA11y: disableKeyboardA11y\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Viewport, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeRenderer$1, {\n        edgeTypes: edgeTypesWrapped,\n        onEdgeClick: onEdgeClick,\n        onEdgeDoubleClick: onEdgeDoubleClick,\n        onEdgeUpdate: onEdgeUpdate,\n        onlyRenderVisibleElements: onlyRenderVisibleElements,\n        onEdgeContextMenu: onEdgeContextMenu,\n        onEdgeMouseEnter: onEdgeMouseEnter,\n        onEdgeMouseMove: onEdgeMouseMove,\n        onEdgeMouseLeave: onEdgeMouseLeave,\n        onEdgeUpdateStart: onEdgeUpdateStart,\n        onEdgeUpdateEnd: onEdgeUpdateEnd,\n        edgeUpdaterRadius: edgeUpdaterRadius,\n        defaultMarkerColor: defaultMarkerColor,\n        noPanClassName: noPanClassName,\n        elevateEdgesOnSelect: !!elevateEdgesOnSelect,\n        disableKeyboardA11y: disableKeyboardA11y,\n        rfId: rfId\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConnectionLineWrapper, {\n        style: connectionLineStyle,\n        type: connectionLineType,\n        component: connectionLineComponent,\n        containerStyle: connectionLineContainerStyle\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"react-flow__edgelabel-renderer\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NodeRenderer$1, {\n        nodeTypes: nodeTypesWrapped,\n        onNodeClick: onNodeClick,\n        onNodeDoubleClick: onNodeDoubleClick,\n        onNodeMouseEnter: onNodeMouseEnter,\n        onNodeMouseMove: onNodeMouseMove,\n        onNodeMouseLeave: onNodeMouseLeave,\n        onNodeContextMenu: onNodeContextMenu,\n        selectNodesOnDrag: selectNodesOnDrag,\n        onlyRenderVisibleElements: onlyRenderVisibleElements,\n        noPanClassName: noPanClassName,\n        noDragClassName: noDragClassName,\n        disableKeyboardA11y: disableKeyboardA11y,\n        nodeOrigin: nodeOrigin,\n        nodeExtent: nodeExtent,\n        rfId: rfId\n    })));\n};\nGraphView.displayName = \"GraphView\";\nvar GraphView$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(GraphView);\nconst infiniteExtent = [\n    [\n        Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY\n    ],\n    [\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY\n    ]\n];\nconst initialState = {\n    rfId: \"1\",\n    width: 0,\n    height: 0,\n    transform: [\n        0,\n        0,\n        1\n    ],\n    nodeInternals: new Map(),\n    edges: [],\n    onNodesChange: null,\n    onEdgesChange: null,\n    hasDefaultNodes: false,\n    hasDefaultEdges: false,\n    d3Zoom: null,\n    d3Selection: null,\n    d3ZoomHandler: undefined,\n    minZoom: 0.5,\n    maxZoom: 2,\n    translateExtent: infiniteExtent,\n    nodeExtent: infiniteExtent,\n    nodesSelectionActive: false,\n    userSelectionActive: false,\n    userSelectionRect: null,\n    connectionNodeId: null,\n    connectionHandleId: null,\n    connectionHandleType: \"source\",\n    connectionPosition: {\n        x: 0,\n        y: 0\n    },\n    connectionStatus: null,\n    connectionMode: ConnectionMode.Strict,\n    domNode: null,\n    paneDragging: false,\n    noPanClassName: \"nopan\",\n    nodeOrigin: [\n        0,\n        0\n    ],\n    nodeDragThreshold: 0,\n    snapGrid: [\n        15,\n        15\n    ],\n    snapToGrid: false,\n    nodesDraggable: true,\n    nodesConnectable: true,\n    nodesFocusable: true,\n    edgesFocusable: true,\n    edgesUpdatable: true,\n    elementsSelectable: true,\n    elevateNodesOnSelect: true,\n    fitViewOnInit: false,\n    fitViewOnInitDone: false,\n    fitViewOnInitOptions: undefined,\n    onSelectionChange: [],\n    multiSelectionActive: false,\n    connectionStartHandle: null,\n    connectionEndHandle: null,\n    connectionClickStartHandle: null,\n    connectOnClick: true,\n    ariaLiveMessage: \"\",\n    autoPanOnConnect: true,\n    autoPanOnNodeDrag: true,\n    connectionRadius: 20,\n    onError: devWarn,\n    isValidConnection: undefined\n};\nconst createRFStore = ()=>(0,zustand_traditional__WEBPACK_IMPORTED_MODULE_4__.createWithEqualityFn)((set, get)=>({\n            ...initialState,\n            setNodes: (nodes)=>{\n                const { nodeInternals, nodeOrigin, elevateNodesOnSelect } = get();\n                set({\n                    nodeInternals: createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect)\n                });\n            },\n            getNodes: ()=>{\n                return Array.from(get().nodeInternals.values());\n            },\n            setEdges: (edges)=>{\n                const { defaultEdgeOptions = {} } = get();\n                set({\n                    edges: edges.map((e)=>({\n                            ...defaultEdgeOptions,\n                            ...e\n                        }))\n                });\n            },\n            setDefaultNodesAndEdges: (nodes, edges)=>{\n                const hasDefaultNodes = typeof nodes !== \"undefined\";\n                const hasDefaultEdges = typeof edges !== \"undefined\";\n                const nodeInternals = hasDefaultNodes ? createNodeInternals(nodes, new Map(), get().nodeOrigin, get().elevateNodesOnSelect) : new Map();\n                const nextEdges = hasDefaultEdges ? edges : [];\n                set({\n                    nodeInternals,\n                    edges: nextEdges,\n                    hasDefaultNodes,\n                    hasDefaultEdges\n                });\n            },\n            updateNodeDimensions: (updates)=>{\n                const { onNodesChange, nodeInternals, fitViewOnInit, fitViewOnInitDone, fitViewOnInitOptions, domNode, nodeOrigin } = get();\n                const viewportNode = domNode?.querySelector(\".react-flow__viewport\");\n                if (!viewportNode) {\n                    return;\n                }\n                const style = window.getComputedStyle(viewportNode);\n                const { m22: zoom } = new window.DOMMatrixReadOnly(style.transform);\n                const changes = updates.reduce((res, update)=>{\n                    const node = nodeInternals.get(update.id);\n                    if (node) {\n                        const dimensions = getDimensions(update.nodeElement);\n                        const doUpdate = !!(dimensions.width && dimensions.height && (node.width !== dimensions.width || node.height !== dimensions.height || update.forceUpdate));\n                        if (doUpdate) {\n                            nodeInternals.set(node.id, {\n                                ...node,\n                                [internalsSymbol]: {\n                                    ...node[internalsSymbol],\n                                    handleBounds: {\n                                        source: getHandleBounds(\".source\", update.nodeElement, zoom, nodeOrigin),\n                                        target: getHandleBounds(\".target\", update.nodeElement, zoom, nodeOrigin)\n                                    }\n                                },\n                                ...dimensions\n                            });\n                            res.push({\n                                id: node.id,\n                                type: \"dimensions\",\n                                dimensions\n                            });\n                        }\n                    }\n                    return res;\n                }, []);\n                updateAbsoluteNodePositions(nodeInternals, nodeOrigin);\n                const nextFitViewOnInitDone = fitViewOnInitDone || fitViewOnInit && !fitViewOnInitDone && fitView(get, {\n                    initial: true,\n                    ...fitViewOnInitOptions\n                });\n                set({\n                    nodeInternals: new Map(nodeInternals),\n                    fitViewOnInitDone: nextFitViewOnInitDone\n                });\n                if (changes?.length > 0) {\n                    onNodesChange?.(changes);\n                }\n            },\n            updateNodePositions: (nodeDragItems, positionChanged = true, dragging = false)=>{\n                const { triggerNodeChanges } = get();\n                const changes = nodeDragItems.map((node)=>{\n                    const change = {\n                        id: node.id,\n                        type: \"position\",\n                        dragging\n                    };\n                    if (positionChanged) {\n                        change.positionAbsolute = node.positionAbsolute;\n                        change.position = node.position;\n                    }\n                    return change;\n                });\n                triggerNodeChanges(changes);\n            },\n            triggerNodeChanges: (changes)=>{\n                const { onNodesChange, nodeInternals, hasDefaultNodes, nodeOrigin, getNodes, elevateNodesOnSelect } = get();\n                if (changes?.length) {\n                    if (hasDefaultNodes) {\n                        const nodes = applyNodeChanges(changes, getNodes());\n                        const nextNodeInternals = createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect);\n                        set({\n                            nodeInternals: nextNodeInternals\n                        });\n                    }\n                    onNodesChange?.(changes);\n                }\n            },\n            addSelectedNodes: (selectedNodeIds)=>{\n                const { multiSelectionActive, edges, getNodes } = get();\n                let changedNodes;\n                let changedEdges = null;\n                if (multiSelectionActive) {\n                    changedNodes = selectedNodeIds.map((nodeId)=>createSelectionChange(nodeId, true));\n                } else {\n                    changedNodes = getSelectionChanges(getNodes(), selectedNodeIds);\n                    changedEdges = getSelectionChanges(edges, []);\n                }\n                updateNodesAndEdgesSelections({\n                    changedNodes,\n                    changedEdges,\n                    get,\n                    set\n                });\n            },\n            addSelectedEdges: (selectedEdgeIds)=>{\n                const { multiSelectionActive, edges, getNodes } = get();\n                let changedEdges;\n                let changedNodes = null;\n                if (multiSelectionActive) {\n                    changedEdges = selectedEdgeIds.map((edgeId)=>createSelectionChange(edgeId, true));\n                } else {\n                    changedEdges = getSelectionChanges(edges, selectedEdgeIds);\n                    changedNodes = getSelectionChanges(getNodes(), []);\n                }\n                updateNodesAndEdgesSelections({\n                    changedNodes,\n                    changedEdges,\n                    get,\n                    set\n                });\n            },\n            unselectNodesAndEdges: ({ nodes, edges } = {})=>{\n                const { edges: storeEdges, getNodes } = get();\n                const nodesToUnselect = nodes ? nodes : getNodes();\n                const edgesToUnselect = edges ? edges : storeEdges;\n                const changedNodes = nodesToUnselect.map((n)=>{\n                    n.selected = false;\n                    return createSelectionChange(n.id, false);\n                });\n                const changedEdges = edgesToUnselect.map((edge)=>createSelectionChange(edge.id, false));\n                updateNodesAndEdgesSelections({\n                    changedNodes,\n                    changedEdges,\n                    get,\n                    set\n                });\n            },\n            setMinZoom: (minZoom)=>{\n                const { d3Zoom, maxZoom } = get();\n                d3Zoom?.scaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    minZoom\n                });\n            },\n            setMaxZoom: (maxZoom)=>{\n                const { d3Zoom, minZoom } = get();\n                d3Zoom?.scaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    maxZoom\n                });\n            },\n            setTranslateExtent: (translateExtent)=>{\n                get().d3Zoom?.translateExtent(translateExtent);\n                set({\n                    translateExtent\n                });\n            },\n            resetSelectedElements: ()=>{\n                const { edges, getNodes } = get();\n                const nodes = getNodes();\n                const nodesToUnselect = nodes.filter((e)=>e.selected).map((n)=>createSelectionChange(n.id, false));\n                const edgesToUnselect = edges.filter((e)=>e.selected).map((e)=>createSelectionChange(e.id, false));\n                updateNodesAndEdgesSelections({\n                    changedNodes: nodesToUnselect,\n                    changedEdges: edgesToUnselect,\n                    get,\n                    set\n                });\n            },\n            setNodeExtent: (nodeExtent)=>{\n                const { nodeInternals } = get();\n                nodeInternals.forEach((node)=>{\n                    node.positionAbsolute = clampPosition(node.position, nodeExtent);\n                });\n                set({\n                    nodeExtent,\n                    nodeInternals: new Map(nodeInternals)\n                });\n            },\n            panBy: (delta)=>{\n                const { transform, width, height, d3Zoom, d3Selection, translateExtent } = get();\n                if (!d3Zoom || !d3Selection || !delta.x && !delta.y) {\n                    return false;\n                }\n                const nextTransform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(transform[0] + delta.x, transform[1] + delta.y).scale(transform[2]);\n                const extent = [\n                    [\n                        0,\n                        0\n                    ],\n                    [\n                        width,\n                        height\n                    ]\n                ];\n                const constrainedTransform = d3Zoom?.constrain()(nextTransform, extent, translateExtent);\n                d3Zoom.transform(d3Selection, constrainedTransform);\n                const transformChanged = transform[0] !== constrainedTransform.x || transform[1] !== constrainedTransform.y || transform[2] !== constrainedTransform.k;\n                return transformChanged;\n            },\n            cancelConnection: ()=>set({\n                    connectionNodeId: initialState.connectionNodeId,\n                    connectionHandleId: initialState.connectionHandleId,\n                    connectionHandleType: initialState.connectionHandleType,\n                    connectionStatus: initialState.connectionStatus,\n                    connectionStartHandle: initialState.connectionStartHandle,\n                    connectionEndHandle: initialState.connectionEndHandle\n                }),\n            reset: ()=>set({\n                    ...initialState\n                })\n        }), Object.is);\nconst ReactFlowProvider = ({ children })=>{\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    if (!storeRef.current) {\n        storeRef.current = createRFStore();\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Provider$1, {\n        value: storeRef.current\n    }, children);\n};\nReactFlowProvider.displayName = \"ReactFlowProvider\";\nconst Wrapper = ({ children })=>{\n    const isWrapped = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    if (isWrapped) {\n        // we need to wrap it with a fragment because it's not allowed for children to be a ReactNode\n        // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children);\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ReactFlowProvider, null, children);\n};\nWrapper.displayName = \"ReactFlowWrapper\";\nconst defaultNodeTypes = {\n    input: InputNode$1,\n    default: DefaultNode$1,\n    output: OutputNode$1,\n    group: GroupNode\n};\nconst defaultEdgeTypes = {\n    default: BezierEdge,\n    straight: StraightEdge,\n    step: StepEdge,\n    smoothstep: SmoothStepEdge,\n    simplebezier: SimpleBezierEdge\n};\nconst initNodeOrigin = [\n    0,\n    0\n];\nconst initSnapGrid = [\n    15,\n    15\n];\nconst initDefaultViewport = {\n    x: 0,\n    y: 0,\n    zoom: 1\n};\nconst wrapperStyle = {\n    width: \"100%\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    position: \"relative\",\n    zIndex: 0\n};\nconst ReactFlow = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes = defaultNodeTypes, edgeTypes = defaultEdgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionMode = ConnectionMode.Strict, connectionLineType = ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = \"Backspace\", selectionKeyCode = \"Shift\", selectionOnDrag = false, selectionMode = SelectionMode.Full, panActivationKeyCode = \"Space\", multiSelectionKeyCode = isMacOs() ? \"Meta\" : \"Control\", zoomActivationKeyCode = isMacOs() ? \"Meta\" : \"Control\", snapToGrid = false, snapGrid = initSnapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag = true, nodesDraggable, nodesConnectable, nodesFocusable, nodeOrigin = initNodeOrigin, edgesFocusable, edgesUpdatable, elementsSelectable, defaultViewport = initDefaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = \"#b1b1b7\", zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, children, onEdgeUpdate, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeUpdateStart, onEdgeUpdateEnd, edgeUpdaterRadius = 10, onNodesChange, onEdgesChange, noDragClassName = \"nodrag\", noWheelClassName = \"nowheel\", noPanClassName = \"nopan\", fitView = false, fitViewOptions, connectOnClick = true, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect = true, elevateEdgesOnSelect = false, disableKeyboardA11y = false, autoPanOnConnect = true, autoPanOnNodeDrag = true, connectionRadius = 20, isValidConnection, onError, style, id, nodeDragThreshold, ...rest }, ref)=>{\n    const rfId = id || \"1\";\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ...rest,\n        style: {\n            ...style,\n            ...wrapperStyle\n        },\n        ref: ref,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow\",\n            className\n        ]),\n        \"data-testid\": \"rf__wrapper\",\n        id: id\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Wrapper, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GraphView$1, {\n        onInit: onInit,\n        onMove: onMove,\n        onMoveStart: onMoveStart,\n        onMoveEnd: onMoveEnd,\n        onNodeClick: onNodeClick,\n        onEdgeClick: onEdgeClick,\n        onNodeMouseEnter: onNodeMouseEnter,\n        onNodeMouseMove: onNodeMouseMove,\n        onNodeMouseLeave: onNodeMouseLeave,\n        onNodeContextMenu: onNodeContextMenu,\n        onNodeDoubleClick: onNodeDoubleClick,\n        nodeTypes: nodeTypes,\n        edgeTypes: edgeTypes,\n        connectionLineType: connectionLineType,\n        connectionLineStyle: connectionLineStyle,\n        connectionLineComponent: connectionLineComponent,\n        connectionLineContainerStyle: connectionLineContainerStyle,\n        selectionKeyCode: selectionKeyCode,\n        selectionOnDrag: selectionOnDrag,\n        selectionMode: selectionMode,\n        deleteKeyCode: deleteKeyCode,\n        multiSelectionKeyCode: multiSelectionKeyCode,\n        panActivationKeyCode: panActivationKeyCode,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        onlyRenderVisibleElements: onlyRenderVisibleElements,\n        selectNodesOnDrag: selectNodesOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        preventScrolling: preventScrolling,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        panOnDrag: panOnDrag,\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneScroll: onPaneScroll,\n        onPaneContextMenu: onPaneContextMenu,\n        onSelectionContextMenu: onSelectionContextMenu,\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        onEdgeUpdate: onEdgeUpdate,\n        onEdgeContextMenu: onEdgeContextMenu,\n        onEdgeDoubleClick: onEdgeDoubleClick,\n        onEdgeMouseEnter: onEdgeMouseEnter,\n        onEdgeMouseMove: onEdgeMouseMove,\n        onEdgeMouseLeave: onEdgeMouseLeave,\n        onEdgeUpdateStart: onEdgeUpdateStart,\n        onEdgeUpdateEnd: onEdgeUpdateEnd,\n        edgeUpdaterRadius: edgeUpdaterRadius,\n        defaultMarkerColor: defaultMarkerColor,\n        noDragClassName: noDragClassName,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        elevateEdgesOnSelect: elevateEdgesOnSelect,\n        rfId: rfId,\n        disableKeyboardA11y: disableKeyboardA11y,\n        nodeOrigin: nodeOrigin,\n        nodeExtent: nodeExtent\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(StoreUpdater, {\n        nodes: nodes,\n        edges: edges,\n        defaultNodes: defaultNodes,\n        defaultEdges: defaultEdges,\n        onConnect: onConnect,\n        onConnectStart: onConnectStart,\n        onConnectEnd: onConnectEnd,\n        onClickConnectStart: onClickConnectStart,\n        onClickConnectEnd: onClickConnectEnd,\n        nodesDraggable: nodesDraggable,\n        nodesConnectable: nodesConnectable,\n        nodesFocusable: nodesFocusable,\n        edgesFocusable: edgesFocusable,\n        edgesUpdatable: edgesUpdatable,\n        elementsSelectable: elementsSelectable,\n        elevateNodesOnSelect: elevateNodesOnSelect,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        nodeExtent: nodeExtent,\n        onNodesChange: onNodesChange,\n        onEdgesChange: onEdgesChange,\n        snapToGrid: snapToGrid,\n        snapGrid: snapGrid,\n        connectionMode: connectionMode,\n        translateExtent: translateExtent,\n        connectOnClick: connectOnClick,\n        defaultEdgeOptions: defaultEdgeOptions,\n        fitView: fitView,\n        fitViewOptions: fitViewOptions,\n        onNodesDelete: onNodesDelete,\n        onEdgesDelete: onEdgesDelete,\n        onNodeDragStart: onNodeDragStart,\n        onNodeDrag: onNodeDrag,\n        onNodeDragStop: onNodeDragStop,\n        onSelectionDrag: onSelectionDrag,\n        onSelectionDragStart: onSelectionDragStart,\n        onSelectionDragStop: onSelectionDragStop,\n        noPanClassName: noPanClassName,\n        nodeOrigin: nodeOrigin,\n        rfId: rfId,\n        autoPanOnConnect: autoPanOnConnect,\n        autoPanOnNodeDrag: autoPanOnNodeDrag,\n        onError: onError,\n        connectionRadius: connectionRadius,\n        isValidConnection: isValidConnection,\n        nodeDragThreshold: nodeDragThreshold\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Wrapper$1, {\n        onSelectionChange: onSelectionChange\n    }), children, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Attribution, {\n        proOptions: proOptions,\n        position: attributionPosition\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(A11yDescriptions, {\n        rfId: rfId,\n        disableKeyboardA11y: disableKeyboardA11y\n    })));\n});\nReactFlow.displayName = \"ReactFlow\";\nconst selector$1 = (s)=>s.domNode?.querySelector(\".react-flow__edgelabel-renderer\");\nfunction EdgeLabelRenderer({ children }) {\n    const edgeLabelRenderer = useStore(selector$1);\n    if (!edgeLabelRenderer) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_3__.createPortal)(children, edgeLabelRenderer);\n}\nfunction useUpdateNodeInternals() {\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        const { domNode, updateNodeDimensions } = store.getState();\n        const updateIds = Array.isArray(id) ? id : [\n            id\n        ];\n        const updates = updateIds.reduce((res, updateId)=>{\n            const nodeElement = domNode?.querySelector(`.react-flow__node[data-id=\"${updateId}\"]`);\n            if (nodeElement) {\n                res.push({\n                    id: updateId,\n                    nodeElement,\n                    forceUpdate: true\n                });\n            }\n            return res;\n        }, []);\n        requestAnimationFrame(()=>updateNodeDimensions(updates));\n    }, []);\n}\nconst nodesSelector = (state)=>state.getNodes();\nfunction useNodes() {\n    const nodes = useStore(nodesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    return nodes;\n}\nconst edgesSelector = (state)=>state.edges;\nfunction useEdges() {\n    const edges = useStore(edgesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    return edges;\n}\nconst viewportSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2]\n    });\nfunction useViewport() {\n    const viewport = useStore(viewportSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    return viewport;\n}\n/* eslint-disable @typescript-eslint/no-explicit-any */ function createUseItemsState(applyChanges) {\n    return (initialItems)=>{\n        const [items, setItems] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialItems);\n        const onItemsChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((changes)=>setItems((items)=>applyChanges(changes, items)), []);\n        return [\n            items,\n            setItems,\n            onItemsChange\n        ];\n    };\n}\nconst useNodesState = createUseItemsState(applyNodeChanges);\nconst useEdgesState = createUseItemsState(applyEdgeChanges);\nfunction useOnViewportChange({ onStart, onChange, onEnd }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        store.setState({\n            onViewportChangeStart: onStart\n        });\n    }, [\n        onStart\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        store.setState({\n            onViewportChange: onChange\n        });\n    }, [\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        store.setState({\n            onViewportChangeEnd: onEnd\n        });\n    }, [\n        onEnd\n    ]);\n}\nfunction useOnSelectionChange({ onChange }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const nextSelectionChangeHandlers = [\n            ...store.getState().onSelectionChange,\n            onChange\n        ];\n        store.setState({\n            onSelectionChange: nextSelectionChangeHandlers\n        });\n        return ()=>{\n            const nextHandlers = store.getState().onSelectionChange.filter((fn)=>fn !== onChange);\n            store.setState({\n                onSelectionChange: nextHandlers\n            });\n        };\n    }, [\n        onChange\n    ]);\n}\nconst selector = (options)=>(s)=>{\n        if (s.nodeInternals.size === 0) {\n            return false;\n        }\n        return s.getNodes().filter((n)=>options.includeHiddenNodes ? true : !n.hidden).every((n)=>n[internalsSymbol]?.handleBounds !== undefined);\n    };\nconst defaultOptions = {\n    includeHiddenNodes: false\n};\nfunction useNodesInitialized(options = defaultOptions) {\n    const initialized = useStore(selector(options));\n    return initialized;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0ByZWFjdGZsb3cvY29yZS9kaXN0L2VzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4SDtBQUNwRztBQUN5RDtBQUN6QztBQUNHO0FBQ0U7QUFDaEI7QUFDVTtBQUV6QyxNQUFNb0IsNkJBQWVuQixvREFBYUEsQ0FBQztBQUNuQyxNQUFNb0IsYUFBYUQsYUFBYUUsUUFBUTtBQUV4QyxNQUFNQyxnQkFBZ0I7SUFDbEJDLFVBQVUsSUFBTTtJQUNoQkMsVUFBVSxJQUFNO0lBQ2hCQyxVQUFVLENBQUNDLFdBQWEsQ0FBQyxXQUFXLEVBQUVBLFNBQVMsMkNBQTJDLENBQUM7SUFDM0ZDLFVBQVUsSUFBTTtJQUNoQkMsVUFBVSxJQUFNO0lBQ2hCQyxVQUFVLElBQU07SUFDaEJDLFVBQVUsQ0FBQ0MsS0FBTyxDQUFDLHFCQUFxQixFQUFFQSxHQUFHLGdCQUFnQixDQUFDO0lBQzlEQyxVQUFVLENBQUNDLE9BQVMsQ0FBQyxhQUFhLEVBQUVBLEtBQUssZ0JBQWdCLENBQUM7SUFDMURDLFVBQVUsQ0FBQ0MsY0FBY0MsT0FBUyxDQUFDLHlCQUF5QixFQUFFLENBQUNELGVBQWUsV0FBVyxTQUFTLGFBQWEsRUFBRSxDQUFDQSxlQUFlQyxLQUFLRCxZQUFZLEdBQUdDLEtBQUtDLFlBQVksQ0FBQyxZQUFZLEVBQUVELEtBQUtMLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDL0xPLFVBQVUsSUFBTTtJQUNoQkMsVUFBVSxDQUFDQyxXQUFhLENBQUMsV0FBVyxFQUFFQSxTQUFTLDJDQUEyQyxDQUFDO0lBQzNGQyxVQUFVLENBQUNWLEtBQU8sQ0FBQyxjQUFjLEVBQUVBLEdBQUcsOEhBQThILENBQUM7QUFDeks7QUFFQSxNQUFNVyxzQkFBc0JwQixhQUFhLENBQUMsV0FBVztBQUNyRCxTQUFTcUIsU0FBU0MsUUFBUSxFQUFF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QTtLQUFNO0FBQ2Q7QUFFQSxTQUFTQyxxQkFBcUIsRUFBRUYsUUFBUSxFQUFFO0lBQ3RDLE1BQU1qckMsUUFBUUU7SUFDZDFDLGdEQUFTQSxDQUFDO1FBQ04sTUFBTTR0Qyw4QkFBOEI7ZUFBSXByQyxNQUFNRyxRQUFRLEdBQUcyZCxpQkFBaUI7WUFBRW10QjtTQUFTO1FBQ3JGanJDLE1BQU1JLFFBQVEsQ0FBQztZQUFFMGQsbUJBQW1Cc3RCO1FBQTRCO1FBQ2hFLE9BQU87WUFDSCxNQUFNQyxlQUFlcnJDLE1BQU1HLFFBQVEsR0FBRzJkLGlCQUFpQixDQUFDdk4sTUFBTSxDQUFDLENBQUN3TixLQUFPQSxPQUFPa3RCO1lBQzlFanJDLE1BQU1JLFFBQVEsQ0FBQztnQkFBRTBkLG1CQUFtQnV0QjtZQUFhO1FBQ3JEO0lBQ0osR0FBRztRQUFDSjtLQUFTO0FBQ2pCO0FBRUEsTUFBTW5yQyxXQUFXLENBQUNnUyxVQUFZLENBQUN0UjtRQUMzQixJQUFJQSxFQUFFMlMsYUFBYSxDQUFDNUUsSUFBSSxLQUFLLEdBQUc7WUFDNUIsT0FBTztRQUNYO1FBQ0EsT0FBTy9OLEVBQ0YwWSxRQUFRLEdBQ1IzSSxNQUFNLENBQUMsQ0FBQ3ZLLElBQU84TCxRQUFRdVQsa0JBQWtCLEdBQUcsT0FBTyxDQUFDcmYsRUFBRTJOLE1BQU0sRUFDNUQ2UCxLQUFLLENBQUMsQ0FBQ3hkLElBQU1BLENBQUMsQ0FBQ0csZ0JBQWdCLEVBQUVrUCxpQkFBaUI5TDtJQUMzRDtBQUNBLE1BQU0raEMsaUJBQWlCO0lBQ25Cam1CLG9CQUFvQjtBQUN4QjtBQUNBLFNBQVNrbUIsb0JBQW9CejVCLFVBQVV3NUIsY0FBYztJQUNqRCxNQUFNN1MsY0FBYzU0QixTQUFTQyxTQUFTZ1M7SUFDdEMsT0FBTzJtQjtBQUNYO0FBRTI0QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BsaWZlLWdyYXBoL2Zyb250ZW5kMi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0Zmxvdy9jb3JlL2Rpc3QvZXNtL2luZGV4Lm1qcz82OGE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vLCBtZW1vLCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIGZvcndhcmRSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNjIGZyb20gJ2NsYXNzY2F0JztcbmltcG9ydCB7IHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4sIGNyZWF0ZVdpdGhFcXVhbGl0eUZuIH0gZnJvbSAnenVzdGFuZC90cmFkaXRpb25hbCc7XG5pbXBvcnQgeyBzaGFsbG93IH0gZnJvbSAnenVzdGFuZC9zaGFsbG93JztcbmltcG9ydCB7IHpvb21JZGVudGl0eSwgem9vbSB9IGZyb20gJ2QzLXpvb20nO1xuaW1wb3J0IHsgc2VsZWN0LCBwb2ludGVyIH0gZnJvbSAnZDMtc2VsZWN0aW9uJztcbmltcG9ydCB7IGRyYWcgfSBmcm9tICdkMy1kcmFnJztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5cbmNvbnN0IFN0b3JlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBQcm92aWRlciQxID0gU3RvcmVDb250ZXh0LlByb3ZpZGVyO1xuXG5jb25zdCBlcnJvck1lc3NhZ2VzID0ge1xuICAgIGVycm9yMDAxOiAoKSA9PiAnW1JlYWN0IEZsb3ddOiBTZWVtcyBsaWtlIHlvdSBoYXZlIG5vdCB1c2VkIHp1c3RhbmQgcHJvdmlkZXIgYXMgYW4gYW5jZXN0b3IuIEhlbHA6IGh0dHBzOi8vcmVhY3RmbG93LmRldi9lcnJvciMwMDEnLFxuICAgIGVycm9yMDAyOiAoKSA9PiBcIkl0IGxvb2tzIGxpa2UgeW91J3ZlIGNyZWF0ZWQgYSBuZXcgbm9kZVR5cGVzIG9yIGVkZ2VUeXBlcyBvYmplY3QuIElmIHRoaXMgd2Fzbid0IG9uIHB1cnBvc2UgcGxlYXNlIGRlZmluZSB0aGUgbm9kZVR5cGVzL2VkZ2VUeXBlcyBvdXRzaWRlIG9mIHRoZSBjb21wb25lbnQgb3IgbWVtb2l6ZSB0aGVtLlwiLFxuICAgIGVycm9yMDAzOiAobm9kZVR5cGUpID0+IGBOb2RlIHR5cGUgXCIke25vZGVUeXBlfVwiIG5vdCBmb3VuZC4gVXNpbmcgZmFsbGJhY2sgdHlwZSBcImRlZmF1bHRcIi5gLFxuICAgIGVycm9yMDA0OiAoKSA9PiAnVGhlIFJlYWN0IEZsb3cgcGFyZW50IGNvbnRhaW5lciBuZWVkcyBhIHdpZHRoIGFuZCBhIGhlaWdodCB0byByZW5kZXIgdGhlIGdyYXBoLicsXG4gICAgZXJyb3IwMDU6ICgpID0+ICdPbmx5IGNoaWxkIG5vZGVzIGNhbiB1c2UgYSBwYXJlbnQgZXh0ZW50LicsXG4gICAgZXJyb3IwMDY6ICgpID0+IFwiQ2FuJ3QgY3JlYXRlIGVkZ2UuIEFuIGVkZ2UgbmVlZHMgYSBzb3VyY2UgYW5kIGEgdGFyZ2V0LlwiLFxuICAgIGVycm9yMDA3OiAoaWQpID0+IGBUaGUgb2xkIGVkZ2Ugd2l0aCBpZD0ke2lkfSBkb2VzIG5vdCBleGlzdC5gLFxuICAgIGVycm9yMDA5OiAodHlwZSkgPT4gYE1hcmtlciB0eXBlIFwiJHt0eXBlfVwiIGRvZXNuJ3QgZXhpc3QuYCxcbiAgICBlcnJvcjAwODogKHNvdXJjZUhhbmRsZSwgZWRnZSkgPT4gYENvdWxkbid0IGNyZWF0ZSBlZGdlIGZvciAkeyFzb3VyY2VIYW5kbGUgPyAnc291cmNlJyA6ICd0YXJnZXQnfSBoYW5kbGUgaWQ6IFwiJHshc291cmNlSGFuZGxlID8gZWRnZS5zb3VyY2VIYW5kbGUgOiBlZGdlLnRhcmdldEhhbmRsZX1cIiwgZWRnZSBpZDogJHtlZGdlLmlkfS5gLFxuICAgIGVycm9yMDEwOiAoKSA9PiAnSGFuZGxlOiBObyBub2RlIGlkIGZvdW5kLiBNYWtlIHN1cmUgdG8gb25seSB1c2UgYSBIYW5kbGUgaW5zaWRlIGEgY3VzdG9tIE5vZGUuJyxcbiAgICBlcnJvcjAxMTogKGVkZ2VUeXBlKSA9PiBgRWRnZSB0eXBlIFwiJHtlZGdlVHlwZX1cIiBub3QgZm91bmQuIFVzaW5nIGZhbGxiYWNrIHR5cGUgXCJkZWZhdWx0XCIuYCxcbiAgICBlcnJvcjAxMjogKGlkKSA9PiBgTm9kZSB3aXRoIGlkIFwiJHtpZH1cIiBkb2VzIG5vdCBleGlzdCwgaXQgbWF5IGhhdmUgYmVlbiByZW1vdmVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIG5vZGUgaXMgZGVsZXRlZCBiZWZvcmUgdGhlIFwib25Ob2RlQ2xpY2tcIiBoYW5kbGVyIGlzIGNhbGxlZC5gLFxufTtcblxuY29uc3QgenVzdGFuZEVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAxJ10oKTtcbmZ1bmN0aW9uIHVzZVN0b3JlKHNlbGVjdG9yLCBlcXVhbGl0eUZuKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKHN0b3JlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih6dXN0YW5kRXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4oc3RvcmUsIHNlbGVjdG9yLCBlcXVhbGl0eUZuKTtcbn1cbmNvbnN0IHVzZVN0b3JlQXBpID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlQ29udGV4dChTdG9yZUNvbnRleHQpO1xuICAgIGlmIChzdG9yZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoenVzdGFuZEVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgICAgc2V0U3RhdGU6IHN0b3JlLnNldFN0YXRlLFxuICAgICAgICBzdWJzY3JpYmU6IHN0b3JlLnN1YnNjcmliZSxcbiAgICAgICAgZGVzdHJveTogc3RvcmUuZGVzdHJveSxcbiAgICB9KSwgW3N0b3JlXSk7XG59O1xuXG5jb25zdCBzZWxlY3RvciRnID0gKHMpID0+IChzLnVzZXJTZWxlY3Rpb25BY3RpdmUgPyAnbm9uZScgOiAnYWxsJyk7XG5mdW5jdGlvbiBQYW5lbCh7IHBvc2l0aW9uLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBzdHlsZSwgLi4ucmVzdCB9KSB7XG4gICAgY29uc3QgcG9pbnRlckV2ZW50cyA9IHVzZVN0b3JlKHNlbGVjdG9yJGcpO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2xhc3NlcyA9IGAke3Bvc2l0aW9ufWAuc3BsaXQoJy0nKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fcGFuZWwnLCBjbGFzc05hbWUsIC4uLnBvc2l0aW9uQ2xhc3Nlc10pLCBzdHlsZTogeyAuLi5zdHlsZSwgcG9pbnRlckV2ZW50cyB9LCAuLi5yZXN0IH0sIGNoaWxkcmVuKSk7XG59XG5cbmZ1bmN0aW9uIEF0dHJpYnV0aW9uKHsgcHJvT3B0aW9ucywgcG9zaXRpb24gPSAnYm90dG9tLXJpZ2h0JyB9KSB7XG4gICAgaWYgKHByb09wdGlvbnM/LmhpZGVBdHRyaWJ1dGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFBhbmVsLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2F0dHJpYnV0aW9uXCIsIFwiZGF0YS1tZXNzYWdlXCI6IFwiUGxlYXNlIG9ubHkgaGlkZSB0aGlzIGF0dHJpYnV0aW9uIHdoZW4geW91IGFyZSBzdWJzY3JpYmVkIHRvIFJlYWN0IEZsb3cgUHJvOiBodHRwczovL3JlYWN0Zmxvdy5kZXYvcHJvXCIgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwgeyBocmVmOiBcImh0dHBzOi8vcmVhY3RmbG93LmRldlwiLCB0YXJnZXQ6IFwiX2JsYW5rXCIsIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCIsIFwiYXJpYS1sYWJlbFwiOiBcIlJlYWN0IEZsb3cgYXR0cmlidXRpb25cIiB9LCBcIlJlYWN0IEZsb3dcIikpKTtcbn1cblxuY29uc3QgRWRnZVRleHQgPSAoeyB4LCB5LCBsYWJlbCwgbGFiZWxTdHlsZSA9IHt9LCBsYWJlbFNob3dCZyA9IHRydWUsIGxhYmVsQmdTdHlsZSA9IHt9LCBsYWJlbEJnUGFkZGluZyA9IFsyLCA0XSwgbGFiZWxCZ0JvcmRlclJhZGl1cyA9IDIsIGNoaWxkcmVuLCBjbGFzc05hbWUsIC4uLnJlc3QgfSkgPT4ge1xuICAgIGNvbnN0IGVkZ2VSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgW2VkZ2VUZXh0QmJveCwgc2V0RWRnZVRleHRCYm94XSA9IHVzZVN0YXRlKHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcbiAgICBjb25zdCBlZGdlVGV4dENsYXNzZXMgPSBjYyhbJ3JlYWN0LWZsb3dfX2VkZ2UtdGV4dHdyYXBwZXInLCBjbGFzc05hbWVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZWRnZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0QmJveCA9IGVkZ2VSZWYuY3VycmVudC5nZXRCQm94KCk7XG4gICAgICAgICAgICBzZXRFZGdlVGV4dEJib3goe1xuICAgICAgICAgICAgICAgIHg6IHRleHRCYm94LngsXG4gICAgICAgICAgICAgICAgeTogdGV4dEJib3gueSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGV4dEJib3gud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0ZXh0QmJveC5oZWlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtsYWJlbF0pO1xuICAgIGlmICh0eXBlb2YgbGFiZWwgPT09ICd1bmRlZmluZWQnIHx8ICFsYWJlbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke3ggLSBlZGdlVGV4dEJib3gud2lkdGggLyAyfSAke3kgLSBlZGdlVGV4dEJib3guaGVpZ2h0IC8gMn0pYCwgY2xhc3NOYW1lOiBlZGdlVGV4dENsYXNzZXMsIHZpc2liaWxpdHk6IGVkZ2VUZXh0QmJveC53aWR0aCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nLCAuLi5yZXN0IH0sXG4gICAgICAgIGxhYmVsU2hvd0JnICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7IHdpZHRoOiBlZGdlVGV4dEJib3gud2lkdGggKyAyICogbGFiZWxCZ1BhZGRpbmdbMF0sIHg6IC1sYWJlbEJnUGFkZGluZ1swXSwgeTogLWxhYmVsQmdQYWRkaW5nWzFdLCBoZWlnaHQ6IGVkZ2VUZXh0QmJveC5oZWlnaHQgKyAyICogbGFiZWxCZ1BhZGRpbmdbMV0sIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLXRleHRiZ1wiLCBzdHlsZTogbGFiZWxCZ1N0eWxlLCByeDogbGFiZWxCZ0JvcmRlclJhZGl1cywgcnk6IGxhYmVsQmdCb3JkZXJSYWRpdXMgfSkpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGV4dFwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLXRleHRcIiwgeTogZWRnZVRleHRCYm94LmhlaWdodCAvIDIsIGR5OiBcIjAuM2VtXCIsIHJlZjogZWRnZVJlZiwgc3R5bGU6IGxhYmVsU3R5bGUgfSwgbGFiZWwpLFxuICAgICAgICBjaGlsZHJlbikpO1xufTtcbnZhciBFZGdlVGV4dCQxID0gbWVtbyhFZGdlVGV4dCk7XG5cbmNvbnN0IGdldERpbWVuc2lvbnMgPSAobm9kZSkgPT4gKHtcbiAgICB3aWR0aDogbm9kZS5vZmZzZXRXaWR0aCxcbiAgICBoZWlnaHQ6IG5vZGUub2Zmc2V0SGVpZ2h0LFxufSk7XG5jb25zdCBjbGFtcCA9ICh2YWwsIG1pbiA9IDAsIG1heCA9IDEpID0+IE1hdGgubWluKE1hdGgubWF4KHZhbCwgbWluKSwgbWF4KTtcbmNvbnN0IGNsYW1wUG9zaXRpb24gPSAocG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfSwgZXh0ZW50KSA9PiAoe1xuICAgIHg6IGNsYW1wKHBvc2l0aW9uLngsIGV4dGVudFswXVswXSwgZXh0ZW50WzFdWzBdKSxcbiAgICB5OiBjbGFtcChwb3NpdGlvbi55LCBleHRlbnRbMF1bMV0sIGV4dGVudFsxXVsxXSksXG59KTtcbi8vIHJldHVybnMgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIHRoYXQgcmVwcmVzZW50cyB0aGUgdmVsb2NpdHkgb2YgdGhlIG1vdmVtZW50XG4vLyB3aGVuIHRoZSBtb3VzZSBpcyBjbG9zZSB0byB0aGUgZWRnZSBvZiB0aGUgY2FudmFzXG5jb25zdCBjYWxjQXV0b1BhblZlbG9jaXR5ID0gKHZhbHVlLCBtaW4sIG1heCkgPT4ge1xuICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICByZXR1cm4gY2xhbXAoTWF0aC5hYnModmFsdWUgLSBtaW4pLCAxLCA1MCkgLyA1MDtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgcmV0dXJuIC1jbGFtcChNYXRoLmFicyh2YWx1ZSAtIG1heCksIDEsIDUwKSAvIDUwO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5jb25zdCBjYWxjQXV0b1BhbiA9IChwb3MsIGJvdW5kcykgPT4ge1xuICAgIGNvbnN0IHhNb3ZlbWVudCA9IGNhbGNBdXRvUGFuVmVsb2NpdHkocG9zLngsIDM1LCBib3VuZHMud2lkdGggLSAzNSkgKiAyMDtcbiAgICBjb25zdCB5TW92ZW1lbnQgPSBjYWxjQXV0b1BhblZlbG9jaXR5KHBvcy55LCAzNSwgYm91bmRzLmhlaWdodCAtIDM1KSAqIDIwO1xuICAgIHJldHVybiBbeE1vdmVtZW50LCB5TW92ZW1lbnRdO1xufTtcbmNvbnN0IGdldEhvc3RGb3JFbGVtZW50ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0Um9vdE5vZGU/LigpIHx8IHdpbmRvdz8uZG9jdW1lbnQ7XG5jb25zdCBnZXRCb3VuZHNPZkJveGVzID0gKGJveDEsIGJveDIpID0+ICh7XG4gICAgeDogTWF0aC5taW4oYm94MS54LCBib3gyLngpLFxuICAgIHk6IE1hdGgubWluKGJveDEueSwgYm94Mi55KSxcbiAgICB4MjogTWF0aC5tYXgoYm94MS54MiwgYm94Mi54MiksXG4gICAgeTI6IE1hdGgubWF4KGJveDEueTIsIGJveDIueTIpLFxufSk7XG5jb25zdCByZWN0VG9Cb3ggPSAoeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0pID0+ICh7XG4gICAgeCxcbiAgICB5LFxuICAgIHgyOiB4ICsgd2lkdGgsXG4gICAgeTI6IHkgKyBoZWlnaHQsXG59KTtcbmNvbnN0IGJveFRvUmVjdCA9ICh7IHgsIHksIHgyLCB5MiB9KSA9PiAoe1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aDogeDIgLSB4LFxuICAgIGhlaWdodDogeTIgLSB5LFxufSk7XG5jb25zdCBub2RlVG9SZWN0ID0gKG5vZGUpID0+ICh7XG4gICAgLi4uKG5vZGUucG9zaXRpb25BYnNvbHV0ZSB8fCB7IHg6IDAsIHk6IDAgfSksXG4gICAgd2lkdGg6IG5vZGUud2lkdGggfHwgMCxcbiAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0IHx8IDAsXG59KTtcbmNvbnN0IGdldEJvdW5kc09mUmVjdHMgPSAocmVjdDEsIHJlY3QyKSA9PiBib3hUb1JlY3QoZ2V0Qm91bmRzT2ZCb3hlcyhyZWN0VG9Cb3gocmVjdDEpLCByZWN0VG9Cb3gocmVjdDIpKSk7XG5jb25zdCBnZXRPdmVybGFwcGluZ0FyZWEgPSAocmVjdEEsIHJlY3RCKSA9PiB7XG4gICAgY29uc3QgeE92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWN0QS54ICsgcmVjdEEud2lkdGgsIHJlY3RCLnggKyByZWN0Qi53aWR0aCkgLSBNYXRoLm1heChyZWN0QS54LCByZWN0Qi54KSk7XG4gICAgY29uc3QgeU92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWN0QS55ICsgcmVjdEEuaGVpZ2h0LCByZWN0Qi55ICsgcmVjdEIuaGVpZ2h0KSAtIE1hdGgubWF4KHJlY3RBLnksIHJlY3RCLnkpKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHhPdmVybGFwICogeU92ZXJsYXApO1xufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBpc1JlY3RPYmplY3QgPSAob2JqKSA9PiBpc051bWVyaWMob2JqLndpZHRoKSAmJiBpc051bWVyaWMob2JqLmhlaWdodCkgJiYgaXNOdW1lcmljKG9iai54KSAmJiBpc051bWVyaWMob2JqLnkpO1xuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IGlzTnVtZXJpYyA9IChuKSA9PiAhaXNOYU4obikgJiYgaXNGaW5pdGUobik7XG5jb25zdCBpbnRlcm5hbHNTeW1ib2wgPSBTeW1ib2wuZm9yKCdpbnRlcm5hbHMnKTtcbi8vIHVzZWQgZm9yIGExMXkga2V5IGJvYXJkIGNvbnRyb2xzIGZvciBub2RlcyBhbmQgZWRnZXNcbmNvbnN0IGVsZW1lbnRTZWxlY3Rpb25LZXlzID0gWydFbnRlcicsICcgJywgJ0VzY2FwZSddO1xuY29uc3QgZGV2V2FybiA9IChpZCwgbWVzc2FnZSkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oYFtSZWFjdCBGbG93XTogJHttZXNzYWdlfSBIZWxwOiBodHRwczovL3JlYWN0Zmxvdy5kZXYvZXJyb3IjJHtpZH1gKTtcbiAgICB9XG59O1xuY29uc3QgaXNSZWFjdEtleWJvYXJkRXZlbnQgPSAoZXZlbnQpID0+ICduYXRpdmVFdmVudCcgaW4gZXZlbnQ7XG5mdW5jdGlvbiBpc0lucHV0RE9NTm9kZShldmVudCkge1xuICAgIGNvbnN0IGtiRXZlbnQgPSBpc1JlYWN0S2V5Ym9hcmRFdmVudChldmVudCkgPyBldmVudC5uYXRpdmVFdmVudCA6IGV2ZW50O1xuICAgIC8vIHVzaW5nIGNvbXBvc2VkIHBhdGggZm9yIGhhbmRsaW5nIHNoYWRvdyBkb21cbiAgICBjb25zdCB0YXJnZXQgPSAoa2JFdmVudC5jb21wb3NlZFBhdGg/LigpPy5bMF0gfHwgZXZlbnQudGFyZ2V0KTtcbiAgICBjb25zdCBpc0lucHV0ID0gWydJTlBVVCcsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXS5pbmNsdWRlcyh0YXJnZXQ/Lm5vZGVOYW1lKSB8fCB0YXJnZXQ/Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG4gICAgLy8gd2hlbiBhbiBpbnB1dCBmaWVsZCBpcyBmb2N1c2VkIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBkZWxldGlvbiBvciBtb3ZlbWVudCBvZiBub2Rlc1xuICAgIHJldHVybiBpc0lucHV0IHx8ICEhdGFyZ2V0Py5jbG9zZXN0KCcubm9rZXknKTtcbn1cbmNvbnN0IGlzTW91c2VFdmVudCA9IChldmVudCkgPT4gJ2NsaWVudFgnIGluIGV2ZW50O1xuY29uc3QgZ2V0RXZlbnRQb3NpdGlvbiA9IChldmVudCwgYm91bmRzKSA9PiB7XG4gICAgY29uc3QgaXNNb3VzZVRyaWdnZXJlZCA9IGlzTW91c2VFdmVudChldmVudCk7XG4gICAgY29uc3QgZXZ0WCA9IGlzTW91c2VUcmlnZ2VyZWQgPyBldmVudC5jbGllbnRYIDogZXZlbnQudG91Y2hlcz8uWzBdLmNsaWVudFg7XG4gICAgY29uc3QgZXZ0WSA9IGlzTW91c2VUcmlnZ2VyZWQgPyBldmVudC5jbGllbnRZIDogZXZlbnQudG91Y2hlcz8uWzBdLmNsaWVudFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZ0WCAtIChib3VuZHM/LmxlZnQgPz8gMCksXG4gICAgICAgIHk6IGV2dFkgLSAoYm91bmRzPy50b3AgPz8gMCksXG4gICAgfTtcbn07XG5jb25zdCBpc01hY09zID0gKCkgPT4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yPy51c2VyQWdlbnQ/LmluZGV4T2YoJ01hYycpID49IDA7XG5cbmNvbnN0IEJhc2VFZGdlID0gKHsgaWQsIHBhdGgsIGxhYmVsWCwgbGFiZWxZLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoID0gMjAsIH0pID0+IHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgaWQ6IGlkLCBzdHlsZTogc3R5bGUsIGQ6IHBhdGgsIGZpbGw6IFwibm9uZVwiLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZS1wYXRoXCIsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQgfSksXG4gICAgICAgIGludGVyYWN0aW9uV2lkdGggJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogcGF0aCwgZmlsbDogXCJub25lXCIsIHN0cm9rZU9wYWNpdHk6IDAsIHN0cm9rZVdpZHRoOiBpbnRlcmFjdGlvbldpZHRoLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZS1pbnRlcmFjdGlvblwiIH0pKSxcbiAgICAgICAgbGFiZWwgJiYgaXNOdW1lcmljKGxhYmVsWCkgJiYgaXNOdW1lcmljKGxhYmVsWSkgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChFZGdlVGV4dCQxLCB7IHg6IGxhYmVsWCwgeTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cyB9KSkgOiBudWxsKSk7XG59O1xuQmFzZUVkZ2UuZGlzcGxheU5hbWUgPSAnQmFzZUVkZ2UnO1xuXG5jb25zdCBnZXRNYXJrZXJFbmQgPSAobWFya2VyVHlwZSwgbWFya2VyRW5kSWQpID0+IHtcbiAgICBpZiAodHlwZW9mIG1hcmtlckVuZElkICE9PSAndW5kZWZpbmVkJyAmJiBtYXJrZXJFbmRJZCkge1xuICAgICAgICByZXR1cm4gYHVybCgjJHttYXJrZXJFbmRJZH0pYDtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBtYXJrZXJUeXBlICE9PSAndW5kZWZpbmVkJyA/IGB1cmwoI3JlYWN0LWZsb3dfXyR7bWFya2VyVHlwZX0pYCA6ICdub25lJztcbn07XG5mdW5jdGlvbiBnZXRNb3VzZUhhbmRsZXIkMShpZCwgZ2V0U3RhdGUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gaGFuZGxlciA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gaGFuZGxlclxuICAgICAgICA6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWRnZSA9IGdldFN0YXRlKCkuZWRnZXMuZmluZCgoZSkgPT4gZS5pZCA9PT0gaWQpO1xuICAgICAgICAgICAgaWYgKGVkZ2UpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG59XG4vLyB0aGlzIGlzIHVzZWQgZm9yIHN0cmFpZ2h0IGVkZ2VzIGFuZCBzaW1wbGUgc21vb3Roc3RlcCBlZGdlcyAoTFRSLCBSVEwsIEJUVCwgVFRCKVxuZnVuY3Rpb24gZ2V0RWRnZUNlbnRlcih7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIH0pIHtcbiAgICBjb25zdCB4T2Zmc2V0ID0gTWF0aC5hYnModGFyZ2V0WCAtIHNvdXJjZVgpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJYID0gdGFyZ2V0WCA8IHNvdXJjZVggPyB0YXJnZXRYICsgeE9mZnNldCA6IHRhcmdldFggLSB4T2Zmc2V0O1xuICAgIGNvbnN0IHlPZmZzZXQgPSBNYXRoLmFicyh0YXJnZXRZIC0gc291cmNlWSkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSB0YXJnZXRZIDwgc291cmNlWSA/IHRhcmdldFkgKyB5T2Zmc2V0IDogdGFyZ2V0WSAtIHlPZmZzZXQ7XG4gICAgcmV0dXJuIFtjZW50ZXJYLCBjZW50ZXJZLCB4T2Zmc2V0LCB5T2Zmc2V0XTtcbn1cbmZ1bmN0aW9uIGdldEJlemllckVkZ2VDZW50ZXIoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VDb250cm9sWCwgc291cmNlQ29udHJvbFksIHRhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWSwgfSkge1xuICAgIC8vIGN1YmljIGJlemllciB0PTAuNSBtaWQgcG9pbnQsIG5vdCB0aGUgYWN0dWFsIG1pZCBwb2ludCwgYnV0IGVhc3kgdG8gY2FsY3VsYXRlXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjc1MTYxMDEvaG93LXRvLWZpbmQtZGlzdGFuY2UtbWlkLXBvaW50LW9mLWJlemllci1jdXJ2ZVxuICAgIGNvbnN0IGNlbnRlclggPSBzb3VyY2VYICogMC4xMjUgKyBzb3VyY2VDb250cm9sWCAqIDAuMzc1ICsgdGFyZ2V0Q29udHJvbFggKiAwLjM3NSArIHRhcmdldFggKiAwLjEyNTtcbiAgICBjb25zdCBjZW50ZXJZID0gc291cmNlWSAqIDAuMTI1ICsgc291cmNlQ29udHJvbFkgKiAwLjM3NSArIHRhcmdldENvbnRyb2xZICogMC4zNzUgKyB0YXJnZXRZICogMC4xMjU7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGguYWJzKGNlbnRlclggLSBzb3VyY2VYKTtcbiAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5hYnMoY2VudGVyWSAtIHNvdXJjZVkpO1xuICAgIHJldHVybiBbY2VudGVyWCwgY2VudGVyWSwgb2Zmc2V0WCwgb2Zmc2V0WV07XG59XG5cbnZhciBDb25uZWN0aW9uTW9kZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvbk1vZGUpIHtcbiAgICBDb25uZWN0aW9uTW9kZVtcIlN0cmljdFwiXSA9IFwic3RyaWN0XCI7XG4gICAgQ29ubmVjdGlvbk1vZGVbXCJMb29zZVwiXSA9IFwibG9vc2VcIjtcbn0pKENvbm5lY3Rpb25Nb2RlIHx8IChDb25uZWN0aW9uTW9kZSA9IHt9KSk7XG52YXIgUGFuT25TY3JvbGxNb2RlO1xuKGZ1bmN0aW9uIChQYW5PblNjcm9sbE1vZGUpIHtcbiAgICBQYW5PblNjcm9sbE1vZGVbXCJGcmVlXCJdID0gXCJmcmVlXCI7XG4gICAgUGFuT25TY3JvbGxNb2RlW1wiVmVydGljYWxcIl0gPSBcInZlcnRpY2FsXCI7XG4gICAgUGFuT25TY3JvbGxNb2RlW1wiSG9yaXpvbnRhbFwiXSA9IFwiaG9yaXpvbnRhbFwiO1xufSkoUGFuT25TY3JvbGxNb2RlIHx8IChQYW5PblNjcm9sbE1vZGUgPSB7fSkpO1xudmFyIFNlbGVjdGlvbk1vZGU7XG4oZnVuY3Rpb24gKFNlbGVjdGlvbk1vZGUpIHtcbiAgICBTZWxlY3Rpb25Nb2RlW1wiUGFydGlhbFwiXSA9IFwicGFydGlhbFwiO1xuICAgIFNlbGVjdGlvbk1vZGVbXCJGdWxsXCJdID0gXCJmdWxsXCI7XG59KShTZWxlY3Rpb25Nb2RlIHx8IChTZWxlY3Rpb25Nb2RlID0ge30pKTtcblxudmFyIENvbm5lY3Rpb25MaW5lVHlwZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvbkxpbmVUeXBlKSB7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiQmV6aWVyXCJdID0gXCJkZWZhdWx0XCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU3RyYWlnaHRcIl0gPSBcInN0cmFpZ2h0XCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU3RlcFwiXSA9IFwic3RlcFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlNtb290aFN0ZXBcIl0gPSBcInNtb290aHN0ZXBcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTaW1wbGVCZXppZXJcIl0gPSBcInNpbXBsZWJlemllclwiO1xufSkoQ29ubmVjdGlvbkxpbmVUeXBlIHx8IChDb25uZWN0aW9uTGluZVR5cGUgPSB7fSkpO1xudmFyIE1hcmtlclR5cGU7XG4oZnVuY3Rpb24gKE1hcmtlclR5cGUpIHtcbiAgICBNYXJrZXJUeXBlW1wiQXJyb3dcIl0gPSBcImFycm93XCI7XG4gICAgTWFya2VyVHlwZVtcIkFycm93Q2xvc2VkXCJdID0gXCJhcnJvd2Nsb3NlZFwiO1xufSkoTWFya2VyVHlwZSB8fCAoTWFya2VyVHlwZSA9IHt9KSk7XG5cbnZhciBQb3NpdGlvbjtcbihmdW5jdGlvbiAoUG9zaXRpb24pIHtcbiAgICBQb3NpdGlvbltcIkxlZnRcIl0gPSBcImxlZnRcIjtcbiAgICBQb3NpdGlvbltcIlRvcFwiXSA9IFwidG9wXCI7XG4gICAgUG9zaXRpb25bXCJSaWdodFwiXSA9IFwicmlnaHRcIjtcbiAgICBQb3NpdGlvbltcIkJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG59KShQb3NpdGlvbiB8fCAoUG9zaXRpb24gPSB7fSkpO1xuXG5mdW5jdGlvbiBnZXRDb250cm9sKHsgcG9zLCB4MSwgeTEsIHgyLCB5MiB9KSB7XG4gICAgaWYgKHBvcyA9PT0gUG9zaXRpb24uTGVmdCB8fCBwb3MgPT09IFBvc2l0aW9uLlJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBbMC41ICogKHgxICsgeDIpLCB5MV07XG4gICAgfVxuICAgIHJldHVybiBbeDEsIDAuNSAqICh5MSArIHkyKV07XG59XG5mdW5jdGlvbiBnZXRTaW1wbGVCZXppZXJQYXRoKHsgc291cmNlWCwgc291cmNlWSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFgsIHRhcmdldFksIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCB9KSB7XG4gICAgY29uc3QgW3NvdXJjZUNvbnRyb2xYLCBzb3VyY2VDb250cm9sWV0gPSBnZXRDb250cm9sKHtcbiAgICAgICAgcG9zOiBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgeDE6IHNvdXJjZVgsXG4gICAgICAgIHkxOiBzb3VyY2VZLFxuICAgICAgICB4MjogdGFyZ2V0WCxcbiAgICAgICAgeTI6IHRhcmdldFksXG4gICAgfSk7XG4gICAgY29uc3QgW3RhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWV0gPSBnZXRDb250cm9sKHtcbiAgICAgICAgcG9zOiB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgeDE6IHRhcmdldFgsXG4gICAgICAgIHkxOiB0YXJnZXRZLFxuICAgICAgICB4Mjogc291cmNlWCxcbiAgICAgICAgeTI6IHNvdXJjZVksXG4gICAgfSk7XG4gICAgY29uc3QgW2xhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldEJlemllckVkZ2VDZW50ZXIoe1xuICAgICAgICBzb3VyY2VYLFxuICAgICAgICBzb3VyY2VZLFxuICAgICAgICB0YXJnZXRYLFxuICAgICAgICB0YXJnZXRZLFxuICAgICAgICBzb3VyY2VDb250cm9sWCxcbiAgICAgICAgc291cmNlQ29udHJvbFksXG4gICAgICAgIHRhcmdldENvbnRyb2xYLFxuICAgICAgICB0YXJnZXRDb250cm9sWSxcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBgTSR7c291cmNlWH0sJHtzb3VyY2VZfSBDJHtzb3VyY2VDb250cm9sWH0sJHtzb3VyY2VDb250cm9sWX0gJHt0YXJnZXRDb250cm9sWH0sJHt0YXJnZXRDb250cm9sWX0gJHt0YXJnZXRYfSwke3RhcmdldFl9YCxcbiAgICAgICAgbGFiZWxYLFxuICAgICAgICBsYWJlbFksXG4gICAgICAgIG9mZnNldFgsXG4gICAgICAgIG9mZnNldFksXG4gICAgXTtcbn1cbmNvbnN0IFNpbXBsZUJlemllckVkZ2UgPSBtZW1vKCh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRTaW1wbGVCZXppZXJQYXRoKHtcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgIH0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChCYXNlRWRnZSwgeyBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xufSk7XG5TaW1wbGVCZXppZXJFZGdlLmRpc3BsYXlOYW1lID0gJ1NpbXBsZUJlemllckVkZ2UnO1xuXG5jb25zdCBoYW5kbGVEaXJlY3Rpb25zID0ge1xuICAgIFtQb3NpdGlvbi5MZWZ0XTogeyB4OiAtMSwgeTogMCB9LFxuICAgIFtQb3NpdGlvbi5SaWdodF06IHsgeDogMSwgeTogMCB9LFxuICAgIFtQb3NpdGlvbi5Ub3BdOiB7IHg6IDAsIHk6IC0xIH0sXG4gICAgW1Bvc2l0aW9uLkJvdHRvbV06IHsgeDogMCwgeTogMSB9LFxufTtcbmNvbnN0IGdldERpcmVjdGlvbiA9ICh7IHNvdXJjZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldCwgfSkgPT4ge1xuICAgIGlmIChzb3VyY2VQb3NpdGlvbiA9PT0gUG9zaXRpb24uTGVmdCB8fCBzb3VyY2VQb3NpdGlvbiA9PT0gUG9zaXRpb24uUmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS54IDwgdGFyZ2V0LnggPyB7IHg6IDEsIHk6IDAgfSA6IHsgeDogLTEsIHk6IDAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZS55IDwgdGFyZ2V0LnkgPyB7IHg6IDAsIHk6IDEgfSA6IHsgeDogMCwgeTogLTEgfTtcbn07XG5jb25zdCBkaXN0YW5jZSA9IChhLCBiKSA9PiBNYXRoLnNxcnQoTWF0aC5wb3coYi54IC0gYS54LCAyKSArIE1hdGgucG93KGIueSAtIGEueSwgMikpO1xuLy8gaXRoIHRoaXMgZnVuY3Rpb24gd2UgdHJ5IHRvIG1pbWljIGEgb3J0aG9nb25hbCBlZGdlIHJvdXRpbmcgYmVoYXZpb3VyXG4vLyBJdCdzIG5vdCBhcyBnb29kIGFzIGEgcmVhbCBvcnRob2dvbmFsIGVkZ2Ugcm91dGluZyBidXQgaXQncyBmYXN0ZXIgYW5kIGdvb2QgZW5vdWdoIGFzIGEgZGVmYXVsdCBmb3Igc3RlcCBhbmQgc21vb3RoIHN0ZXAgZWRnZXNcbmZ1bmN0aW9uIGdldFBvaW50cyh7IHNvdXJjZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldCwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGNlbnRlciwgb2Zmc2V0LCB9KSB7XG4gICAgY29uc3Qgc291cmNlRGlyID0gaGFuZGxlRGlyZWN0aW9uc1tzb3VyY2VQb3NpdGlvbl07XG4gICAgY29uc3QgdGFyZ2V0RGlyID0gaGFuZGxlRGlyZWN0aW9uc1t0YXJnZXRQb3NpdGlvbl07XG4gICAgY29uc3Qgc291cmNlR2FwcGVkID0geyB4OiBzb3VyY2UueCArIHNvdXJjZURpci54ICogb2Zmc2V0LCB5OiBzb3VyY2UueSArIHNvdXJjZURpci55ICogb2Zmc2V0IH07XG4gICAgY29uc3QgdGFyZ2V0R2FwcGVkID0geyB4OiB0YXJnZXQueCArIHRhcmdldERpci54ICogb2Zmc2V0LCB5OiB0YXJnZXQueSArIHRhcmdldERpci55ICogb2Zmc2V0IH07XG4gICAgY29uc3QgZGlyID0gZ2V0RGlyZWN0aW9uKHtcbiAgICAgICAgc291cmNlOiBzb3VyY2VHYXBwZWQsXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldEdhcHBlZCxcbiAgICB9KTtcbiAgICBjb25zdCBkaXJBY2Nlc3NvciA9IGRpci54ICE9PSAwID8gJ3gnIDogJ3knO1xuICAgIGNvbnN0IGN1cnJEaXIgPSBkaXJbZGlyQWNjZXNzb3JdO1xuICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICBsZXQgY2VudGVyWCwgY2VudGVyWTtcbiAgICBjb25zdCBzb3VyY2VHYXBPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCB0YXJnZXRHYXBPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCBbZGVmYXVsdENlbnRlclgsIGRlZmF1bHRDZW50ZXJZLCBkZWZhdWx0T2Zmc2V0WCwgZGVmYXVsdE9mZnNldFldID0gZ2V0RWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVg6IHNvdXJjZS54LFxuICAgICAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAgICAgICAgdGFyZ2V0WDogdGFyZ2V0LngsXG4gICAgICAgIHRhcmdldFk6IHRhcmdldC55LFxuICAgIH0pO1xuICAgIC8vIG9wcG9zaXRlIGhhbmRsZSBwb3NpdGlvbnMsIGRlZmF1bHQgY2FzZVxuICAgIGlmIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdICogdGFyZ2V0RGlyW2RpckFjY2Vzc29yXSA9PT0gLTEpIHtcbiAgICAgICAgY2VudGVyWCA9IGNlbnRlci54IHx8IGRlZmF1bHRDZW50ZXJYO1xuICAgICAgICBjZW50ZXJZID0gY2VudGVyLnkgfHwgZGVmYXVsdENlbnRlclk7XG4gICAgICAgIC8vICAgIC0tLT5cbiAgICAgICAgLy8gICAgfFxuICAgICAgICAvLyA+LS0tXG4gICAgICAgIGNvbnN0IHZlcnRpY2FsU3BsaXQgPSBbXG4gICAgICAgICAgICB7IHg6IGNlbnRlclgsIHk6IHNvdXJjZUdhcHBlZC55IH0sXG4gICAgICAgICAgICB7IHg6IGNlbnRlclgsIHk6IHRhcmdldEdhcHBlZC55IH0sXG4gICAgICAgIF07XG4gICAgICAgIC8vICAgIHxcbiAgICAgICAgLy8gIC0tLVxuICAgICAgICAvLyAgfFxuICAgICAgICBjb25zdCBob3Jpem9udGFsU3BsaXQgPSBbXG4gICAgICAgICAgICB7IHg6IHNvdXJjZUdhcHBlZC54LCB5OiBjZW50ZXJZIH0sXG4gICAgICAgICAgICB7IHg6IHRhcmdldEdhcHBlZC54LCB5OiBjZW50ZXJZIH0sXG4gICAgICAgIF07XG4gICAgICAgIGlmIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSBjdXJyRGlyKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBkaXJBY2Nlc3NvciA9PT0gJ3gnID8gdmVydGljYWxTcGxpdCA6IGhvcml6b250YWxTcGxpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50cyA9IGRpckFjY2Vzc29yID09PSAneCcgPyBob3Jpem9udGFsU3BsaXQgOiB2ZXJ0aWNhbFNwbGl0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBzb3VyY2VUYXJnZXQgbWVhbnMgd2UgdGFrZSB4IGZyb20gc291cmNlIGFuZCB5IGZyb20gdGFyZ2V0LCB0YXJnZXRTb3VyY2UgaXMgdGhlIG9wcG9zaXRlXG4gICAgICAgIGNvbnN0IHNvdXJjZVRhcmdldCA9IFt7IHg6IHNvdXJjZUdhcHBlZC54LCB5OiB0YXJnZXRHYXBwZWQueSB9XTtcbiAgICAgICAgY29uc3QgdGFyZ2V0U291cmNlID0gW3sgeDogdGFyZ2V0R2FwcGVkLngsIHk6IHNvdXJjZUdhcHBlZC55IH1dO1xuICAgICAgICAvLyB0aGlzIGhhbmRsZXMgZWRnZXMgd2l0aCBzYW1lIGhhbmRsZSBwb3NpdGlvbnNcbiAgICAgICAgaWYgKGRpckFjY2Vzc29yID09PSAneCcpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IHNvdXJjZURpci54ID09PSBjdXJyRGlyID8gdGFyZ2V0U291cmNlIDogc291cmNlVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzID0gc291cmNlRGlyLnkgPT09IGN1cnJEaXIgPyBzb3VyY2VUYXJnZXQgOiB0YXJnZXRTb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVBvc2l0aW9uID09PSB0YXJnZXRQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKHNvdXJjZVtkaXJBY2Nlc3Nvcl0gLSB0YXJnZXRbZGlyQWNjZXNzb3JdKTtcbiAgICAgICAgICAgIC8vIGlmIGFuIGVkZ2UgZ29lcyBmcm9tIHJpZ2h0IHRvIHJpZ2h0IGZvciBleGFtcGxlIChzb3VyY2VQb3NpdGlvbiA9PT0gdGFyZ2V0UG9zaXRpb24pIGFuZCB0aGUgZGlzdGFuY2UgYmV0d2VlbiBzb3VyY2UueCBhbmQgdGFyZ2V0LnggaXMgbGVzcyB0aGFuIHRoZSBvZmZzZXQsIHRoZSBhZGRlZCBwb2ludCBhbmQgdGhlIGdhcHBlZCBzb3VyY2UvdGFyZ2V0IHdpbGwgb3ZlcmxhcC4gVGhpcyBsZWFkcyB0byBhIHdlaXJkIGVkZ2UgcGF0aC4gVG8gYXZvaWQgdGhpcyB3ZSBhZGQgYSBnYXBPZmZzZXQgdG8gdGhlIHNvdXJjZS90YXJnZXRcbiAgICAgICAgICAgIGlmIChkaWZmIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhcE9mZnNldCA9IE1hdGgubWluKG9mZnNldCAtIDEsIG9mZnNldCAtIGRpZmYpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSBjdXJyRGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUdhcE9mZnNldFtkaXJBY2Nlc3Nvcl0gPSAoc291cmNlR2FwcGVkW2RpckFjY2Vzc29yXSA+IHNvdXJjZVtkaXJBY2Nlc3Nvcl0gPyAtMSA6IDEpICogZ2FwT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0R2FwT2Zmc2V0W2RpckFjY2Vzc29yXSA9ICh0YXJnZXRHYXBwZWRbZGlyQWNjZXNzb3JdID4gdGFyZ2V0W2RpckFjY2Vzc29yXSA/IC0xIDogMSkgKiBnYXBPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZXNlIGFyZSBjb25kaXRpb25zIGZvciBoYW5kbGluZyBtaXhlZCBoYW5kbGUgcG9zaXRpb25zIGxpa2UgUmlnaHQgLT4gQm90dG9tIGZvciBleGFtcGxlXG4gICAgICAgIGlmIChzb3VyY2VQb3NpdGlvbiAhPT0gdGFyZ2V0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGRpckFjY2Vzc29yT3Bwb3NpdGUgPSBkaXJBY2Nlc3NvciA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICAgICAgICAgICAgY29uc3QgaXNTYW1lRGlyID0gc291cmNlRGlyW2RpckFjY2Vzc29yXSA9PT0gdGFyZ2V0RGlyW2RpckFjY2Vzc29yT3Bwb3NpdGVdO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlR3RUYXJnZXRPcHBvID0gc291cmNlR2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdID4gdGFyZ2V0R2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlTHRUYXJnZXRPcHBvID0gc291cmNlR2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdIDwgdGFyZ2V0R2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdO1xuICAgICAgICAgICAgY29uc3QgZmxpcFNvdXJjZVRhcmdldCA9IChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSAxICYmICgoIWlzU2FtZURpciAmJiBzb3VyY2VHdFRhcmdldE9wcG8pIHx8IChpc1NhbWVEaXIgJiYgc291cmNlTHRUYXJnZXRPcHBvKSkpIHx8XG4gICAgICAgICAgICAgICAgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gIT09IDEgJiYgKCghaXNTYW1lRGlyICYmIHNvdXJjZUx0VGFyZ2V0T3BwbykgfHwgKGlzU2FtZURpciAmJiBzb3VyY2VHdFRhcmdldE9wcG8pKSk7XG4gICAgICAgICAgICBpZiAoZmxpcFNvdXJjZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IGRpckFjY2Vzc29yID09PSAneCcgPyBzb3VyY2VUYXJnZXQgOiB0YXJnZXRTb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlR2FwUG9pbnQgPSB7IHg6IHNvdXJjZUdhcHBlZC54ICsgc291cmNlR2FwT2Zmc2V0LngsIHk6IHNvdXJjZUdhcHBlZC55ICsgc291cmNlR2FwT2Zmc2V0LnkgfTtcbiAgICAgICAgY29uc3QgdGFyZ2V0R2FwUG9pbnQgPSB7IHg6IHRhcmdldEdhcHBlZC54ICsgdGFyZ2V0R2FwT2Zmc2V0LngsIHk6IHRhcmdldEdhcHBlZC55ICsgdGFyZ2V0R2FwT2Zmc2V0LnkgfTtcbiAgICAgICAgY29uc3QgbWF4WERpc3RhbmNlID0gTWF0aC5tYXgoTWF0aC5hYnMoc291cmNlR2FwUG9pbnQueCAtIHBvaW50c1swXS54KSwgTWF0aC5hYnModGFyZ2V0R2FwUG9pbnQueCAtIHBvaW50c1swXS54KSk7XG4gICAgICAgIGNvbnN0IG1heFlEaXN0YW5jZSA9IE1hdGgubWF4KE1hdGguYWJzKHNvdXJjZUdhcFBvaW50LnkgLSBwb2ludHNbMF0ueSksIE1hdGguYWJzKHRhcmdldEdhcFBvaW50LnkgLSBwb2ludHNbMF0ueSkpO1xuICAgICAgICAvLyB3ZSB3YW50IHRvIHBsYWNlIHRoZSBsYWJlbCBvbiB0aGUgbG9uZ2VzdCBzZWdtZW50IG9mIHRoZSBlZGdlXG4gICAgICAgIGlmIChtYXhYRGlzdGFuY2UgPj0gbWF4WURpc3RhbmNlKSB7XG4gICAgICAgICAgICBjZW50ZXJYID0gKHNvdXJjZUdhcFBvaW50LnggKyB0YXJnZXRHYXBQb2ludC54KSAvIDI7XG4gICAgICAgICAgICBjZW50ZXJZID0gcG9pbnRzWzBdLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjZW50ZXJYID0gcG9pbnRzWzBdLng7XG4gICAgICAgICAgICBjZW50ZXJZID0gKHNvdXJjZUdhcFBvaW50LnkgKyB0YXJnZXRHYXBQb2ludC55KSAvIDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGF0aFBvaW50cyA9IFtcbiAgICAgICAgc291cmNlLFxuICAgICAgICB7IHg6IHNvdXJjZUdhcHBlZC54ICsgc291cmNlR2FwT2Zmc2V0LngsIHk6IHNvdXJjZUdhcHBlZC55ICsgc291cmNlR2FwT2Zmc2V0LnkgfSxcbiAgICAgICAgLi4ucG9pbnRzLFxuICAgICAgICB7IHg6IHRhcmdldEdhcHBlZC54ICsgdGFyZ2V0R2FwT2Zmc2V0LngsIHk6IHRhcmdldEdhcHBlZC55ICsgdGFyZ2V0R2FwT2Zmc2V0LnkgfSxcbiAgICAgICAgdGFyZ2V0LFxuICAgIF07XG4gICAgcmV0dXJuIFtwYXRoUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCBkZWZhdWx0T2Zmc2V0WCwgZGVmYXVsdE9mZnNldFldO1xufVxuZnVuY3Rpb24gZ2V0QmVuZChhLCBiLCBjLCBzaXplKSB7XG4gICAgY29uc3QgYmVuZFNpemUgPSBNYXRoLm1pbihkaXN0YW5jZShhLCBiKSAvIDIsIGRpc3RhbmNlKGIsIGMpIC8gMiwgc2l6ZSk7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBiO1xuICAgIC8vIG5vIGJlbmRcbiAgICBpZiAoKGEueCA9PT0geCAmJiB4ID09PSBjLngpIHx8IChhLnkgPT09IHkgJiYgeSA9PT0gYy55KSkge1xuICAgICAgICByZXR1cm4gYEwke3h9ICR7eX1gO1xuICAgIH1cbiAgICAvLyBmaXJzdCBzZWdtZW50IGlzIGhvcml6b250YWxcbiAgICBpZiAoYS55ID09PSB5KSB7XG4gICAgICAgIGNvbnN0IHhEaXIgPSBhLnggPCBjLnggPyAtMSA6IDE7XG4gICAgICAgIGNvbnN0IHlEaXIgPSBhLnkgPCBjLnkgPyAxIDogLTE7XG4gICAgICAgIHJldHVybiBgTCAke3ggKyBiZW5kU2l6ZSAqIHhEaXJ9LCR7eX1RICR7eH0sJHt5fSAke3h9LCR7eSArIGJlbmRTaXplICogeURpcn1gO1xuICAgIH1cbiAgICBjb25zdCB4RGlyID0gYS54IDwgYy54ID8gMSA6IC0xO1xuICAgIGNvbnN0IHlEaXIgPSBhLnkgPCBjLnkgPyAtMSA6IDE7XG4gICAgcmV0dXJuIGBMICR7eH0sJHt5ICsgYmVuZFNpemUgKiB5RGlyfVEgJHt4fSwke3l9ICR7eCArIGJlbmRTaXplICogeERpcn0sJHt5fWA7XG59XG5mdW5jdGlvbiBnZXRTbW9vdGhTdGVwUGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRYLCB0YXJnZXRZLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgYm9yZGVyUmFkaXVzID0gNSwgY2VudGVyWCwgY2VudGVyWSwgb2Zmc2V0ID0gMjAsIH0pIHtcbiAgICBjb25zdCBbcG9pbnRzLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRQb2ludHMoe1xuICAgICAgICBzb3VyY2U6IHsgeDogc291cmNlWCwgeTogc291cmNlWSB9LFxuICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0OiB7IHg6IHRhcmdldFgsIHk6IHRhcmdldFkgfSxcbiAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIGNlbnRlcjogeyB4OiBjZW50ZXJYLCB5OiBjZW50ZXJZIH0sXG4gICAgICAgIG9mZnNldCxcbiAgICB9KTtcbiAgICBjb25zdCBwYXRoID0gcG9pbnRzLnJlZHVjZSgocmVzLCBwLCBpKSA9PiB7XG4gICAgICAgIGxldCBzZWdtZW50ID0gJyc7XG4gICAgICAgIGlmIChpID4gMCAmJiBpIDwgcG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBnZXRCZW5kKHBvaW50c1tpIC0gMV0sIHAsIHBvaW50c1tpICsgMV0sIGJvcmRlclJhZGl1cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWdtZW50ID0gYCR7aSA9PT0gMCA/ICdNJyA6ICdMJ30ke3AueH0gJHtwLnl9YDtcbiAgICAgICAgfVxuICAgICAgICByZXMgKz0gc2VnbWVudDtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCAnJyk7XG4gICAgcmV0dXJuIFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV07XG59XG5jb25zdCBTbW9vdGhTdGVwRWRnZSA9IG1lbW8oKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBwYXRoT3B0aW9ucywgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRTbW9vdGhTdGVwUGF0aCh7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXRYLFxuICAgICAgICB0YXJnZXRZLFxuICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBwYXRoT3B0aW9ucz8uYm9yZGVyUmFkaXVzLFxuICAgICAgICBvZmZzZXQ6IHBhdGhPcHRpb25zPy5vZmZzZXQsXG4gICAgfSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEJhc2VFZGdlLCB7IHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG59KTtcblNtb290aFN0ZXBFZGdlLmRpc3BsYXlOYW1lID0gJ1Ntb290aFN0ZXBFZGdlJztcblxuY29uc3QgU3RlcEVkZ2UgPSBtZW1vKChwcm9wcykgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU21vb3RoU3RlcEVkZ2UsIHsgLi4ucHJvcHMsIHBhdGhPcHRpb25zOiB1c2VNZW1vKCgpID0+ICh7IGJvcmRlclJhZGl1czogMCwgb2Zmc2V0OiBwcm9wcy5wYXRoT3B0aW9ucz8ub2Zmc2V0IH0pLCBbcHJvcHMucGF0aE9wdGlvbnM/Lm9mZnNldF0pIH0pKSk7XG5TdGVwRWRnZS5kaXNwbGF5TmFtZSA9ICdTdGVwRWRnZSc7XG5cbmZ1bmN0aW9uIGdldFN0cmFpZ2h0UGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIH0pIHtcbiAgICBjb25zdCBbbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0RWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgfSk7XG4gICAgcmV0dXJuIFtgTSAke3NvdXJjZVh9LCR7c291cmNlWX1MICR7dGFyZ2V0WH0sJHt0YXJnZXRZfWAsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cbmNvbnN0IFN0cmFpZ2h0RWRnZSA9IG1lbW8oKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRTdHJhaWdodFBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZIH0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChCYXNlRWRnZSwgeyBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xufSk7XG5TdHJhaWdodEVkZ2UuZGlzcGxheU5hbWUgPSAnU3RyYWlnaHRFZGdlJztcblxuZnVuY3Rpb24gY2FsY3VsYXRlQ29udHJvbE9mZnNldChkaXN0YW5jZSwgY3VydmF0dXJlKSB7XG4gICAgaWYgKGRpc3RhbmNlID49IDApIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIGRpc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmF0dXJlICogMjUgKiBNYXRoLnNxcnQoLWRpc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHsgcG9zLCB4MSwgeTEsIHgyLCB5MiwgYyB9KSB7XG4gICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5MZWZ0OlxuICAgICAgICAgICAgcmV0dXJuIFt4MSAtIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoeDEgLSB4MiwgYyksIHkxXTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5SaWdodDpcbiAgICAgICAgICAgIHJldHVybiBbeDEgKyBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHgyIC0geDEsIGMpLCB5MV07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uVG9wOlxuICAgICAgICAgICAgcmV0dXJuIFt4MSwgeTEgLSBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHkxIC0geTIsIGMpXTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Cb3R0b206XG4gICAgICAgICAgICByZXR1cm4gW3gxLCB5MSArIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoeTIgLSB5MSwgYyldO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEJlemllclBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0WCwgdGFyZ2V0WSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGN1cnZhdHVyZSA9IDAuMjUsIH0pIHtcbiAgICBjb25zdCBbc291cmNlQ29udHJvbFgsIHNvdXJjZUNvbnRyb2xZXSA9IGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHtcbiAgICAgICAgcG9zOiBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgeDE6IHNvdXJjZVgsXG4gICAgICAgIHkxOiBzb3VyY2VZLFxuICAgICAgICB4MjogdGFyZ2V0WCxcbiAgICAgICAgeTI6IHRhcmdldFksXG4gICAgICAgIGM6IGN1cnZhdHVyZSxcbiAgICB9KTtcbiAgICBjb25zdCBbdGFyZ2V0Q29udHJvbFgsIHRhcmdldENvbnRyb2xZXSA9IGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHtcbiAgICAgICAgcG9zOiB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgeDE6IHRhcmdldFgsXG4gICAgICAgIHkxOiB0YXJnZXRZLFxuICAgICAgICB4Mjogc291cmNlWCxcbiAgICAgICAgeTI6IHNvdXJjZVksXG4gICAgICAgIGM6IGN1cnZhdHVyZSxcbiAgICB9KTtcbiAgICBjb25zdCBbbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0QmV6aWVyRWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgICAgIHNvdXJjZUNvbnRyb2xYLFxuICAgICAgICBzb3VyY2VDb250cm9sWSxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFgsXG4gICAgICAgIHRhcmdldENvbnRyb2xZLFxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGBNJHtzb3VyY2VYfSwke3NvdXJjZVl9IEMke3NvdXJjZUNvbnRyb2xYfSwke3NvdXJjZUNvbnRyb2xZfSAke3RhcmdldENvbnRyb2xYfSwke3RhcmdldENvbnRyb2xZfSAke3RhcmdldFh9LCR7dGFyZ2V0WX1gLFxuICAgICAgICBsYWJlbFgsXG4gICAgICAgIGxhYmVsWSxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICBdO1xufVxuY29uc3QgQmV6aWVyRWRnZSA9IG1lbW8oKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBwYXRoT3B0aW9ucywgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRCZXppZXJQYXRoKHtcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgICAgICBjdXJ2YXR1cmU6IHBhdGhPcHRpb25zPy5jdXJ2YXR1cmUsXG4gICAgfSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEJhc2VFZGdlLCB7IHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG59KTtcbkJlemllckVkZ2UuZGlzcGxheU5hbWUgPSAnQmV6aWVyRWRnZSc7XG5cbmNvbnN0IE5vZGVJZENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgUHJvdmlkZXIgPSBOb2RlSWRDb250ZXh0LlByb3ZpZGVyO1xuTm9kZUlkQ29udGV4dC5Db25zdW1lcjtcbmNvbnN0IHVzZU5vZGVJZCA9ICgpID0+IHtcbiAgICBjb25zdCBub2RlSWQgPSB1c2VDb250ZXh0KE5vZGVJZENvbnRleHQpO1xuICAgIHJldHVybiBub2RlSWQ7XG59O1xuXG5jb25zdCBpc0VkZ2UgPSAoZWxlbWVudCkgPT4gJ2lkJyBpbiBlbGVtZW50ICYmICdzb3VyY2UnIGluIGVsZW1lbnQgJiYgJ3RhcmdldCcgaW4gZWxlbWVudDtcbmNvbnN0IGlzTm9kZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgISgnc291cmNlJyBpbiBlbGVtZW50KSAmJiAhKCd0YXJnZXQnIGluIGVsZW1lbnQpO1xuY29uc3QgZ2V0T3V0Z29lcnMgPSAobm9kZSwgbm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgaWYgKCFpc05vZGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBvdXRnb2VySWRzID0gZWRnZXMuZmlsdGVyKChlKSA9PiBlLnNvdXJjZSA9PT0gbm9kZS5pZCkubWFwKChlKSA9PiBlLnRhcmdldCk7XG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcigobikgPT4gb3V0Z29lcklkcy5pbmNsdWRlcyhuLmlkKSk7XG59O1xuY29uc3QgZ2V0SW5jb21lcnMgPSAobm9kZSwgbm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgaWYgKCFpc05vZGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBpbmNvbWVyc0lkcyA9IGVkZ2VzLmZpbHRlcigoZSkgPT4gZS50YXJnZXQgPT09IG5vZGUuaWQpLm1hcCgoZSkgPT4gZS5zb3VyY2UpO1xuICAgIHJldHVybiBub2Rlcy5maWx0ZXIoKG4pID0+IGluY29tZXJzSWRzLmluY2x1ZGVzKG4uaWQpKTtcbn07XG5jb25zdCBnZXRFZGdlSWQgPSAoeyBzb3VyY2UsIHNvdXJjZUhhbmRsZSwgdGFyZ2V0LCB0YXJnZXRIYW5kbGUgfSkgPT4gYHJlYWN0Zmxvd19fZWRnZS0ke3NvdXJjZX0ke3NvdXJjZUhhbmRsZSB8fCAnJ30tJHt0YXJnZXR9JHt0YXJnZXRIYW5kbGUgfHwgJyd9YDtcbmNvbnN0IGdldE1hcmtlcklkID0gKG1hcmtlciwgcmZJZCkgPT4ge1xuICAgIGlmICh0eXBlb2YgbWFya2VyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWFya2VyID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgIH1cbiAgICBjb25zdCBpZFByZWZpeCA9IHJmSWQgPyBgJHtyZklkfV9fYCA6ICcnO1xuICAgIHJldHVybiBgJHtpZFByZWZpeH0ke09iamVjdC5rZXlzKG1hcmtlcilcbiAgICAgICAgLnNvcnQoKVxuICAgICAgICAubWFwKChrZXkpID0+IGAke2tleX09JHttYXJrZXJba2V5XX1gKVxuICAgICAgICAuam9pbignJicpfWA7XG59O1xuY29uc3QgY29ubmVjdGlvbkV4aXN0cyA9IChlZGdlLCBlZGdlcykgPT4ge1xuICAgIHJldHVybiBlZGdlcy5zb21lKChlbCkgPT4gZWwuc291cmNlID09PSBlZGdlLnNvdXJjZSAmJlxuICAgICAgICBlbC50YXJnZXQgPT09IGVkZ2UudGFyZ2V0ICYmXG4gICAgICAgIChlbC5zb3VyY2VIYW5kbGUgPT09IGVkZ2Uuc291cmNlSGFuZGxlIHx8ICghZWwuc291cmNlSGFuZGxlICYmICFlZGdlLnNvdXJjZUhhbmRsZSkpICYmXG4gICAgICAgIChlbC50YXJnZXRIYW5kbGUgPT09IGVkZ2UudGFyZ2V0SGFuZGxlIHx8ICghZWwudGFyZ2V0SGFuZGxlICYmICFlZGdlLnRhcmdldEhhbmRsZSkpKTtcbn07XG5jb25zdCBhZGRFZGdlID0gKGVkZ2VQYXJhbXMsIGVkZ2VzKSA9PiB7XG4gICAgaWYgKCFlZGdlUGFyYW1zLnNvdXJjZSB8fCAhZWRnZVBhcmFtcy50YXJnZXQpIHtcbiAgICAgICAgZGV2V2FybignMDA2JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDYnXSgpKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICBsZXQgZWRnZTtcbiAgICBpZiAoaXNFZGdlKGVkZ2VQYXJhbXMpKSB7XG4gICAgICAgIGVkZ2UgPSB7IC4uLmVkZ2VQYXJhbXMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVkZ2UgPSB7XG4gICAgICAgICAgICAuLi5lZGdlUGFyYW1zLFxuICAgICAgICAgICAgaWQ6IGdldEVkZ2VJZChlZGdlUGFyYW1zKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNvbm5lY3Rpb25FeGlzdHMoZWRnZSwgZWRnZXMpKSB7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgcmV0dXJuIGVkZ2VzLmNvbmNhdChlZGdlKTtcbn07XG5jb25zdCB1cGRhdGVFZGdlID0gKG9sZEVkZ2UsIG5ld0Nvbm5lY3Rpb24sIGVkZ2VzLCBvcHRpb25zID0geyBzaG91bGRSZXBsYWNlSWQ6IHRydWUgfSkgPT4ge1xuICAgIGNvbnN0IHsgaWQ6IG9sZEVkZ2VJZCwgLi4ucmVzdCB9ID0gb2xkRWRnZTtcbiAgICBpZiAoIW5ld0Nvbm5lY3Rpb24uc291cmNlIHx8ICFuZXdDb25uZWN0aW9uLnRhcmdldCkge1xuICAgICAgICBkZXZXYXJuKCcwMDYnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNiddKCkpO1xuICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIGNvbnN0IGZvdW5kRWRnZSA9IGVkZ2VzLmZpbmQoKGUpID0+IGUuaWQgPT09IG9sZEVkZ2VJZCk7XG4gICAgaWYgKCFmb3VuZEVkZ2UpIHtcbiAgICAgICAgZGV2V2FybignMDA3JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDcnXShvbGRFZGdlSWQpKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgb2xkIGVkZ2UgYW5kIGNyZWF0ZSB0aGUgbmV3IGVkZ2Ugd2l0aCBwYXJhbWV0ZXJzIG9mIG9sZCBlZGdlLlxuICAgIGNvbnN0IGVkZ2UgPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGlkOiBvcHRpb25zLnNob3VsZFJlcGxhY2VJZCA/IGdldEVkZ2VJZChuZXdDb25uZWN0aW9uKSA6IG9sZEVkZ2VJZCxcbiAgICAgICAgc291cmNlOiBuZXdDb25uZWN0aW9uLnNvdXJjZSxcbiAgICAgICAgdGFyZ2V0OiBuZXdDb25uZWN0aW9uLnRhcmdldCxcbiAgICAgICAgc291cmNlSGFuZGxlOiBuZXdDb25uZWN0aW9uLnNvdXJjZUhhbmRsZSxcbiAgICAgICAgdGFyZ2V0SGFuZGxlOiBuZXdDb25uZWN0aW9uLnRhcmdldEhhbmRsZSxcbiAgICB9O1xuICAgIHJldHVybiBlZGdlcy5maWx0ZXIoKGUpID0+IGUuaWQgIT09IG9sZEVkZ2VJZCkuY29uY2F0KGVkZ2UpO1xufTtcbmNvbnN0IHBvaW50VG9SZW5kZXJlclBvaW50ID0gKHsgeCwgeSB9LCBbdHgsIHR5LCB0U2NhbGVdLCBzbmFwVG9HcmlkLCBbc25hcFgsIHNuYXBZXSkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgICB4OiAoeCAtIHR4KSAvIHRTY2FsZSxcbiAgICAgICAgeTogKHkgLSB0eSkgLyB0U2NhbGUsXG4gICAgfTtcbiAgICBpZiAoc25hcFRvR3JpZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogc25hcFggKiBNYXRoLnJvdW5kKHBvc2l0aW9uLnggLyBzbmFwWCksXG4gICAgICAgICAgICB5OiBzbmFwWSAqIE1hdGgucm91bmQocG9zaXRpb24ueSAvIHNuYXBZKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xufTtcbmNvbnN0IHJlbmRlcmVyUG9pbnRUb1BvaW50ID0gKHsgeCwgeSB9LCBbdHgsIHR5LCB0U2NhbGVdKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAqIHRTY2FsZSArIHR4LFxuICAgICAgICB5OiB5ICogdFNjYWxlICsgdHksXG4gICAgfTtcbn07XG5jb25zdCBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luID0gKG5vZGUsIG5vZGVPcmlnaW4gPSBbMCwgMF0pID0+IHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZToge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldFggPSAobm9kZS53aWR0aCA/PyAwKSAqIG5vZGVPcmlnaW5bMF07XG4gICAgY29uc3Qgb2Zmc2V0WSA9IChub2RlLmhlaWdodCA/PyAwKSAqIG5vZGVPcmlnaW5bMV07XG4gICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgIHg6IG5vZGUucG9zaXRpb24ueCAtIG9mZnNldFgsXG4gICAgICAgIHk6IG5vZGUucG9zaXRpb24ueSAtIG9mZnNldFksXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5wb3NpdGlvbixcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZTogbm9kZS5wb3NpdGlvbkFic29sdXRlXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB4OiBub2RlLnBvc2l0aW9uQWJzb2x1dGUueCAtIG9mZnNldFgsXG4gICAgICAgICAgICAgICAgeTogbm9kZS5wb3NpdGlvbkFic29sdXRlLnkgLSBvZmZzZXRZLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBwb3NpdGlvbixcbiAgICB9O1xufTtcbmNvbnN0IGdldE5vZGVzQm91bmRzID0gKG5vZGVzLCBub2RlT3JpZ2luID0gWzAsIDBdKSA9PiB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgfVxuICAgIGNvbnN0IGJveCA9IG5vZGVzLnJlZHVjZSgoY3VyckJveCwgbm9kZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4obm9kZSwgbm9kZU9yaWdpbikucG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgcmV0dXJuIGdldEJvdW5kc09mQm94ZXMoY3VyckJveCwgcmVjdFRvQm94KHtcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgd2lkdGg6IG5vZGUud2lkdGggfHwgMCxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgfHwgMCxcbiAgICAgICAgfSkpO1xuICAgIH0sIHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5LCB4MjogLUluZmluaXR5LCB5MjogLUluZmluaXR5IH0pO1xuICAgIHJldHVybiBib3hUb1JlY3QoYm94KTtcbn07XG4vLyBAZGVwcmVjYXRlZCBVc2UgYGdldE5vZGVzQm91bmRzYC5cbmNvbnN0IGdldFJlY3RPZk5vZGVzID0gKG5vZGVzLCBub2RlT3JpZ2luID0gWzAsIDBdKSA9PiB7XG4gICAgY29uc29sZS53YXJuKCdbREVQUkVDQVRFRF0gYGdldFJlY3RPZk5vZGVzYCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHVzZSBgZ2V0Tm9kZXNCb3VuZHNgIGh0dHBzOi8vcmVhY3RmbG93LmRldi9hcGktcmVmZXJlbmNlL3V0aWxzL2dldC1ub2Rlcy1ib3VuZHMuJyk7XG4gICAgcmV0dXJuIGdldE5vZGVzQm91bmRzKG5vZGVzLCBub2RlT3JpZ2luKTtcbn07XG5jb25zdCBnZXROb2Rlc0luc2lkZSA9IChub2RlSW50ZXJuYWxzLCByZWN0LCBbdHgsIHR5LCB0U2NhbGVdID0gWzAsIDAsIDFdLCBwYXJ0aWFsbHkgPSBmYWxzZSwgXG4vLyBzZXQgZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyBpZiB5b3Ugd2FudCB0byBwYXkgYXR0ZW50aW9uIHRvIHRoZSBub2RlcyBcInNlbGVjdGFibGVcIiBhdHRyaWJ1dGVcbmV4Y2x1ZGVOb25TZWxlY3RhYmxlTm9kZXMgPSBmYWxzZSwgbm9kZU9yaWdpbiA9IFswLCAwXSkgPT4ge1xuICAgIGNvbnN0IHBhbmVSZWN0ID0ge1xuICAgICAgICB4OiAocmVjdC54IC0gdHgpIC8gdFNjYWxlLFxuICAgICAgICB5OiAocmVjdC55IC0gdHkpIC8gdFNjYWxlLFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCAvIHRTY2FsZSxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCAvIHRTY2FsZSxcbiAgICB9O1xuICAgIGNvbnN0IHZpc2libGVOb2RlcyA9IFtdO1xuICAgIG5vZGVJbnRlcm5hbHMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHNlbGVjdGFibGUgPSB0cnVlLCBoaWRkZW4gPSBmYWxzZSB9ID0gbm9kZTtcbiAgICAgICAgaWYgKChleGNsdWRlTm9uU2VsZWN0YWJsZU5vZGVzICYmICFzZWxlY3RhYmxlKSB8fCBoaWRkZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHBvc2l0aW9uQWJzb2x1dGUgfSA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4obm9kZSwgbm9kZU9yaWdpbik7XG4gICAgICAgIGNvbnN0IG5vZGVSZWN0ID0ge1xuICAgICAgICAgICAgeDogcG9zaXRpb25BYnNvbHV0ZS54LFxuICAgICAgICAgICAgeTogcG9zaXRpb25BYnNvbHV0ZS55LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoIHx8IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCB8fCAwLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBnZXRPdmVybGFwcGluZ0FyZWEocGFuZVJlY3QsIG5vZGVSZWN0KTtcbiAgICAgICAgY29uc3Qgbm90SW5pdGlhbGl6ZWQgPSB0eXBlb2Ygd2lkdGggPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBoZWlnaHQgPT09ICd1bmRlZmluZWQnIHx8IHdpZHRoID09PSBudWxsIHx8IGhlaWdodCA9PT0gbnVsbDtcbiAgICAgICAgY29uc3QgcGFydGlhbGx5VmlzaWJsZSA9IHBhcnRpYWxseSAmJiBvdmVybGFwcGluZ0FyZWEgPiAwO1xuICAgICAgICBjb25zdCBhcmVhID0gKHdpZHRoIHx8IDApICogKGhlaWdodCB8fCAwKTtcbiAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gbm90SW5pdGlhbGl6ZWQgfHwgcGFydGlhbGx5VmlzaWJsZSB8fCBvdmVybGFwcGluZ0FyZWEgPj0gYXJlYTtcbiAgICAgICAgaWYgKGlzVmlzaWJsZSB8fCBub2RlLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB2aXNpYmxlTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2aXNpYmxlTm9kZXM7XG59O1xuY29uc3QgZ2V0Q29ubmVjdGVkRWRnZXMgPSAobm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgY29uc3Qgbm9kZUlkcyA9IG5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5pZCk7XG4gICAgcmV0dXJuIGVkZ2VzLmZpbHRlcigoZWRnZSkgPT4gbm9kZUlkcy5pbmNsdWRlcyhlZGdlLnNvdXJjZSkgfHwgbm9kZUlkcy5pbmNsdWRlcyhlZGdlLnRhcmdldCkpO1xufTtcbi8vIEBkZXByZWNhdGVkIFVzZSBgZ2V0Vmlld3BvcnRGb3JCb3VuZHNgLlxuY29uc3QgZ2V0VHJhbnNmb3JtRm9yQm91bmRzID0gKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgcGFkZGluZyA9IDAuMSkgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBwYWRkaW5nKTtcbiAgICBjb25zb2xlLndhcm4oJ1tERVBSRUNBVEVEXSBgZ2V0VHJhbnNmb3JtRm9yQm91bmRzYCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHVzZSBgZ2V0Vmlld3BvcnRGb3JCb3VuZHNgLiBCZXdhcmUgdGhhdCB0aGUgcmV0dXJuIHZhbHVlIGlzIHR5cGUgVmlld3BvcnQgKGB7IHg6IG51bWJlciwgeTogbnVtYmVyLCB6b29tOiBudW1iZXIgfWApIGluc3RlYWQgb2YgVHJhbnNmb3JtIChgW251bWJlciwgbnVtYmVyLCBudW1iZXJdYCkuIGh0dHBzOi8vcmVhY3RmbG93LmRldi9hcGktcmVmZXJlbmNlL3V0aWxzL2dldC12aWV3cG9ydC1mb3ItYm91bmRzJyk7XG4gICAgcmV0dXJuIFt4LCB5LCB6b29tXTtcbn07XG5jb25zdCBnZXRWaWV3cG9ydEZvckJvdW5kcyA9IChib3VuZHMsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20sIHBhZGRpbmcgPSAwLjEpID0+IHtcbiAgICBjb25zdCB4Wm9vbSA9IHdpZHRoIC8gKGJvdW5kcy53aWR0aCAqICgxICsgcGFkZGluZykpO1xuICAgIGNvbnN0IHlab29tID0gaGVpZ2h0IC8gKGJvdW5kcy5oZWlnaHQgKiAoMSArIHBhZGRpbmcpKTtcbiAgICBjb25zdCB6b29tID0gTWF0aC5taW4oeFpvb20sIHlab29tKTtcbiAgICBjb25zdCBjbGFtcGVkWm9vbSA9IGNsYW1wKHpvb20sIG1pblpvb20sIG1heFpvb20pO1xuICAgIGNvbnN0IGJvdW5kc0NlbnRlclggPSBib3VuZHMueCArIGJvdW5kcy53aWR0aCAvIDI7XG4gICAgY29uc3QgYm91bmRzQ2VudGVyWSA9IGJvdW5kcy55ICsgYm91bmRzLmhlaWdodCAvIDI7XG4gICAgY29uc3QgeCA9IHdpZHRoIC8gMiAtIGJvdW5kc0NlbnRlclggKiBjbGFtcGVkWm9vbTtcbiAgICBjb25zdCB5ID0gaGVpZ2h0IC8gMiAtIGJvdW5kc0NlbnRlclkgKiBjbGFtcGVkWm9vbTtcbiAgICByZXR1cm4geyB4LCB5LCB6b29tOiBjbGFtcGVkWm9vbSB9O1xufTtcbmNvbnN0IGdldEQzVHJhbnNpdGlvbiA9IChzZWxlY3Rpb24sIGR1cmF0aW9uID0gMCkgPT4ge1xuICAgIHJldHVybiBzZWxlY3Rpb24udHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKTtcbn07XG5cbi8vIHRoaXMgZnVuY3Rpb25zIGNvbGxlY3RzIGFsbCBoYW5kbGVzIGFuZCBhZGRzIGFuIGFic29sdXRlIHBvc2l0aW9uXG4vLyBzbyB0aGF0IHdlIGNhbiBsYXRlciBmaW5kIHRoZSBjbG9zZXN0IGhhbmRsZSB0byB0aGUgbW91c2UgcG9zaXRpb25cbmZ1bmN0aW9uIGdldEhhbmRsZXMobm9kZSwgaGFuZGxlQm91bmRzLCB0eXBlLCBjdXJyZW50SGFuZGxlKSB7XG4gICAgcmV0dXJuIChoYW5kbGVCb3VuZHNbdHlwZV0gfHwgW10pLnJlZHVjZSgocmVzLCBoKSA9PiB7XG4gICAgICAgIGlmIChgJHtub2RlLmlkfS0ke2guaWR9LSR7dHlwZX1gICE9PSBjdXJyZW50SGFuZGxlKSB7XG4gICAgICAgICAgICByZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IGguaWQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIG5vZGVJZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICB4OiAobm9kZS5wb3NpdGlvbkFic29sdXRlPy54ID8/IDApICsgaC54ICsgaC53aWR0aCAvIDIsXG4gICAgICAgICAgICAgICAgeTogKG5vZGUucG9zaXRpb25BYnNvbHV0ZT8ueSA/PyAwKSArIGgueSArIGguaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgW10pO1xufVxuZnVuY3Rpb24gZ2V0Q2xvc2VzdEhhbmRsZShldmVudCwgZG9jLCBwb3MsIGNvbm5lY3Rpb25SYWRpdXMsIGhhbmRsZXMsIHZhbGlkYXRvcikge1xuICAgIC8vIHdlIGFsd2F5cyB3YW50IHRvIHByaW9yaXRpemUgdGhlIGhhbmRsZSBiZWxvdyB0aGUgbW91c2UgY3Vyc29yIG92ZXIgdGhlIGNsb3Nlc3QgZGlzdGFuY2UgaGFuZGxlLFxuICAgIC8vIGJlY2F1c2UgaXQgY291bGQgYmUgdGhhdCB0aGUgY2VudGVyIG9mIGFub3RoZXIgaGFuZGxlIGlzIGNsb3NlciB0byB0aGUgbW91c2UgcG9pbnRlciB0aGFuIHRoZSBoYW5kbGUgYmVsb3cgdGhlIGN1cnNvclxuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgZG9tTm9kZXMgPSBkb2MuZWxlbWVudHNGcm9tUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgaGFuZGxlQmVsb3cgPSBkb21Ob2Rlcy5maW5kKChlbCkgPT4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdyZWFjdC1mbG93X19oYW5kbGUnKSk7XG4gICAgaWYgKGhhbmRsZUJlbG93KSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZU5vZGVJZCA9IGhhbmRsZUJlbG93LmdldEF0dHJpYnV0ZSgnZGF0YS1ub2RlaWQnKTtcbiAgICAgICAgaWYgKGhhbmRsZU5vZGVJZCkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlVHlwZSA9IGdldEhhbmRsZVR5cGUodW5kZWZpbmVkLCBoYW5kbGVCZWxvdyk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVJZCA9IGhhbmRsZUJlbG93LmdldEF0dHJpYnV0ZSgnZGF0YS1oYW5kbGVpZCcpO1xuICAgICAgICAgICAgY29uc3QgdmFsaWRIYW5kbGVSZXN1bHQgPSB2YWxpZGF0b3IoeyBub2RlSWQ6IGhhbmRsZU5vZGVJZCwgaWQ6IGhhbmRsZUlkLCB0eXBlOiBoYW5kbGVUeXBlIH0pO1xuICAgICAgICAgICAgaWYgKHZhbGlkSGFuZGxlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gaGFuZGxlcy5maW5kKChoKSA9PiBoLm5vZGVJZCA9PT0gaGFuZGxlTm9kZUlkICYmIGgudHlwZSA9PT0gaGFuZGxlVHlwZSAmJiBoLmlkID09PSBoYW5kbGVJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaGFuZGxlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBoYW5kbGVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkOiBoYW5kbGVOb2RlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBoYW5kbGU/LnggfHwgcG9zLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBoYW5kbGU/LnkgfHwgcG9zLnksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkSGFuZGxlUmVzdWx0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgd2UgY291bGRuJ3QgZmluZCBhIGhhbmRsZSBiZWxvdyB0aGUgbW91c2UgY3Vyc29yIHdlIGxvb2sgZm9yIHRoZSBjbG9zZXN0IGRpc3RhbmNlIGJhc2VkIG9uIHRoZSBjb25uZWN0aW9uUmFkaXVzXG4gICAgbGV0IGNsb3Nlc3RIYW5kbGVzID0gW107XG4gICAgbGV0IG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgaGFuZGxlcy5mb3JFYWNoKChoYW5kbGUpID0+IHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoKGhhbmRsZS54IC0gcG9zLngpICoqIDIgKyAoaGFuZGxlLnkgLSBwb3MueSkgKiogMik7XG4gICAgICAgIGlmIChkaXN0YW5jZSA8PSBjb25uZWN0aW9uUmFkaXVzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWxpZEhhbmRsZVJlc3VsdCA9IHZhbGlkYXRvcihoYW5kbGUpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDw9IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdEhhbmRsZXMgPSBbeyBoYW5kbGUsIHZhbGlkSGFuZGxlUmVzdWx0IH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBtdWx0aXBsZSBoYW5kbGVzIGFyZSBvbiB0aGUgc2FtZSBkaXN0YW5jZSB3ZSBjb2xsZWN0IGFsbCBvZiB0aGVtXG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RIYW5kbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRIYW5kbGVSZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFjbG9zZXN0SGFuZGxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHsgaGFuZGxlOiBudWxsLCB2YWxpZEhhbmRsZVJlc3VsdDogZGVmYXVsdFJlc3VsdCgpIH07XG4gICAgfVxuICAgIGlmIChjbG9zZXN0SGFuZGxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RIYW5kbGVzWzBdO1xuICAgIH1cbiAgICBjb25zdCBoYXNWYWxpZEhhbmRsZSA9IGNsb3Nlc3RIYW5kbGVzLnNvbWUoKHsgdmFsaWRIYW5kbGVSZXN1bHQgfSkgPT4gdmFsaWRIYW5kbGVSZXN1bHQuaXNWYWxpZCk7XG4gICAgY29uc3QgaGFzVGFyZ2V0SGFuZGxlID0gY2xvc2VzdEhhbmRsZXMuc29tZSgoeyBoYW5kbGUgfSkgPT4gaGFuZGxlLnR5cGUgPT09ICd0YXJnZXQnKTtcbiAgICAvLyBpZiBtdWx0aXBsZSBoYW5kbGVzIGFyZSBsYXlvdXRlZCBvbiB0b3Agb2YgZWFjaCBvdGhlciB3ZSBwcmVmZXIgdGhlIG9uZSB3aXRoIHR5cGUgPSB0YXJnZXQgYW5kIHRoZSBvbmUgdGhhdCBpcyB2YWxpZFxuICAgIHJldHVybiAoY2xvc2VzdEhhbmRsZXMuZmluZCgoeyBoYW5kbGUsIHZhbGlkSGFuZGxlUmVzdWx0IH0pID0+IGhhc1RhcmdldEhhbmRsZSA/IGhhbmRsZS50eXBlID09PSAndGFyZ2V0JyA6IChoYXNWYWxpZEhhbmRsZSA/IHZhbGlkSGFuZGxlUmVzdWx0LmlzVmFsaWQgOiB0cnVlKSkgfHwgY2xvc2VzdEhhbmRsZXNbMF0pO1xufVxuY29uc3QgbnVsbENvbm5lY3Rpb24gPSB7IHNvdXJjZTogbnVsbCwgdGFyZ2V0OiBudWxsLCBzb3VyY2VIYW5kbGU6IG51bGwsIHRhcmdldEhhbmRsZTogbnVsbCB9O1xuY29uc3QgZGVmYXVsdFJlc3VsdCA9ICgpID0+ICh7XG4gICAgaGFuZGxlRG9tTm9kZTogbnVsbCxcbiAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICBjb25uZWN0aW9uOiBudWxsQ29ubmVjdGlvbixcbiAgICBlbmRIYW5kbGU6IG51bGwsXG59KTtcbi8vIGNoZWNrcyBpZiAgYW5kIHJldHVybnMgY29ubmVjdGlvbiBpbiBmb20gb2YgYW4gb2JqZWN0IHsgc291cmNlOiAxMjMsIHRhcmdldDogMzEyIH1cbmZ1bmN0aW9uIGlzVmFsaWRIYW5kbGUoaGFuZGxlLCBjb25uZWN0aW9uTW9kZSwgZnJvbU5vZGVJZCwgZnJvbUhhbmRsZUlkLCBmcm9tVHlwZSwgaXNWYWxpZENvbm5lY3Rpb24sIGRvYykge1xuICAgIGNvbnN0IGlzVGFyZ2V0ID0gZnJvbVR5cGUgPT09ICd0YXJnZXQnO1xuICAgIGNvbnN0IGhhbmRsZVRvQ2hlY2sgPSBkb2MucXVlcnlTZWxlY3RvcihgLnJlYWN0LWZsb3dfX2hhbmRsZVtkYXRhLWlkPVwiJHtoYW5kbGU/Lm5vZGVJZH0tJHtoYW5kbGU/LmlkfS0ke2hhbmRsZT8udHlwZX1cIl1gKTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRSZXN1bHQoKSxcbiAgICAgICAgaGFuZGxlRG9tTm9kZTogaGFuZGxlVG9DaGVjayxcbiAgICB9O1xuICAgIGlmIChoYW5kbGVUb0NoZWNrKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZVR5cGUgPSBnZXRIYW5kbGVUeXBlKHVuZGVmaW5lZCwgaGFuZGxlVG9DaGVjayk7XG4gICAgICAgIGNvbnN0IGhhbmRsZU5vZGVJZCA9IGhhbmRsZVRvQ2hlY2suZ2V0QXR0cmlidXRlKCdkYXRhLW5vZGVpZCcpO1xuICAgICAgICBjb25zdCBoYW5kbGVJZCA9IGhhbmRsZVRvQ2hlY2suZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZWlkJyk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RhYmxlID0gaGFuZGxlVG9DaGVjay5jbGFzc0xpc3QuY29udGFpbnMoJ2Nvbm5lY3RhYmxlJyk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RhYmxlRW5kID0gaGFuZGxlVG9DaGVjay5jbGFzc0xpc3QuY29udGFpbnMoJ2Nvbm5lY3RhYmxlZW5kJyk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB7XG4gICAgICAgICAgICBzb3VyY2U6IGlzVGFyZ2V0ID8gaGFuZGxlTm9kZUlkIDogZnJvbU5vZGVJZCxcbiAgICAgICAgICAgIHNvdXJjZUhhbmRsZTogaXNUYXJnZXQgPyBoYW5kbGVJZCA6IGZyb21IYW5kbGVJZCxcbiAgICAgICAgICAgIHRhcmdldDogaXNUYXJnZXQgPyBmcm9tTm9kZUlkIDogaGFuZGxlTm9kZUlkLFxuICAgICAgICAgICAgdGFyZ2V0SGFuZGxlOiBpc1RhcmdldCA/IGZyb21IYW5kbGVJZCA6IGhhbmRsZUlkLFxuICAgICAgICB9O1xuICAgICAgICByZXN1bHQuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIGNvbnN0IGlzQ29ubmVjdGFibGUgPSBjb25uZWN0YWJsZSAmJiBjb25uZWN0YWJsZUVuZDtcbiAgICAgICAgLy8gaW4gc3RyaWN0IG1vZGUgd2UgZG9uJ3QgYWxsb3cgdGFyZ2V0IHRvIHRhcmdldCBvciBzb3VyY2UgdG8gc291cmNlIGNvbm5lY3Rpb25zXG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBpc0Nvbm5lY3RhYmxlICYmXG4gICAgICAgICAgICAoY29ubmVjdGlvbk1vZGUgPT09IENvbm5lY3Rpb25Nb2RlLlN0cmljdFxuICAgICAgICAgICAgICAgID8gKGlzVGFyZ2V0ICYmIGhhbmRsZVR5cGUgPT09ICdzb3VyY2UnKSB8fCAoIWlzVGFyZ2V0ICYmIGhhbmRsZVR5cGUgPT09ICd0YXJnZXQnKVxuICAgICAgICAgICAgICAgIDogaGFuZGxlTm9kZUlkICE9PSBmcm9tTm9kZUlkIHx8IGhhbmRsZUlkICE9PSBmcm9tSGFuZGxlSWQpO1xuICAgICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgcmVzdWx0LmVuZEhhbmRsZSA9IHtcbiAgICAgICAgICAgICAgICBub2RlSWQ6IGhhbmRsZU5vZGVJZCxcbiAgICAgICAgICAgICAgICBoYW5kbGVJZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBoYW5kbGVUeXBlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdC5pc1ZhbGlkID0gaXNWYWxpZENvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZUxvb2t1cCh7IG5vZGVzLCBub2RlSWQsIGhhbmRsZUlkLCBoYW5kbGVUeXBlIH0pIHtcbiAgICByZXR1cm4gbm9kZXMucmVkdWNlKChyZXMsIG5vZGUpID0+IHtcbiAgICAgICAgaWYgKG5vZGVbaW50ZXJuYWxzU3ltYm9sXSkge1xuICAgICAgICAgICAgY29uc3QgeyBoYW5kbGVCb3VuZHMgfSA9IG5vZGVbaW50ZXJuYWxzU3ltYm9sXTtcbiAgICAgICAgICAgIGxldCBzb3VyY2VIYW5kbGVzID0gW107XG4gICAgICAgICAgICBsZXQgdGFyZ2V0SGFuZGxlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKGhhbmRsZUJvdW5kcykge1xuICAgICAgICAgICAgICAgIHNvdXJjZUhhbmRsZXMgPSBnZXRIYW5kbGVzKG5vZGUsIGhhbmRsZUJvdW5kcywgJ3NvdXJjZScsIGAke25vZGVJZH0tJHtoYW5kbGVJZH0tJHtoYW5kbGVUeXBlfWApO1xuICAgICAgICAgICAgICAgIHRhcmdldEhhbmRsZXMgPSBnZXRIYW5kbGVzKG5vZGUsIGhhbmRsZUJvdW5kcywgJ3RhcmdldCcsIGAke25vZGVJZH0tJHtoYW5kbGVJZH0tJHtoYW5kbGVUeXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLnB1c2goLi4uc291cmNlSGFuZGxlcywgLi4udGFyZ2V0SGFuZGxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCBbXSk7XG59XG5mdW5jdGlvbiBnZXRIYW5kbGVUeXBlKGVkZ2VVcGRhdGVyVHlwZSwgaGFuZGxlRG9tTm9kZSkge1xuICAgIGlmIChlZGdlVXBkYXRlclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VVcGRhdGVyVHlwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlRG9tTm9kZT8uY2xhc3NMaXN0LmNvbnRhaW5zKCd0YXJnZXQnKSkge1xuICAgICAgICByZXR1cm4gJ3RhcmdldCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhbmRsZURvbU5vZGU/LmNsYXNzTGlzdC5jb250YWlucygnc291cmNlJykpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2UnO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlc2V0UmVjZW50SGFuZGxlKGhhbmRsZURvbU5vZGUpIHtcbiAgICBoYW5kbGVEb21Ob2RlPy5jbGFzc0xpc3QucmVtb3ZlKCd2YWxpZCcsICdjb25uZWN0aW5nJywgJ3JlYWN0LWZsb3dfX2hhbmRsZS12YWxpZCcsICdyZWFjdC1mbG93X19oYW5kbGUtY29ubmVjdGluZycpO1xufVxuZnVuY3Rpb24gZ2V0Q29ubmVjdGlvblN0YXR1cyhpc0luc2lkZUNvbm5lY3Rpb25SYWRpdXMsIGlzSGFuZGxlVmFsaWQpIHtcbiAgICBsZXQgY29ubmVjdGlvblN0YXR1cyA9IG51bGw7XG4gICAgaWYgKGlzSGFuZGxlVmFsaWQpIHtcbiAgICAgICAgY29ubmVjdGlvblN0YXR1cyA9ICd2YWxpZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSW5zaWRlQ29ubmVjdGlvblJhZGl1cyAmJiAhaXNIYW5kbGVWYWxpZCkge1xuICAgICAgICBjb25uZWN0aW9uU3RhdHVzID0gJ2ludmFsaWQnO1xuICAgIH1cbiAgICByZXR1cm4gY29ubmVjdGlvblN0YXR1cztcbn1cblxuZnVuY3Rpb24gaGFuZGxlUG9pbnRlckRvd24oeyBldmVudCwgaGFuZGxlSWQsIG5vZGVJZCwgb25Db25uZWN0LCBpc1RhcmdldCwgZ2V0U3RhdGUsIHNldFN0YXRlLCBpc1ZhbGlkQ29ubmVjdGlvbiwgZWRnZVVwZGF0ZXJUeXBlLCBvbkVkZ2VVcGRhdGVFbmQsIH0pIHtcbiAgICAvLyB3aGVuIHJlYWN0LWZsb3cgaXMgdXNlZCBpbnNpZGUgYSBzaGFkb3cgcm9vdCB3ZSBjYW4ndCB1c2UgZG9jdW1lbnRcbiAgICBjb25zdCBkb2MgPSBnZXRIb3N0Rm9yRWxlbWVudChldmVudC50YXJnZXQpO1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbk1vZGUsIGRvbU5vZGUsIGF1dG9QYW5PbkNvbm5lY3QsIGNvbm5lY3Rpb25SYWRpdXMsIG9uQ29ubmVjdFN0YXJ0LCBwYW5CeSwgZ2V0Tm9kZXMsIGNhbmNlbENvbm5lY3Rpb24sIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGxldCBhdXRvUGFuSWQgPSAwO1xuICAgIGxldCBjbG9zZXN0SGFuZGxlO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgY2xpY2tlZEhhbmRsZSA9IGRvYz8uZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICBjb25zdCBoYW5kbGVUeXBlID0gZ2V0SGFuZGxlVHlwZShlZGdlVXBkYXRlclR5cGUsIGNsaWNrZWRIYW5kbGUpO1xuICAgIGNvbnN0IGNvbnRhaW5lckJvdW5kcyA9IGRvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmICghY29udGFpbmVyQm91bmRzIHx8ICFoYW5kbGVUeXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHByZXZBY3RpdmVIYW5kbGU7XG4gICAgbGV0IGNvbm5lY3Rpb25Qb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgbGV0IGF1dG9QYW5TdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IGNvbm5lY3Rpb24gPSBudWxsO1xuICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XG4gICAgbGV0IGhhbmRsZURvbU5vZGUgPSBudWxsO1xuICAgIGNvbnN0IGhhbmRsZUxvb2t1cCA9IGdldEhhbmRsZUxvb2t1cCh7XG4gICAgICAgIG5vZGVzOiBnZXROb2RlcygpLFxuICAgICAgICBub2RlSWQsXG4gICAgICAgIGhhbmRsZUlkLFxuICAgICAgICBoYW5kbGVUeXBlLFxuICAgIH0pO1xuICAgIC8vIHdoZW4gdGhlIHVzZXIgaXMgbW92aW5nIHRoZSBtb3VzZSBjbG9zZSB0byB0aGUgZWRnZSBvZiB0aGUgY2FudmFzIHdoaWxlIGNvbm5lY3Rpbmcgd2UgbW92ZSB0aGUgY2FudmFzXG4gICAgY29uc3QgYXV0b1BhbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFhdXRvUGFuT25Db25uZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3hNb3ZlbWVudCwgeU1vdmVtZW50XSA9IGNhbGNBdXRvUGFuKGNvbm5lY3Rpb25Qb3NpdGlvbiwgY29udGFpbmVyQm91bmRzKTtcbiAgICAgICAgcGFuQnkoeyB4OiB4TW92ZW1lbnQsIHk6IHlNb3ZlbWVudCB9KTtcbiAgICAgICAgYXV0b1BhbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGF1dG9QYW4pO1xuICAgIH07XG4gICAgc2V0U3RhdGUoe1xuICAgICAgICBjb25uZWN0aW9uUG9zaXRpb24sXG4gICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6IG51bGwsXG4gICAgICAgIC8vIGNvbm5lY3Rpb25Ob2RlSWQgZXRjIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciBpbiBmYXZvciBvZiBjb25uZWN0aW9uU3RhcnRIYW5kbGVcbiAgICAgICAgY29ubmVjdGlvbk5vZGVJZDogbm9kZUlkLFxuICAgICAgICBjb25uZWN0aW9uSGFuZGxlSWQ6IGhhbmRsZUlkLFxuICAgICAgICBjb25uZWN0aW9uSGFuZGxlVHlwZTogaGFuZGxlVHlwZSxcbiAgICAgICAgY29ubmVjdGlvblN0YXJ0SGFuZGxlOiB7XG4gICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICBoYW5kbGVJZCxcbiAgICAgICAgICAgIHR5cGU6IGhhbmRsZVR5cGUsXG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3Rpb25FbmRIYW5kbGU6IG51bGwsXG4gICAgfSk7XG4gICAgb25Db25uZWN0U3RhcnQ/LihldmVudCwgeyBub2RlSWQsIGhhbmRsZUlkLCBoYW5kbGVUeXBlIH0pO1xuICAgIGZ1bmN0aW9uIG9uUG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0gfSA9IGdldFN0YXRlKCk7XG4gICAgICAgIGNvbm5lY3Rpb25Qb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgICAgIGNvbnN0IHsgaGFuZGxlLCB2YWxpZEhhbmRsZVJlc3VsdCB9ID0gZ2V0Q2xvc2VzdEhhbmRsZShldmVudCwgZG9jLCBwb2ludFRvUmVuZGVyZXJQb2ludChjb25uZWN0aW9uUG9zaXRpb24sIHRyYW5zZm9ybSwgZmFsc2UsIFsxLCAxXSksIGNvbm5lY3Rpb25SYWRpdXMsIGhhbmRsZUxvb2t1cCwgKGhhbmRsZSkgPT4gaXNWYWxpZEhhbmRsZShoYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBub2RlSWQsIGhhbmRsZUlkLCBpc1RhcmdldCA/ICd0YXJnZXQnIDogJ3NvdXJjZScsIGlzVmFsaWRDb25uZWN0aW9uLCBkb2MpKTtcbiAgICAgICAgY2xvc2VzdEhhbmRsZSA9IGhhbmRsZTtcbiAgICAgICAgaWYgKCFhdXRvUGFuU3RhcnRlZCkge1xuICAgICAgICAgICAgYXV0b1BhbigpO1xuICAgICAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZURvbU5vZGUgPSB2YWxpZEhhbmRsZVJlc3VsdC5oYW5kbGVEb21Ob2RlO1xuICAgICAgICBjb25uZWN0aW9uID0gdmFsaWRIYW5kbGVSZXN1bHQuY29ubmVjdGlvbjtcbiAgICAgICAgaXNWYWxpZCA9IHZhbGlkSGFuZGxlUmVzdWx0LmlzVmFsaWQ7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Qb3NpdGlvbjogY2xvc2VzdEhhbmRsZSAmJiBpc1ZhbGlkXG4gICAgICAgICAgICAgICAgPyByZW5kZXJlclBvaW50VG9Qb2ludCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IGNsb3Nlc3RIYW5kbGUueCxcbiAgICAgICAgICAgICAgICAgICAgeTogY2xvc2VzdEhhbmRsZS55LFxuICAgICAgICAgICAgICAgIH0sIHRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICA6IGNvbm5lY3Rpb25Qb3NpdGlvbixcbiAgICAgICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6IGdldENvbm5lY3Rpb25TdGF0dXMoISFjbG9zZXN0SGFuZGxlLCBpc1ZhbGlkKSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25FbmRIYW5kbGU6IHZhbGlkSGFuZGxlUmVzdWx0LmVuZEhhbmRsZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2xvc2VzdEhhbmRsZSAmJiAhaXNWYWxpZCAmJiAhaGFuZGxlRG9tTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0UmVjZW50SGFuZGxlKHByZXZBY3RpdmVIYW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uLnNvdXJjZSAhPT0gY29ubmVjdGlvbi50YXJnZXQgJiYgaGFuZGxlRG9tTm9kZSkge1xuICAgICAgICAgICAgcmVzZXRSZWNlbnRIYW5kbGUocHJldkFjdGl2ZUhhbmRsZSk7XG4gICAgICAgICAgICBwcmV2QWN0aXZlSGFuZGxlID0gaGFuZGxlRG9tTm9kZTtcbiAgICAgICAgICAgIC8vIEB0b2RvOiByZW1vdmUgdGhlIG9sZCBjbGFzcyBuYW1lcyBcInJlYWN0LWZsb3dfX2hhbmRsZS1cIiBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXG4gICAgICAgICAgICBoYW5kbGVEb21Ob2RlLmNsYXNzTGlzdC5hZGQoJ2Nvbm5lY3RpbmcnLCAncmVhY3QtZmxvd19faGFuZGxlLWNvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgIGhhbmRsZURvbU5vZGUuY2xhc3NMaXN0LnRvZ2dsZSgndmFsaWQnLCBpc1ZhbGlkKTtcbiAgICAgICAgICAgIGhhbmRsZURvbU5vZGUuY2xhc3NMaXN0LnRvZ2dsZSgncmVhY3QtZmxvd19faGFuZGxlLXZhbGlkJywgaXNWYWxpZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Qb2ludGVyVXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKChjbG9zZXN0SGFuZGxlIHx8IGhhbmRsZURvbU5vZGUpICYmIGNvbm5lY3Rpb24gJiYgaXNWYWxpZCkge1xuICAgICAgICAgICAgb25Db25uZWN0Py4oY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXQncyBpbXBvcnRhbnQgdG8gZ2V0IGEgZnJlc2ggcmVmZXJlbmNlIGZyb20gdGhlIHN0b3JlIGhlcmVcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gZ2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2Ygb25Db25uZWN0RW5kXG4gICAgICAgIGdldFN0YXRlKCkub25Db25uZWN0RW5kPy4oZXZlbnQpO1xuICAgICAgICBpZiAoZWRnZVVwZGF0ZXJUeXBlKSB7XG4gICAgICAgICAgICBvbkVkZ2VVcGRhdGVFbmQ/LihldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzZXRSZWNlbnRIYW5kbGUocHJldkFjdGl2ZUhhbmRsZSk7XG4gICAgICAgIGNhbmNlbENvbm5lY3Rpb24oKTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYXV0b1BhbklkKTtcbiAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICBjb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgaGFuZGxlRG9tTm9kZSA9IG51bGw7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblBvaW50ZXJVcCk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Qb2ludGVyVXApO1xuICAgIH1cbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblBvaW50ZXJVcCk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uUG9pbnRlclVwKTtcbn1cblxuY29uc3QgYWx3YXlzVmFsaWQgPSAoKSA9PiB0cnVlO1xuY29uc3Qgc2VsZWN0b3IkZiA9IChzKSA9PiAoe1xuICAgIGNvbm5lY3Rpb25TdGFydEhhbmRsZTogcy5jb25uZWN0aW9uU3RhcnRIYW5kbGUsXG4gICAgY29ubmVjdE9uQ2xpY2s6IHMuY29ubmVjdE9uQ2xpY2ssXG4gICAgbm9QYW5DbGFzc05hbWU6IHMubm9QYW5DbGFzc05hbWUsXG59KTtcbmNvbnN0IGNvbm5lY3RpbmdTZWxlY3RvciA9IChub2RlSWQsIGhhbmRsZUlkLCB0eXBlKSA9PiAoc3RhdGUpID0+IHtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25TdGFydEhhbmRsZTogc3RhcnRIYW5kbGUsIGNvbm5lY3Rpb25FbmRIYW5kbGU6IGVuZEhhbmRsZSwgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IGNsaWNrSGFuZGxlLCB9ID0gc3RhdGU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29ubmVjdGluZzogKHN0YXJ0SGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiBzdGFydEhhbmRsZT8uaGFuZGxlSWQgPT09IGhhbmRsZUlkICYmIHN0YXJ0SGFuZGxlPy50eXBlID09PSB0eXBlKSB8fFxuICAgICAgICAgICAgKGVuZEhhbmRsZT8ubm9kZUlkID09PSBub2RlSWQgJiYgZW5kSGFuZGxlPy5oYW5kbGVJZCA9PT0gaGFuZGxlSWQgJiYgZW5kSGFuZGxlPy50eXBlID09PSB0eXBlKSxcbiAgICAgICAgY2xpY2tDb25uZWN0aW5nOiBjbGlja0hhbmRsZT8ubm9kZUlkID09PSBub2RlSWQgJiYgY2xpY2tIYW5kbGU/LmhhbmRsZUlkID09PSBoYW5kbGVJZCAmJiBjbGlja0hhbmRsZT8udHlwZSA9PT0gdHlwZSxcbiAgICB9O1xufTtcbmNvbnN0IEhhbmRsZSA9IGZvcndhcmRSZWYoKHsgdHlwZSA9ICdzb3VyY2UnLCBwb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgaXNWYWxpZENvbm5lY3Rpb24sIGlzQ29ubmVjdGFibGUgPSB0cnVlLCBpc0Nvbm5lY3RhYmxlU3RhcnQgPSB0cnVlLCBpc0Nvbm5lY3RhYmxlRW5kID0gdHJ1ZSwgaWQsIG9uQ29ubmVjdCwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgb25Nb3VzZURvd24sIG9uVG91Y2hTdGFydCwgLi4ucmVzdCB9LCByZWYpID0+IHtcbiAgICBjb25zdCBoYW5kbGVJZCA9IGlkIHx8IG51bGw7XG4gICAgY29uc3QgaXNUYXJnZXQgPSB0eXBlID09PSAndGFyZ2V0JztcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgeyBjb25uZWN0T25DbGljaywgbm9QYW5DbGFzc05hbWUgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGYsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHsgY29ubmVjdGluZywgY2xpY2tDb25uZWN0aW5nIH0gPSB1c2VTdG9yZShjb25uZWN0aW5nU2VsZWN0b3Iobm9kZUlkLCBoYW5kbGVJZCwgdHlwZSksIHNoYWxsb3cpO1xuICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMTAnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMCddKCkpO1xuICAgIH1cbiAgICBjb25zdCBvbkNvbm5lY3RFeHRlbmRlZCA9IChwYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0RWRnZU9wdGlvbnMsIG9uQ29ubmVjdDogb25Db25uZWN0QWN0aW9uLCBoYXNEZWZhdWx0RWRnZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGVkZ2VQYXJhbXMgPSB7XG4gICAgICAgICAgICAuLi5kZWZhdWx0RWRnZU9wdGlvbnMsXG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRnZXMsIHNldEVkZ2VzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgc2V0RWRnZXMoYWRkRWRnZShlZGdlUGFyYW1zLCBlZGdlcykpO1xuICAgICAgICB9XG4gICAgICAgIG9uQ29ubmVjdEFjdGlvbj8uKGVkZ2VQYXJhbXMpO1xuICAgICAgICBvbkNvbm5lY3Q/LihlZGdlUGFyYW1zKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUG9pbnRlckRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc01vdXNlVHJpZ2dlcmVkID0gaXNNb3VzZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgaWYgKGlzQ29ubmVjdGFibGVTdGFydCAmJiAoKGlzTW91c2VUcmlnZ2VyZWQgJiYgZXZlbnQuYnV0dG9uID09PSAwKSB8fCAhaXNNb3VzZVRyaWdnZXJlZCkpIHtcbiAgICAgICAgICAgIGhhbmRsZVBvaW50ZXJEb3duKHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBoYW5kbGVJZCxcbiAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgb25Db25uZWN0OiBvbkNvbm5lY3RFeHRlbmRlZCxcbiAgICAgICAgICAgICAgICBpc1RhcmdldCxcbiAgICAgICAgICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICAgICAgICAgICAgc2V0U3RhdGU6IHN0b3JlLnNldFN0YXRlLFxuICAgICAgICAgICAgICAgIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvbiB8fCBzdG9yZS5nZXRTdGF0ZSgpLmlzVmFsaWRDb25uZWN0aW9uIHx8IGFsd2F5c1ZhbGlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTW91c2VUcmlnZ2VyZWQpIHtcbiAgICAgICAgICAgIG9uTW91c2VEb3duPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0Py4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbkNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25DbGlja0Nvbm5lY3RTdGFydCwgb25DbGlja0Nvbm5lY3RFbmQsIGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLCBjb25uZWN0aW9uTW9kZSwgaXNWYWxpZENvbm5lY3Rpb246IGlzVmFsaWRDb25uZWN0aW9uU3RvcmUsIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIW5vZGVJZCB8fCAoIWNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlICYmICFpc0Nvbm5lY3RhYmxlU3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSkge1xuICAgICAgICAgICAgb25DbGlja0Nvbm5lY3RTdGFydD8uKGV2ZW50LCB7IG5vZGVJZCwgaGFuZGxlSWQsIGhhbmRsZVR5cGU6IHR5cGUgfSk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlOiB7IG5vZGVJZCwgdHlwZSwgaGFuZGxlSWQgfSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb2MgPSBnZXRIb3N0Rm9yRWxlbWVudChldmVudC50YXJnZXQpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkQ29ubmVjdGlvbkhhbmRsZXIgPSBpc1ZhbGlkQ29ubmVjdGlvbiB8fCBpc1ZhbGlkQ29ubmVjdGlvblN0b3JlIHx8IGFsd2F5c1ZhbGlkO1xuICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb24sIGlzVmFsaWQgfSA9IGlzVmFsaWRIYW5kbGUoe1xuICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgaWQ6IGhhbmRsZUlkLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgfSwgY29ubmVjdGlvbk1vZGUsIGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLm5vZGVJZCwgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUuaGFuZGxlSWQgfHwgbnVsbCwgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUudHlwZSwgaXNWYWxpZENvbm5lY3Rpb25IYW5kbGVyLCBkb2MpO1xuICAgICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgb25Db25uZWN0RXh0ZW5kZWQoY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgb25DbGlja0Nvbm5lY3RFbmQ/LihldmVudCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IG51bGwgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtaGFuZGxlaWRcIjogaGFuZGxlSWQsIFwiZGF0YS1ub2RlaWRcIjogbm9kZUlkLCBcImRhdGEtaGFuZGxlcG9zXCI6IHBvc2l0aW9uLCBcImRhdGEtaWRcIjogYCR7bm9kZUlkfS0ke2hhbmRsZUlkfS0ke3R5cGV9YCwgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAncmVhY3QtZmxvd19faGFuZGxlJyxcbiAgICAgICAgICAgIGByZWFjdC1mbG93X19oYW5kbGUtJHtwb3NpdGlvbn1gLFxuICAgICAgICAgICAgJ25vZHJhZycsXG4gICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICFpc1RhcmdldCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGlzVGFyZ2V0LFxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlc3RhcnQ6IGlzQ29ubmVjdGFibGVTdGFydCxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZWVuZDogaXNDb25uZWN0YWJsZUVuZCxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW5nOiBjbGlja0Nvbm5lY3RpbmcsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjbGFzcyBpcyB1c2VkIHRvIHN0eWxlIHRoZSBoYW5kbGUgd2hlbiB0aGUgdXNlciBpcyBjb25uZWN0aW5nXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbmluZGljYXRvcjogaXNDb25uZWN0YWJsZSAmJiAoKGlzQ29ubmVjdGFibGVTdGFydCAmJiAhY29ubmVjdGluZykgfHwgKGlzQ29ubmVjdGFibGVFbmQgJiYgY29ubmVjdGluZykpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSksIG9uTW91c2VEb3duOiBvblBvaW50ZXJEb3duLCBvblRvdWNoU3RhcnQ6IG9uUG9pbnRlckRvd24sIG9uQ2xpY2s6IGNvbm5lY3RPbkNsaWNrID8gb25DbGljayA6IHVuZGVmaW5lZCwgcmVmOiByZWYsIC4uLnJlc3QgfSwgY2hpbGRyZW4pKTtcbn0pO1xuSGFuZGxlLmRpc3BsYXlOYW1lID0gJ0hhbmRsZSc7XG52YXIgSGFuZGxlJDEgPSBtZW1vKEhhbmRsZSk7XG5cbmNvbnN0IERlZmF1bHROb2RlID0gKHsgZGF0YSwgaXNDb25uZWN0YWJsZSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB9KSA9PiB7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEhhbmRsZSQxLCB7IHR5cGU6IFwidGFyZ2V0XCIsIHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KSxcbiAgICAgICAgZGF0YT8ubGFiZWwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGFuZGxlJDEsIHsgdHlwZTogXCJzb3VyY2VcIiwgcG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pKSk7XG59O1xuRGVmYXVsdE5vZGUuZGlzcGxheU5hbWUgPSAnRGVmYXVsdE5vZGUnO1xudmFyIERlZmF1bHROb2RlJDEgPSBtZW1vKERlZmF1bHROb2RlKTtcblxuY29uc3QgSW5wdXROb2RlID0gKHsgZGF0YSwgaXNDb25uZWN0YWJsZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20gfSkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgZGF0YT8ubGFiZWwsXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChIYW5kbGUkMSwgeyB0eXBlOiBcInNvdXJjZVwiLCBwb3NpdGlvbjogc291cmNlUG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSkpKTtcbklucHV0Tm9kZS5kaXNwbGF5TmFtZSA9ICdJbnB1dE5vZGUnO1xudmFyIElucHV0Tm9kZSQxID0gbWVtbyhJbnB1dE5vZGUpO1xuXG5jb25zdCBPdXRwdXROb2RlID0gKHsgZGF0YSwgaXNDb25uZWN0YWJsZSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AgfSkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChIYW5kbGUkMSwgeyB0eXBlOiBcInRhcmdldFwiLCBwb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSksXG4gICAgZGF0YT8ubGFiZWwpKTtcbk91dHB1dE5vZGUuZGlzcGxheU5hbWUgPSAnT3V0cHV0Tm9kZSc7XG52YXIgT3V0cHV0Tm9kZSQxID0gbWVtbyhPdXRwdXROb2RlKTtcblxuY29uc3QgR3JvdXBOb2RlID0gKCkgPT4gbnVsbDtcbkdyb3VwTm9kZS5kaXNwbGF5TmFtZSA9ICdHcm91cE5vZGUnO1xuXG5jb25zdCBzZWxlY3RvciRlID0gKHMpID0+ICh7XG4gICAgc2VsZWN0ZWROb2Rlczogcy5nZXROb2RlcygpLmZpbHRlcigobikgPT4gbi5zZWxlY3RlZCksXG4gICAgc2VsZWN0ZWRFZGdlczogcy5lZGdlcy5maWx0ZXIoKGUpID0+IGUuc2VsZWN0ZWQpLFxufSk7XG5jb25zdCBzZWxlY3RJZCA9IChvYmopID0+IG9iai5pZDtcbmZ1bmN0aW9uIGFyZUVxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gKHNoYWxsb3coYS5zZWxlY3RlZE5vZGVzLm1hcChzZWxlY3RJZCksIGIuc2VsZWN0ZWROb2Rlcy5tYXAoc2VsZWN0SWQpKSAmJlxuICAgICAgICBzaGFsbG93KGEuc2VsZWN0ZWRFZGdlcy5tYXAoc2VsZWN0SWQpLCBiLnNlbGVjdGVkRWRnZXMubWFwKHNlbGVjdElkKSkpO1xufVxuLy8gVGhpcyBpcyBqdXN0IGEgaGVscGVyIGNvbXBvbmVudCBmb3IgY2FsbGluZyB0aGUgb25TZWxlY3Rpb25DaGFuZ2UgbGlzdGVuZXIuXG4vLyBAVE9ETzogTm93IHRoYXQgd2UgaGF2ZSB0aGUgb25Ob2Rlc0NoYW5nZSBhbmQgb24gRWRnZXNDaGFuZ2UgbGlzdGVuZXJzLCBkbyB3ZSBzdGlsbCBuZWVkIHRoaXMgY29tcG9uZW50P1xuY29uc3QgU2VsZWN0aW9uTGlzdGVuZXIgPSBtZW1vKCh7IG9uU2VsZWN0aW9uQ2hhbmdlIH0pID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyBzZWxlY3RlZE5vZGVzLCBzZWxlY3RlZEVkZ2VzIH0gPSB1c2VTdG9yZShzZWxlY3RvciRlLCBhcmVFcXVhbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0geyBub2Rlczogc2VsZWN0ZWROb2RlcywgZWRnZXM6IHNlbGVjdGVkRWRnZXMgfTtcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2U/LihwYXJhbXMpO1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlLmZvckVhY2goKGZuKSA9PiBmbihwYXJhbXMpKTtcbiAgICB9LCBbc2VsZWN0ZWROb2Rlcywgc2VsZWN0ZWRFZGdlcywgb25TZWxlY3Rpb25DaGFuZ2VdKTtcbiAgICByZXR1cm4gbnVsbDtcbn0pO1xuU2VsZWN0aW9uTGlzdGVuZXIuZGlzcGxheU5hbWUgPSAnU2VsZWN0aW9uTGlzdGVuZXInO1xuY29uc3QgY2hhbmdlU2VsZWN0b3IgPSAocykgPT4gISFzLm9uU2VsZWN0aW9uQ2hhbmdlO1xuZnVuY3Rpb24gV3JhcHBlciQxKHsgb25TZWxlY3Rpb25DaGFuZ2UgfSkge1xuICAgIGNvbnN0IHN0b3JlSGFzU2VsZWN0aW9uQ2hhbmdlID0gdXNlU3RvcmUoY2hhbmdlU2VsZWN0b3IpO1xuICAgIGlmIChvblNlbGVjdGlvbkNoYW5nZSB8fCBzdG9yZUhhc1NlbGVjdGlvbkNoYW5nZSkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChTZWxlY3Rpb25MaXN0ZW5lciwgeyBvblNlbGVjdGlvbkNoYW5nZTogb25TZWxlY3Rpb25DaGFuZ2UgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBzZWxlY3RvciRkID0gKHMpID0+ICh7XG4gICAgc2V0Tm9kZXM6IHMuc2V0Tm9kZXMsXG4gICAgc2V0RWRnZXM6IHMuc2V0RWRnZXMsXG4gICAgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXM6IHMuc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMsXG4gICAgc2V0TWluWm9vbTogcy5zZXRNaW5ab29tLFxuICAgIHNldE1heFpvb206IHMuc2V0TWF4Wm9vbSxcbiAgICBzZXRUcmFuc2xhdGVFeHRlbnQ6IHMuc2V0VHJhbnNsYXRlRXh0ZW50LFxuICAgIHNldE5vZGVFeHRlbnQ6IHMuc2V0Tm9kZUV4dGVudCxcbiAgICByZXNldDogcy5yZXNldCxcbn0pO1xuZnVuY3Rpb24gdXNlU3RvcmVVcGRhdGVyKHZhbHVlLCBzZXRTdG9yZVN0YXRlKSB7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHNldFN0b3JlU3RhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgW3ZhbHVlXSk7XG59XG4vLyB1cGRhdGVzIHdpdGggdmFsdWVzIGluIHN0b3JlIHRoYXQgZG9uJ3QgaGF2ZSBhIGRlZGljYXRlZCBzZXR0ZXIgZnVuY3Rpb25cbmZ1bmN0aW9uIHVzZURpcmVjdFN0b3JlVXBkYXRlcihrZXksIHZhbHVlLCBzZXRTdGF0ZSkge1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7IFtrZXldOiB2YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgIH0sIFt2YWx1ZV0pO1xufVxuY29uc3QgU3RvcmVVcGRhdGVyID0gKHsgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgb25Db25uZWN0LCBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kLCBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBvbkNsaWNrQ29ubmVjdEVuZCwgbm9kZXNEcmFnZ2FibGUsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNVcGRhdGFibGUsIGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBtaW5ab29tLCBtYXhab29tLCBub2RlRXh0ZW50LCBvbk5vZGVzQ2hhbmdlLCBvbkVkZ2VzQ2hhbmdlLCBlbGVtZW50c1NlbGVjdGFibGUsIGNvbm5lY3Rpb25Nb2RlLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgdHJhbnNsYXRlRXh0ZW50LCBjb25uZWN0T25DbGljaywgZGVmYXVsdEVkZ2VPcHRpb25zLCBmaXRWaWV3LCBmaXRWaWV3T3B0aW9ucywgb25Ob2Rlc0RlbGV0ZSwgb25FZGdlc0RlbGV0ZSwgb25Ob2RlRHJhZywgb25Ob2RlRHJhZ1N0YXJ0LCBvbk5vZGVEcmFnU3RvcCwgb25TZWxlY3Rpb25EcmFnLCBvblNlbGVjdGlvbkRyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnU3RvcCwgbm9QYW5DbGFzc05hbWUsIG5vZGVPcmlnaW4sIHJmSWQsIGF1dG9QYW5PbkNvbm5lY3QsIGF1dG9QYW5Pbk5vZGVEcmFnLCBvbkVycm9yLCBjb25uZWN0aW9uUmFkaXVzLCBpc1ZhbGlkQ29ubmVjdGlvbiwgbm9kZURyYWdUaHJlc2hvbGQsIH0pID0+IHtcbiAgICBjb25zdCB7IHNldE5vZGVzLCBzZXRFZGdlcywgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMsIHNldE1pblpvb20sIHNldE1heFpvb20sIHNldFRyYW5zbGF0ZUV4dGVudCwgc2V0Tm9kZUV4dGVudCwgcmVzZXQsIH0gPSB1c2VTdG9yZShzZWxlY3RvciRkLCBzaGFsbG93KTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZWRnZXNXaXRoRGVmYXVsdHMgPSBkZWZhdWx0RWRnZXM/Lm1hcCgoZSkgPT4gKHsgLi4uZSwgLi4uZGVmYXVsdEVkZ2VPcHRpb25zIH0pKTtcbiAgICAgICAgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMoZGVmYXVsdE5vZGVzLCBlZGdlc1dpdGhEZWZhdWx0cyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ2RlZmF1bHRFZGdlT3B0aW9ucycsIGRlZmF1bHRFZGdlT3B0aW9ucywgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignY29ubmVjdGlvbk1vZGUnLCBjb25uZWN0aW9uTW9kZSwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignb25Db25uZWN0Jywgb25Db25uZWN0LCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvbkNvbm5lY3RTdGFydCcsIG9uQ29ubmVjdFN0YXJ0LCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvbkNvbm5lY3RFbmQnLCBvbkNvbm5lY3RFbmQsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ29uQ2xpY2tDb25uZWN0U3RhcnQnLCBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvbkNsaWNrQ29ubmVjdEVuZCcsIG9uQ2xpY2tDb25uZWN0RW5kLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdub2Rlc0RyYWdnYWJsZScsIG5vZGVzRHJhZ2dhYmxlLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdub2Rlc0Nvbm5lY3RhYmxlJywgbm9kZXNDb25uZWN0YWJsZSwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignbm9kZXNGb2N1c2FibGUnLCBub2Rlc0ZvY3VzYWJsZSwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignZWRnZXNGb2N1c2FibGUnLCBlZGdlc0ZvY3VzYWJsZSwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignZWRnZXNVcGRhdGFibGUnLCBlZGdlc1VwZGF0YWJsZSwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignZWxlbWVudHNTZWxlY3RhYmxlJywgZWxlbWVudHNTZWxlY3RhYmxlLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdlbGV2YXRlTm9kZXNPblNlbGVjdCcsIGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdzbmFwVG9HcmlkJywgc25hcFRvR3JpZCwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignc25hcEdyaWQnLCBzbmFwR3JpZCwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignb25Ob2Rlc0NoYW5nZScsIG9uTm9kZXNDaGFuZ2UsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ29uRWRnZXNDaGFuZ2UnLCBvbkVkZ2VzQ2hhbmdlLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdjb25uZWN0T25DbGljaycsIGNvbm5lY3RPbkNsaWNrLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdmaXRWaWV3T25Jbml0JywgZml0Vmlldywgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignZml0Vmlld09uSW5pdE9wdGlvbnMnLCBmaXRWaWV3T3B0aW9ucywgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignb25Ob2Rlc0RlbGV0ZScsIG9uTm9kZXNEZWxldGUsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ29uRWRnZXNEZWxldGUnLCBvbkVkZ2VzRGVsZXRlLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvbk5vZGVEcmFnJywgb25Ob2RlRHJhZywgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignb25Ob2RlRHJhZ1N0YXJ0Jywgb25Ob2RlRHJhZ1N0YXJ0LCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvbk5vZGVEcmFnU3RvcCcsIG9uTm9kZURyYWdTdG9wLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvblNlbGVjdGlvbkRyYWcnLCBvblNlbGVjdGlvbkRyYWcsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ29uU2VsZWN0aW9uRHJhZ1N0YXJ0Jywgb25TZWxlY3Rpb25EcmFnU3RhcnQsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ29uU2VsZWN0aW9uRHJhZ1N0b3AnLCBvblNlbGVjdGlvbkRyYWdTdG9wLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdub1BhbkNsYXNzTmFtZScsIG5vUGFuQ2xhc3NOYW1lLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdub2RlT3JpZ2luJywgbm9kZU9yaWdpbiwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcigncmZJZCcsIHJmSWQsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ2F1dG9QYW5PbkNvbm5lY3QnLCBhdXRvUGFuT25Db25uZWN0LCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdhdXRvUGFuT25Ob2RlRHJhZycsIGF1dG9QYW5Pbk5vZGVEcmFnLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvbkVycm9yJywgb25FcnJvciwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignY29ubmVjdGlvblJhZGl1cycsIGNvbm5lY3Rpb25SYWRpdXMsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ2lzVmFsaWRDb25uZWN0aW9uJywgaXNWYWxpZENvbm5lY3Rpb24sIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ25vZGVEcmFnVGhyZXNob2xkJywgbm9kZURyYWdUaHJlc2hvbGQsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VTdG9yZVVwZGF0ZXIobm9kZXMsIHNldE5vZGVzKTtcbiAgICB1c2VTdG9yZVVwZGF0ZXIoZWRnZXMsIHNldEVkZ2VzKTtcbiAgICB1c2VTdG9yZVVwZGF0ZXIobWluWm9vbSwgc2V0TWluWm9vbSk7XG4gICAgdXNlU3RvcmVVcGRhdGVyKG1heFpvb20sIHNldE1heFpvb20pO1xuICAgIHVzZVN0b3JlVXBkYXRlcih0cmFuc2xhdGVFeHRlbnQsIHNldFRyYW5zbGF0ZUV4dGVudCk7XG4gICAgdXNlU3RvcmVVcGRhdGVyKG5vZGVFeHRlbnQsIHNldE5vZGVFeHRlbnQpO1xuICAgIHJldHVybiBudWxsO1xufTtcblxuY29uc3Qgc3R5bGUgPSB7IGRpc3BsYXk6ICdub25lJyB9O1xuY29uc3QgYXJpYUxpdmVTdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgbWFyZ2luOiAtMSxcbiAgICBib3JkZXI6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgY2xpcDogJ3JlY3QoMHB4LCAwcHgsIDBweCwgMHB4KScsXG4gICAgY2xpcFBhdGg6ICdpbnNldCgxMDAlKScsXG59O1xuY29uc3QgQVJJQV9OT0RFX0RFU0NfS0VZID0gJ3JlYWN0LWZsb3dfX25vZGUtZGVzYyc7XG5jb25zdCBBUklBX0VER0VfREVTQ19LRVkgPSAncmVhY3QtZmxvd19fZWRnZS1kZXNjJztcbmNvbnN0IEFSSUFfTElWRV9NRVNTQUdFID0gJ3JlYWN0LWZsb3dfX2FyaWEtbGl2ZSc7XG5jb25zdCBzZWxlY3RvciRjID0gKHMpID0+IHMuYXJpYUxpdmVNZXNzYWdlO1xuZnVuY3Rpb24gQXJpYUxpdmVNZXNzYWdlKHsgcmZJZCB9KSB7XG4gICAgY29uc3QgYXJpYUxpdmVNZXNzYWdlID0gdXNlU3RvcmUoc2VsZWN0b3IkYyk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgaWQ6IGAke0FSSUFfTElWRV9NRVNTQUdFfS0ke3JmSWR9YCwgXCJhcmlhLWxpdmVcIjogXCJhc3NlcnRpdmVcIiwgXCJhcmlhLWF0b21pY1wiOiBcInRydWVcIiwgc3R5bGU6IGFyaWFMaXZlU3R5bGUgfSwgYXJpYUxpdmVNZXNzYWdlKSk7XG59XG5mdW5jdGlvbiBBMTF5RGVzY3JpcHRpb25zKHsgcmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeSB9KSB7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgaWQ6IGAke0FSSUFfTk9ERV9ERVNDX0tFWX0tJHtyZklkfWAsIHN0eWxlOiBzdHlsZSB9LFxuICAgICAgICAgICAgXCJQcmVzcyBlbnRlciBvciBzcGFjZSB0byBzZWxlY3QgYSBub2RlLlwiLFxuICAgICAgICAgICAgIWRpc2FibGVLZXlib2FyZEExMXkgJiYgJ1lvdSBjYW4gdGhlbiB1c2UgdGhlIGFycm93IGtleXMgdG8gbW92ZSB0aGUgbm9kZSBhcm91bmQuJyxcbiAgICAgICAgICAgIFwiIFByZXNzIGRlbGV0ZSB0byByZW1vdmUgaXQgYW5kIGVzY2FwZSB0byBjYW5jZWwuXCIsXG4gICAgICAgICAgICAnICcpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgaWQ6IGAke0FSSUFfRURHRV9ERVNDX0tFWX0tJHtyZklkfWAsIHN0eWxlOiBzdHlsZSB9LCBcIlByZXNzIGVudGVyIG9yIHNwYWNlIHRvIHNlbGVjdCBhbiBlZGdlLiBZb3UgY2FuIHRoZW4gcHJlc3MgZGVsZXRlIHRvIHJlbW92ZSBpdCBvciBlc2NhcGUgdG8gY2FuY2VsLlwiKSxcbiAgICAgICAgIWRpc2FibGVLZXlib2FyZEExMXkgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChBcmlhTGl2ZU1lc3NhZ2UsIHsgcmZJZDogcmZJZCB9KSkpO1xufVxuXG4vLyB0aGUga2V5Y29kZSBjYW4gYmUgYSBzdHJpbmcgJ2EnIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgWydhJywgJ2ErZCddXG4vLyBhIHN0cmluZyBtZWFucyBhIHNpbmdsZSBrZXkgJ2EnIG9yIGEgY29tYmluYXRpb24gd2hlbiAnKycgaXMgdXNlZCAnYStkJ1xuLy8gYW4gYXJyYXkgbWVhbnMgZGlmZmVyZW50IHBvc3NpYmlsaXRpZXMuIEV4cGxhaW5lcjogWydhJywgJ2QrcyddIGhlcmUgdGhlXG4vLyB1c2VyIGNhbiB1c2UgdGhlIHNpbmdsZSBrZXkgJ2EnIG9yIHRoZSBjb21iaW5hdGlvbiAnZCcgKyAncydcbnZhciB1c2VLZXlQcmVzcyA9IChrZXlDb2RlID0gbnVsbCwgb3B0aW9ucyA9IHsgYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXI6IHRydWUgfSkgPT4ge1xuICAgIGNvbnN0IFtrZXlQcmVzc2VkLCBzZXRLZXlQcmVzc2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAvLyB3ZSBuZWVkIHRvIHJlbWVtYmVyIGlmIGEgbW9kaWZpZXIga2V5IGlzIHByZXNzZWQgaW4gb3JkZXIgdG8gdHJhY2sgaXRcbiAgICBjb25zdCBtb2RpZmllclByZXNzZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHByZXNzZWQga2V5cyBpbiBvcmRlciB0byBzdXBwb3J0IGNvbWJpbmF0aW9uc1xuICAgIGNvbnN0IHByZXNzZWRLZXlzID0gdXNlUmVmKG5ldyBTZXQoW10pKTtcbiAgICAvLyBrZXlDb2RlcyA9IGFycmF5IHdpdGggc2luZ2xlIGtleXMgW1snYSddXSBvciBrZXkgY29tYmluYXRpb25zIFtbJ2EnLCAncyddXVxuICAgIC8vIGtleXNUb1dhdGNoID0gYXJyYXkgd2l0aCBhbGwga2V5cyBmbGF0dGVuZWQgWydhJywgJ2QnLCAnU2hpZnRMZWZ0J11cbiAgICAvLyB1c2VkIHRvIGNoZWNrIGlmIHdlIHN0b3JlIGV2ZW50LmNvZGUgb3IgZXZlbnQua2V5LiBXaGVuIHRoZSBjb2RlIGlzIGluIHRoZSBsaXN0IG9mIGtleXNUb1dhdGNoXG4gICAgLy8gd2UgdXNlIHRoZSBjb2RlIG90aGVyd2lzZSB0aGUga2V5LiBFeHBsYWluZXI6IFdoZW4geW91IHByZXNzIHRoZSBsZWZ0IFwiY29tbWFuZFwiIGtleSwgdGhlIGNvZGUgaXMgXCJNZXRhTGVmdFwiXG4gICAgLy8gYW5kIHRoZSBrZXkgaXMgXCJNZXRhXCIuIFdlIHdhbnQgdXNlcnMgdG8gYmUgYWJsZSB0byBwYXNzIGtleXMgYW5kIGNvZGVzIHNvIHdlIGFzc3VtZSB0aGF0IHRoZSBrZXkgaXMgbWVhbnQgd2hlblxuICAgIC8vIHdlIGNhbid0IGZpbmQgaXQgaW4gdGhlIGxpc3Qgb2Yga2V5c1RvV2F0Y2guXG4gICAgY29uc3QgW2tleUNvZGVzLCBrZXlzVG9XYXRjaF0gPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGtleUNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleUNvZGVBcnIgPSBBcnJheS5pc0FycmF5KGtleUNvZGUpID8ga2V5Q29kZSA6IFtrZXlDb2RlXTtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBrZXlDb2RlQXJyLmZpbHRlcigoa2MpID0+IHR5cGVvZiBrYyA9PT0gJ3N0cmluZycpLm1hcCgoa2MpID0+IGtjLnNwbGl0KCcrJykpO1xuICAgICAgICAgICAgY29uc3Qga2V5c0ZsYXQgPSBrZXlzLnJlZHVjZSgocmVzLCBpdGVtKSA9PiByZXMuY29uY2F0KC4uLml0ZW0pLCBbXSk7XG4gICAgICAgICAgICByZXR1cm4gW2tleXMsIGtleXNGbGF0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1tdLCBbXV07XG4gICAgfSwgW2tleUNvZGVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBvcHRpb25zPy50YXJnZXQgfHwgZG9jO1xuICAgICAgICBpZiAoa2V5Q29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZG93bkhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBtb2RpZmllclByZXNzZWQuY3VycmVudCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ZW50QWN0aW9uID0gKCFtb2RpZmllclByZXNzZWQuY3VycmVudCB8fCAobW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgJiYgIW9wdGlvbnMuYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXIpKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0lucHV0RE9NTm9kZShldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZlbnRBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBrZXlPckNvZGUgPSB1c2VLZXlPckNvZGUoZXZlbnQuY29kZSwga2V5c1RvV2F0Y2gpO1xuICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuYWRkKGV2ZW50W2tleU9yQ29kZV0pO1xuICAgICAgICAgICAgICAgIGlmIChpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cy5jdXJyZW50LCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdXBIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmVudEFjdGlvbiA9ICghbW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgfHwgKG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50ICYmICFvcHRpb25zLmFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNJbnB1dERPTU5vZGUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ZW50QWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5T3JDb2RlID0gdXNlS2V5T3JDb2RlKGV2ZW50LmNvZGUsIGtleXNUb1dhdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGluZ0tleShrZXlDb2RlcywgcHJlc3NlZEtleXMuY3VycmVudCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuZGVsZXRlKGV2ZW50W2tleU9yQ29kZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmaXggZm9yIE1hYzogd2hlbiBjbWQga2V5IGlzIHByZXNzZWQsIGtleXVwIGlzIG5vdCB0cmlnZ2VyZWQgZm9yIGFueSBvdGhlciBrZXksIHNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjczODAwMTgvd2hlbi1jbWQta2V5LWlzLWtlcHQtcHJlc3NlZC1rZXl1cC1pcy1ub3QtdHJpZ2dlcmVkLWZvci1hbnktb3RoZXIta2V5XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ01ldGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNldEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHNldEtleVByZXNzZWQoZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRhcmdldD8uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGRvd25IYW5kbGVyKTtcbiAgICAgICAgICAgIHRhcmdldD8uYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cEhhbmRsZXIpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Py5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtrZXlDb2RlLCBzZXRLZXlQcmVzc2VkXSk7XG4gICAgcmV0dXJuIGtleVByZXNzZWQ7XG59O1xuLy8gdXRpbHNcbmZ1bmN0aW9uIGlzTWF0Y2hpbmdLZXkoa2V5Q29kZXMsIHByZXNzZWRLZXlzLCBpc1VwKSB7XG4gICAgcmV0dXJuIChrZXlDb2Rlc1xuICAgICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gY29tcGFyZSBzYW1lIHNpemVzIG9mIGtleUNvZGUgZGVmaW5pdGlvbnNcbiAgICAgICAgLy8gYW5kIHByZXNzZWQga2V5cy4gV2hlbiB0aGUgdXNlciBzcGVjaWZpZWQgJ01ldGEnIGFzIGEga2V5IHNvbWV3aGVyZVxuICAgICAgICAvLyB0aGlzIHdvdWxkIGFsc28gYmUgdHJ1dGh5IHdpdGhvdXQgdGhpcyBmaWx0ZXIgd2hlbiB1c2VyIHByZXNzZXMgJ01ldGEnICsgJ3InXG4gICAgICAgIC5maWx0ZXIoKGtleXMpID0+IGlzVXAgfHwga2V5cy5sZW5ndGggPT09IHByZXNzZWRLZXlzLnNpemUpXG4gICAgICAgIC8vIHNpbmNlIHdlIHdhbnQgdG8gc3VwcG9ydCBtdWx0aXBsZSBwb3NzaWJpbGl0aWVzIG9ubHkgb25lIG9mIHRoZVxuICAgICAgICAvLyBjb21iaW5hdGlvbnMgbmVlZCB0byBiZSBwYXJ0IG9mIHRoZSBwcmVzc2VkIGtleXNcbiAgICAgICAgLnNvbWUoKGtleXMpID0+IGtleXMuZXZlcnkoKGspID0+IHByZXNzZWRLZXlzLmhhcyhrKSkpKTtcbn1cbmZ1bmN0aW9uIHVzZUtleU9yQ29kZShldmVudENvZGUsIGtleXNUb1dhdGNoKSB7XG4gICAgcmV0dXJuIGtleXNUb1dhdGNoLmluY2x1ZGVzKGV2ZW50Q29kZSkgPyAnY29kZScgOiAna2V5Jztcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlWFlaUG9zaXRpb24obm9kZSwgbm9kZUludGVybmFscywgcmVzdWx0LCBub2RlT3JpZ2luKSB7XG4gICAgaWYgKCFub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGVJbnRlcm5hbHMuZ2V0KG5vZGUucGFyZW50Tm9kZSk7XG4gICAgY29uc3QgcGFyZW50Tm9kZVBvc2l0aW9uID0gZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihwYXJlbnROb2RlLCBub2RlT3JpZ2luKTtcbiAgICByZXR1cm4gY2FsY3VsYXRlWFlaUG9zaXRpb24ocGFyZW50Tm9kZSwgbm9kZUludGVybmFscywge1xuICAgICAgICB4OiAocmVzdWx0LnggPz8gMCkgKyBwYXJlbnROb2RlUG9zaXRpb24ueCxcbiAgICAgICAgeTogKHJlc3VsdC55ID8/IDApICsgcGFyZW50Tm9kZVBvc2l0aW9uLnksXG4gICAgICAgIHo6IChwYXJlbnROb2RlW2ludGVybmFsc1N5bWJvbF0/LnogPz8gMCkgPiAocmVzdWx0LnogPz8gMCkgPyBwYXJlbnROb2RlW2ludGVybmFsc1N5bWJvbF0/LnogPz8gMCA6IHJlc3VsdC56ID8/IDAsXG4gICAgfSwgbm9kZU9yaWdpbik7XG59XG5mdW5jdGlvbiB1cGRhdGVBYnNvbHV0ZU5vZGVQb3NpdGlvbnMobm9kZUludGVybmFscywgbm9kZU9yaWdpbiwgcGFyZW50Tm9kZXMpIHtcbiAgICBub2RlSW50ZXJuYWxzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiAhbm9kZUludGVybmFscy5oYXMobm9kZS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJlbnQgbm9kZSAke25vZGUucGFyZW50Tm9kZX0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSB8fCBwYXJlbnROb2Rlcz8uW25vZGUuaWRdKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHksIHogfSA9IGNhbGN1bGF0ZVhZWlBvc2l0aW9uKG5vZGUsIG5vZGVJbnRlcm5hbHMsIHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHo6IG5vZGVbaW50ZXJuYWxzU3ltYm9sXT8ueiA/PyAwLFxuICAgICAgICAgICAgfSwgbm9kZU9yaWdpbik7XG4gICAgICAgICAgICBub2RlLnBvc2l0aW9uQWJzb2x1dGUgPSB7XG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vZGVbaW50ZXJuYWxzU3ltYm9sXS56ID0gejtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2Rlcz8uW25vZGUuaWRdKSB7XG4gICAgICAgICAgICAgICAgbm9kZVtpbnRlcm5hbHNTeW1ib2xdLmlzUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTm9kZUludGVybmFscyhub2Rlcywgbm9kZUludGVybmFscywgbm9kZU9yaWdpbiwgZWxldmF0ZU5vZGVzT25TZWxlY3QpIHtcbiAgICBjb25zdCBuZXh0Tm9kZUludGVybmFscyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwYXJlbnROb2RlcyA9IHt9O1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZVogPSBlbGV2YXRlTm9kZXNPblNlbGVjdCA/IDEwMDAgOiAwO1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgeiA9IChpc051bWVyaWMobm9kZS56SW5kZXgpID8gbm9kZS56SW5kZXggOiAwKSArIChub2RlLnNlbGVjdGVkID8gc2VsZWN0ZWROb2RlWiA6IDApO1xuICAgICAgICBjb25zdCBjdXJySW50ZXJuYWxzID0gbm9kZUludGVybmFscy5nZXQobm9kZS5pZCk7XG4gICAgICAgIGNvbnN0IGludGVybmFscyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBjdXJySW50ZXJuYWxzPy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY3VyckludGVybmFscz8uaGVpZ2h0LFxuICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGU6IHtcbiAgICAgICAgICAgICAgICB4OiBub2RlLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgeTogbm9kZS5wb3NpdGlvbi55LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgaW50ZXJuYWxzLnBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBwYXJlbnROb2Rlc1tub2RlLnBhcmVudE5vZGVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW50ZXJuYWxzLCBpbnRlcm5hbHNTeW1ib2wsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVCb3VuZHM6IGN1cnJJbnRlcm5hbHM/LltpbnRlcm5hbHNTeW1ib2xdPy5oYW5kbGVCb3VuZHMsXG4gICAgICAgICAgICAgICAgeixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBuZXh0Tm9kZUludGVybmFscy5zZXQobm9kZS5pZCwgaW50ZXJuYWxzKTtcbiAgICB9KTtcbiAgICB1cGRhdGVBYnNvbHV0ZU5vZGVQb3NpdGlvbnMobmV4dE5vZGVJbnRlcm5hbHMsIG5vZGVPcmlnaW4sIHBhcmVudE5vZGVzKTtcbiAgICByZXR1cm4gbmV4dE5vZGVJbnRlcm5hbHM7XG59XG5mdW5jdGlvbiBmaXRWaWV3KGdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBnZXROb2Rlcywgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgZDNab29tLCBkM1NlbGVjdGlvbiwgZml0Vmlld09uSW5pdERvbmUsIGZpdFZpZXdPbkluaXQsIG5vZGVPcmlnaW4sIH0gPSBnZXQoKTtcbiAgICBjb25zdCBpc0luaXRpYWxGaXRWaWV3ID0gb3B0aW9ucy5pbml0aWFsICYmICFmaXRWaWV3T25Jbml0RG9uZSAmJiBmaXRWaWV3T25Jbml0O1xuICAgIGNvbnN0IGQzaW5pdGlhbGl6ZWQgPSBkM1pvb20gJiYgZDNTZWxlY3Rpb247XG4gICAgaWYgKGQzaW5pdGlhbGl6ZWQgJiYgKGlzSW5pdGlhbEZpdFZpZXcgfHwgIW9wdGlvbnMuaW5pdGlhbCkpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBnZXROb2RlcygpLmZpbHRlcigobikgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSGlkZGVuTm9kZXMgPyBuLndpZHRoICYmIG4uaGVpZ2h0IDogIW4uaGlkZGVuO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubm9kZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1Zpc2libGUgJiYgb3B0aW9ucy5ub2Rlcy5zb21lKChvcHRpb25Ob2RlKSA9PiBvcHRpb25Ob2RlLmlkID09PSBuLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1Zpc2libGU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBub2Rlc0luaXRpYWxpemVkID0gbm9kZXMuZXZlcnkoKG4pID0+IG4ud2lkdGggJiYgbi5oZWlnaHQpO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCAmJiBub2Rlc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBjb25zdCBib3VuZHMgPSBnZXROb2Rlc0JvdW5kcyhub2Rlcywgbm9kZU9yaWdpbik7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHksIHpvb20gfSA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucy5taW5ab29tID8/IG1pblpvb20sIG9wdGlvbnMubWF4Wm9vbSA/PyBtYXhab29tLCBvcHRpb25zLnBhZGRpbmcgPz8gMC4xKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB6b29tSWRlbnRpdHkudHJhbnNsYXRlKHgsIHkpLnNjYWxlKHpvb20pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiBvcHRpb25zLmR1cmF0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIGQzWm9vbS50cmFuc2Zvcm0oZ2V0RDNUcmFuc2l0aW9uKGQzU2VsZWN0aW9uLCBvcHRpb25zLmR1cmF0aW9uKSwgbmV4dFRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkM1pvb20udHJhbnNmb3JtKGQzU2VsZWN0aW9uLCBuZXh0VHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWROb2RlU2VsZWN0aW9uQ2hhbmdlKG5vZGVDaGFuZ2VzLCBub2RlSW50ZXJuYWxzKSB7XG4gICAgbm9kZUNoYW5nZXMuZm9yRWFjaCgoY2hhbmdlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2RlSW50ZXJuYWxzLmdldChjaGFuZ2UuaWQpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZUludGVybmFscy5zZXQobm9kZS5pZCwge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgW2ludGVybmFsc1N5bWJvbF06IG5vZGVbaW50ZXJuYWxzU3ltYm9sXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogY2hhbmdlLnNlbGVjdGVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IE1hcChub2RlSW50ZXJuYWxzKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWRFZGdlU2VsZWN0aW9uQ2hhbmdlKGVkZ2VDaGFuZ2VzLCBlZGdlcykge1xuICAgIHJldHVybiBlZGdlcy5tYXAoKGUpID0+IHtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gZWRnZUNoYW5nZXMuZmluZCgoY2hhbmdlKSA9PiBjaGFuZ2UuaWQgPT09IGUuaWQpO1xuICAgICAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgICAgICBlLnNlbGVjdGVkID0gY2hhbmdlLnNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlTm9kZXNBbmRFZGdlc1NlbGVjdGlvbnMoeyBjaGFuZ2VkTm9kZXMsIGNoYW5nZWRFZGdlcywgZ2V0LCBzZXQgfSkge1xuICAgIGNvbnN0IHsgbm9kZUludGVybmFscywgZWRnZXMsIG9uTm9kZXNDaGFuZ2UsIG9uRWRnZXNDaGFuZ2UsIGhhc0RlZmF1bHROb2RlcywgaGFzRGVmYXVsdEVkZ2VzIH0gPSBnZXQoKTtcbiAgICBpZiAoY2hhbmdlZE5vZGVzPy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgc2V0KHsgbm9kZUludGVybmFsczogaGFuZGxlQ29udHJvbGxlZE5vZGVTZWxlY3Rpb25DaGFuZ2UoY2hhbmdlZE5vZGVzLCBub2RlSW50ZXJuYWxzKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBvbk5vZGVzQ2hhbmdlPy4oY2hhbmdlZE5vZGVzKTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZWRFZGdlcz8ubGVuZ3RoKSB7XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIHNldCh7IGVkZ2VzOiBoYW5kbGVDb250cm9sbGVkRWRnZVNlbGVjdGlvbkNoYW5nZShjaGFuZ2VkRWRnZXMsIGVkZ2VzKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBvbkVkZ2VzQ2hhbmdlPy4oY2hhbmdlZEVkZ2VzKTtcbiAgICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG5jb25zdCBpbml0aWFsVmlld3BvcnRIZWxwZXIgPSB7XG4gICAgem9vbUluOiBub29wLFxuICAgIHpvb21PdXQ6IG5vb3AsXG4gICAgem9vbVRvOiBub29wLFxuICAgIGdldFpvb206ICgpID0+IDEsXG4gICAgc2V0Vmlld3BvcnQ6IG5vb3AsXG4gICAgZ2V0Vmlld3BvcnQ6ICgpID0+ICh7IHg6IDAsIHk6IDAsIHpvb206IDEgfSksXG4gICAgZml0VmlldzogKCkgPT4gZmFsc2UsXG4gICAgc2V0Q2VudGVyOiBub29wLFxuICAgIGZpdEJvdW5kczogbm9vcCxcbiAgICBwcm9qZWN0OiAocG9zaXRpb24pID0+IHBvc2l0aW9uLFxuICAgIHNjcmVlblRvRmxvd1Bvc2l0aW9uOiAocG9zaXRpb24pID0+IHBvc2l0aW9uLFxuICAgIGZsb3dUb1NjcmVlblBvc2l0aW9uOiAocG9zaXRpb24pID0+IHBvc2l0aW9uLFxuICAgIHZpZXdwb3J0SW5pdGlhbGl6ZWQ6IGZhbHNlLFxufTtcbmNvbnN0IHNlbGVjdG9yJGIgPSAocykgPT4gKHtcbiAgICBkM1pvb206IHMuZDNab29tLFxuICAgIGQzU2VsZWN0aW9uOiBzLmQzU2VsZWN0aW9uLFxufSk7XG5jb25zdCB1c2VWaWV3cG9ydEhlbHBlciA9ICgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyBkM1pvb20sIGQzU2VsZWN0aW9uIH0gPSB1c2VTdG9yZShzZWxlY3RvciRiLCBzaGFsbG93KTtcbiAgICBjb25zdCB2aWV3cG9ydEhlbHBlckZ1bmN0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24gJiYgZDNab29tKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHpvb21JbjogKG9wdGlvbnMpID0+IGQzWm9vbS5zY2FsZUJ5KGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24pLCAxLjIpLFxuICAgICAgICAgICAgICAgIHpvb21PdXQ6IChvcHRpb25zKSA9PiBkM1pvb20uc2NhbGVCeShnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uKSwgMSAvIDEuMiksXG4gICAgICAgICAgICAgICAgem9vbVRvOiAoem9vbUxldmVsLCBvcHRpb25zKSA9PiBkM1pvb20uc2NhbGVUbyhnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uKSwgem9vbUxldmVsKSxcbiAgICAgICAgICAgICAgICBnZXRab29tOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgICAgICAgICBzZXRWaWV3cG9ydDogKHRyYW5zZm9ybSwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbeCwgeSwgem9vbV0gPSBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFRyYW5zZm9ybSA9IHpvb21JZGVudGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zbGF0ZSh0cmFuc2Zvcm0ueCA/PyB4LCB0cmFuc2Zvcm0ueSA/PyB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHRyYW5zZm9ybS56b29tID8/IHpvb20pO1xuICAgICAgICAgICAgICAgICAgICBkM1pvb20udHJhbnNmb3JtKGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24pLCBuZXh0VHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFZpZXdwb3J0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFt4LCB5LCB6b29tXSA9IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5LCB6b29tIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmaXRWaWV3OiAob3B0aW9ucykgPT4gZml0VmlldyhzdG9yZS5nZXRTdGF0ZSwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgc2V0Q2VudGVyOiAoeCwgeSwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIG1heFpvb20gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRab29tID0gdHlwZW9mIG9wdGlvbnM/Lnpvb20gIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy56b29tIDogbWF4Wm9vbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHdpZHRoIC8gMiAtIHggKiBuZXh0Wm9vbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWSA9IGhlaWdodCAvIDIgLSB5ICogbmV4dFpvb207XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHpvb21JZGVudGl0eS50cmFuc2xhdGUoY2VudGVyWCwgY2VudGVyWSkuc2NhbGUobmV4dFpvb20pO1xuICAgICAgICAgICAgICAgICAgICBkM1pvb20udHJhbnNmb3JtKGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24pLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZml0Qm91bmRzOiAoYm91bmRzLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4LCB5LCB6b29tIH0gPSBnZXRWaWV3cG9ydEZvckJvdW5kcyhib3VuZHMsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20sIG9wdGlvbnM/LnBhZGRpbmcgPz8gMC4xKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gem9vbUlkZW50aXR5LnRyYW5zbGF0ZSh4LCB5KS5zY2FsZSh6b29tKTtcbiAgICAgICAgICAgICAgICAgICAgZDNab29tLnRyYW5zZm9ybShnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uKSwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEBkZXByZWNhdGVkIFVzZSBgc2NyZWVuVG9GbG93UG9zaXRpb25gLlxuICAgICAgICAgICAgICAgIHByb2plY3Q6IChwb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgc25hcFRvR3JpZCwgc25hcEdyaWQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW0RFUFJFQ0FURURdIGBwcm9qZWN0YCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHVzZSBgc2NyZWVuVG9GbG93UG9zaXRpb25gLiBUaGVyZSBpcyBubyBuZWVkIHRvIHN1YnRyYWN0IHRoZSByZWFjdCBmbG93IGJvdW5kcyBhbnltb3JlISBodHRwczovL3JlYWN0Zmxvdy5kZXYvYXBpLXJlZmVyZW5jZS90eXBlcy9yZWFjdC1mbG93LWluc3RhbmNlI3NjcmVlbi10by1mbG93LXBvc2l0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludFRvUmVuZGVyZXJQb2ludChwb3NpdGlvbiwgdHJhbnNmb3JtLCBzbmFwVG9HcmlkLCBzbmFwR3JpZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzY3JlZW5Ub0Zsb3dQb3NpdGlvbjogKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBzbmFwVG9HcmlkLCBzbmFwR3JpZCwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4OiBkb21YLCB5OiBkb21ZIH0gPSBkb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogcG9zaXRpb24ueCAtIGRvbVgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBwb3NpdGlvbi55IC0gZG9tWSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50VG9SZW5kZXJlclBvaW50KHJlbGF0aXZlUG9zaXRpb24sIHRyYW5zZm9ybSwgc25hcFRvR3JpZCwgc25hcEdyaWQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmxvd1RvU2NyZWVuUG9zaXRpb246IChwb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4OiBkb21YLCB5OiBkb21ZIH0gPSBkb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlclBvc2l0aW9uID0gcmVuZGVyZXJQb2ludFRvUG9pbnQocG9zaXRpb24sIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiByZW5kZXJlclBvc2l0aW9uLnggKyBkb21YLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcmVuZGVyZXJQb3NpdGlvbi55ICsgZG9tWSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0SW5pdGlhbGl6ZWQ6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbml0aWFsVmlld3BvcnRIZWxwZXI7XG4gICAgfSwgW2QzWm9vbSwgZDNTZWxlY3Rpb25dKTtcbiAgICByZXR1cm4gdmlld3BvcnRIZWxwZXJGdW5jdGlvbnM7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuZnVuY3Rpb24gdXNlUmVhY3RGbG93KCkge1xuICAgIGNvbnN0IHZpZXdwb3J0SGVscGVyID0gdXNlVmlld3BvcnRIZWxwZXIoKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgZ2V0Tm9kZXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHJldHVybiBzdG9yZVxuICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgIC5nZXROb2RlcygpXG4gICAgICAgICAgICAubWFwKChuKSA9PiAoeyAuLi5uIH0pKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgZ2V0Tm9kZSA9IHVzZUNhbGxiYWNrKChpZCkgPT4ge1xuICAgICAgICByZXR1cm4gc3RvcmUuZ2V0U3RhdGUoKS5ub2RlSW50ZXJuYWxzLmdldChpZCk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGdldEVkZ2VzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGVkZ2VzID0gW10gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIHJldHVybiBlZGdlcy5tYXAoKGUpID0+ICh7IC4uLmUgfSkpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBnZXRFZGdlID0gdXNlQ2FsbGJhY2soKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWRnZXMgPSBbXSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VzLmZpbmQoKGUpID0+IGUuaWQgPT09IGlkKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgc2V0Tm9kZXMgPSB1c2VDYWxsYmFjaygocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCB7IGdldE5vZGVzLCBzZXROb2RlcywgaGFzRGVmYXVsdE5vZGVzLCBvbk5vZGVzQ2hhbmdlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBub2RlcyA9IGdldE5vZGVzKCk7XG4gICAgICAgIGNvbnN0IG5leHROb2RlcyA9IHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nID8gcGF5bG9hZChub2RlcykgOiBwYXlsb2FkO1xuICAgICAgICBpZiAoaGFzRGVmYXVsdE5vZGVzKSB7XG4gICAgICAgICAgICBzZXROb2RlcyhuZXh0Tm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9uTm9kZXNDaGFuZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBuZXh0Tm9kZXMubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgPyBub2Rlcy5tYXAoKG5vZGUpID0+ICh7IHR5cGU6ICdyZW1vdmUnLCBpZDogbm9kZS5pZCB9KSlcbiAgICAgICAgICAgICAgICA6IG5leHROb2Rlcy5tYXAoKG5vZGUpID0+ICh7IGl0ZW06IG5vZGUsIHR5cGU6ICdyZXNldCcgfSkpO1xuICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZShjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCBzZXRFZGdlcyA9IHVzZUNhbGxiYWNrKChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWRnZXMgPSBbXSwgc2V0RWRnZXMsIGhhc0RlZmF1bHRFZGdlcywgb25FZGdlc0NoYW5nZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgbmV4dEVkZ2VzID0gdHlwZW9mIHBheWxvYWQgPT09ICdmdW5jdGlvbicgPyBwYXlsb2FkKGVkZ2VzKSA6IHBheWxvYWQ7XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIHNldEVkZ2VzKG5leHRFZGdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob25FZGdlc0NoYW5nZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IG5leHRFZGdlcy5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICA/IGVkZ2VzLm1hcCgoZWRnZSkgPT4gKHsgdHlwZTogJ3JlbW92ZScsIGlkOiBlZGdlLmlkIH0pKVxuICAgICAgICAgICAgICAgIDogbmV4dEVkZ2VzLm1hcCgoZWRnZSkgPT4gKHsgaXRlbTogZWRnZSwgdHlwZTogJ3Jlc2V0JyB9KSk7XG4gICAgICAgICAgICBvbkVkZ2VzQ2hhbmdlKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGFkZE5vZGVzID0gdXNlQ2FsbGJhY2soKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBBcnJheS5pc0FycmF5KHBheWxvYWQpID8gcGF5bG9hZCA6IFtwYXlsb2FkXTtcbiAgICAgICAgY29uc3QgeyBnZXROb2Rlcywgc2V0Tm9kZXMsIGhhc0RlZmF1bHROb2Rlcywgb25Ob2Rlc0NoYW5nZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE5vZGVzID0gZ2V0Tm9kZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHROb2RlcyA9IFsuLi5jdXJyZW50Tm9kZXMsIC4uLm5vZGVzXTtcbiAgICAgICAgICAgIHNldE5vZGVzKG5leHROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob25Ob2Rlc0NoYW5nZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IG5vZGVzLm1hcCgobm9kZSkgPT4gKHsgaXRlbTogbm9kZSwgdHlwZTogJ2FkZCcgfSkpO1xuICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZShjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCBhZGRFZGdlcyA9IHVzZUNhbGxiYWNrKChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRFZGdlcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkIDogW3BheWxvYWRdO1xuICAgICAgICBjb25zdCB7IGVkZ2VzID0gW10sIHNldEVkZ2VzLCBoYXNEZWZhdWx0RWRnZXMsIG9uRWRnZXNDaGFuZ2UgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIHNldEVkZ2VzKFsuLi5lZGdlcywgLi4ubmV4dEVkZ2VzXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob25FZGdlc0NoYW5nZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IG5leHRFZGdlcy5tYXAoKGVkZ2UpID0+ICh7IGl0ZW06IGVkZ2UsIHR5cGU6ICdhZGQnIH0pKTtcbiAgICAgICAgICAgIG9uRWRnZXNDaGFuZ2UoY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgY29uc3QgdG9PYmplY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZ2V0Tm9kZXMsIGVkZ2VzID0gW10sIHRyYW5zZm9ybSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgW3gsIHksIHpvb21dID0gdHJhbnNmb3JtO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZXM6IGdldE5vZGVzKCkubWFwKChuKSA9PiAoeyAuLi5uIH0pKSxcbiAgICAgICAgICAgIGVkZ2VzOiBlZGdlcy5tYXAoKGUpID0+ICh7IC4uLmUgfSkpLFxuICAgICAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgem9vbSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGRlbGV0ZUVsZW1lbnRzID0gdXNlQ2FsbGJhY2soKHsgbm9kZXM6IG5vZGVzRGVsZXRlZCwgZWRnZXM6IGVkZ2VzRGVsZXRlZCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9kZUludGVybmFscywgZ2V0Tm9kZXMsIGVkZ2VzLCBoYXNEZWZhdWx0Tm9kZXMsIGhhc0RlZmF1bHRFZGdlcywgb25Ob2Rlc0RlbGV0ZSwgb25FZGdlc0RlbGV0ZSwgb25Ob2Rlc0NoYW5nZSwgb25FZGdlc0NoYW5nZSwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IG5vZGVJZHMgPSAobm9kZXNEZWxldGVkIHx8IFtdKS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpO1xuICAgICAgICBjb25zdCBlZGdlSWRzID0gKGVkZ2VzRGVsZXRlZCB8fCBbXSkubWFwKChlZGdlKSA9PiBlZGdlLmlkKTtcbiAgICAgICAgY29uc3Qgbm9kZXNUb1JlbW92ZSA9IGdldE5vZGVzKCkucmVkdWNlKChyZXMsIG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEhpdCA9ICFub2RlSWRzLmluY2x1ZGVzKG5vZGUuaWQpICYmIG5vZGUucGFyZW50Tm9kZSAmJiByZXMuZmluZCgobikgPT4gbi5pZCA9PT0gbm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0YWJsZSA9IHR5cGVvZiBub2RlLmRlbGV0YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9kZS5kZWxldGFibGUgOiB0cnVlO1xuICAgICAgICAgICAgaWYgKGRlbGV0YWJsZSAmJiAobm9kZUlkcy5pbmNsdWRlcyhub2RlLmlkKSB8fCBwYXJlbnRIaXQpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIGNvbnN0IGRlbGV0YWJsZUVkZ2VzID0gZWRnZXMuZmlsdGVyKChlKSA9PiAodHlwZW9mIGUuZGVsZXRhYmxlID09PSAnYm9vbGVhbicgPyBlLmRlbGV0YWJsZSA6IHRydWUpKTtcbiAgICAgICAgY29uc3QgaW5pdGlhbEhpdEVkZ2VzID0gZGVsZXRhYmxlRWRnZXMuZmlsdGVyKChlKSA9PiBlZGdlSWRzLmluY2x1ZGVzKGUuaWQpKTtcbiAgICAgICAgaWYgKG5vZGVzVG9SZW1vdmUgfHwgaW5pdGlhbEhpdEVkZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0ZWRFZGdlcyA9IGdldENvbm5lY3RlZEVkZ2VzKG5vZGVzVG9SZW1vdmUsIGRlbGV0YWJsZUVkZ2VzKTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VzVG9SZW1vdmUgPSBbLi4uaW5pdGlhbEhpdEVkZ2VzLCAuLi5jb25uZWN0ZWRFZGdlc107XG4gICAgICAgICAgICBjb25zdCBlZGdlSWRzVG9SZW1vdmUgPSBlZGdlc1RvUmVtb3ZlLnJlZHVjZSgocmVzLCBlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXMuaW5jbHVkZXMoZWRnZS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goZWRnZS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzIHx8IGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXM6IGVkZ2VzLmZpbHRlcigoZSkgPT4gIWVkZ2VJZHNUb1JlbW92ZS5pbmNsdWRlcyhlLmlkKSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzRGVmYXVsdE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9SZW1vdmUuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUludGVybmFscy5kZWxldGUobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlSW50ZXJuYWxzOiBuZXcgTWFwKG5vZGVJbnRlcm5hbHMpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWRnZUlkc1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvbkVkZ2VzRGVsZXRlPy4oZWRnZXNUb1JlbW92ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG9uRWRnZXNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FZGdlc0NoYW5nZShlZGdlSWRzVG9SZW1vdmUubWFwKChpZCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGVzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG9uTm9kZXNEZWxldGU/Lihub2Rlc1RvUmVtb3ZlKTtcbiAgICAgICAgICAgICAgICBpZiAob25Ob2Rlc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IG5vZGVzVG9SZW1vdmUubWFwKChuKSA9PiAoeyBpZDogbi5pZCwgdHlwZTogJ3JlbW92ZScgfSkpO1xuICAgICAgICAgICAgICAgICAgICBvbk5vZGVzQ2hhbmdlKG5vZGVDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgY29uc3QgZ2V0Tm9kZVJlY3QgPSB1c2VDYWxsYmFjaygobm9kZU9yUmVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpc1JlY3QgPSBpc1JlY3RPYmplY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBpc1JlY3QgPyBudWxsIDogc3RvcmUuZ2V0U3RhdGUoKS5ub2RlSW50ZXJuYWxzLmdldChub2RlT3JSZWN0LmlkKTtcbiAgICAgICAgY29uc3Qgbm9kZVJlY3QgPSBpc1JlY3QgPyBub2RlT3JSZWN0IDogbm9kZVRvUmVjdChub2RlKTtcbiAgICAgICAgcmV0dXJuIFtub2RlUmVjdCwgbm9kZSwgaXNSZWN0XTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgZ2V0SW50ZXJzZWN0aW5nTm9kZXMgPSB1c2VDYWxsYmFjaygobm9kZU9yUmVjdCwgcGFydGlhbGx5ID0gdHJ1ZSwgbm9kZXMpID0+IHtcbiAgICAgICAgY29uc3QgW25vZGVSZWN0LCBub2RlLCBpc1JlY3RdID0gZ2V0Tm9kZVJlY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgIGlmICghbm9kZVJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5vZGVzIHx8IHN0b3JlLmdldFN0YXRlKCkuZ2V0Tm9kZXMoKSkuZmlsdGVyKChuKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzUmVjdCAmJiAobi5pZCA9PT0gbm9kZS5pZCB8fCAhbi5wb3NpdGlvbkFic29sdXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN1cnJOb2RlUmVjdCA9IG5vZGVUb1JlY3Qobik7XG4gICAgICAgICAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBnZXRPdmVybGFwcGluZ0FyZWEoY3Vyck5vZGVSZWN0LCBub2RlUmVjdCk7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgICAgICByZXR1cm4gcGFydGlhbGx5VmlzaWJsZSB8fCBvdmVybGFwcGluZ0FyZWEgPj0gbm9kZVJlY3Qud2lkdGggKiBub2RlUmVjdC5oZWlnaHQ7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBpc05vZGVJbnRlcnNlY3RpbmcgPSB1c2VDYWxsYmFjaygobm9kZU9yUmVjdCwgYXJlYSwgcGFydGlhbGx5ID0gdHJ1ZSkgPT4ge1xuICAgICAgICBjb25zdCBbbm9kZVJlY3RdID0gZ2V0Tm9kZVJlY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgIGlmICghbm9kZVJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBnZXRPdmVybGFwcGluZ0FyZWEobm9kZVJlY3QsIGFyZWEpO1xuICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgIHJldHVybiBwYXJ0aWFsbHlWaXNpYmxlIHx8IG92ZXJsYXBwaW5nQXJlYSA+PSBub2RlUmVjdC53aWR0aCAqIG5vZGVSZWN0LmhlaWdodDtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udmlld3BvcnRIZWxwZXIsXG4gICAgICAgICAgICBnZXROb2RlcyxcbiAgICAgICAgICAgIGdldE5vZGUsXG4gICAgICAgICAgICBnZXRFZGdlcyxcbiAgICAgICAgICAgIGdldEVkZ2UsXG4gICAgICAgICAgICBzZXROb2RlcyxcbiAgICAgICAgICAgIHNldEVkZ2VzLFxuICAgICAgICAgICAgYWRkTm9kZXMsXG4gICAgICAgICAgICBhZGRFZGdlcyxcbiAgICAgICAgICAgIHRvT2JqZWN0LFxuICAgICAgICAgICAgZGVsZXRlRWxlbWVudHMsXG4gICAgICAgICAgICBnZXRJbnRlcnNlY3RpbmdOb2RlcyxcbiAgICAgICAgICAgIGlzTm9kZUludGVyc2VjdGluZyxcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHZpZXdwb3J0SGVscGVyLFxuICAgICAgICBnZXROb2RlcyxcbiAgICAgICAgZ2V0Tm9kZSxcbiAgICAgICAgZ2V0RWRnZXMsXG4gICAgICAgIGdldEVkZ2UsXG4gICAgICAgIHNldE5vZGVzLFxuICAgICAgICBzZXRFZGdlcyxcbiAgICAgICAgYWRkTm9kZXMsXG4gICAgICAgIGFkZEVkZ2VzLFxuICAgICAgICB0b09iamVjdCxcbiAgICAgICAgZGVsZXRlRWxlbWVudHMsXG4gICAgICAgIGdldEludGVyc2VjdGluZ05vZGVzLFxuICAgICAgICBpc05vZGVJbnRlcnNlY3RpbmcsXG4gICAgXSk7XG59XG5cbmNvbnN0IGRlbGV0ZUtleU9wdGlvbnMgPSB7IGFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyOiBmYWxzZSB9O1xudmFyIHVzZUdsb2JhbEtleUhhbmRsZXIgPSAoeyBkZWxldGVLZXlDb2RlLCBtdWx0aVNlbGVjdGlvbktleUNvZGUgfSkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IGRlbGV0ZUVsZW1lbnRzIH0gPSB1c2VSZWFjdEZsb3coKTtcbiAgICBjb25zdCBkZWxldGVLZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MoZGVsZXRlS2V5Q29kZSwgZGVsZXRlS2V5T3B0aW9ucyk7XG4gICAgY29uc3QgbXVsdGlTZWxlY3Rpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MobXVsdGlTZWxlY3Rpb25LZXlDb2RlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZGVsZXRlS2V5UHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgZ2V0Tm9kZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gZ2V0Tm9kZXMoKS5maWx0ZXIoKG5vZGUpID0+IG5vZGUuc2VsZWN0ZWQpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRFZGdlcyA9IGVkZ2VzLmZpbHRlcigoZWRnZSkgPT4gZWRnZS5zZWxlY3RlZCk7XG4gICAgICAgICAgICBkZWxldGVFbGVtZW50cyh7IG5vZGVzOiBzZWxlY3RlZE5vZGVzLCBlZGdlczogc2VsZWN0ZWRFZGdlcyB9KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2RlbGV0ZUtleVByZXNzZWRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG11bHRpU2VsZWN0aW9uQWN0aXZlOiBtdWx0aVNlbGVjdGlvbktleVByZXNzZWQgfSk7XG4gICAgfSwgW211bHRpU2VsZWN0aW9uS2V5UHJlc3NlZF0pO1xufTtcblxuZnVuY3Rpb24gdXNlUmVzaXplSGFuZGxlcihyZW5kZXJlck5vZGUpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IHJlc2l6ZU9ic2VydmVyO1xuICAgICAgICBjb25zdCB1cGRhdGVEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZW5kZXJlck5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBnZXREaW1lbnNpb25zKHJlbmRlcmVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIGlmIChzaXplLmhlaWdodCA9PT0gMCB8fCBzaXplLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAwNCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA0J10oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHdpZHRoOiBzaXplLndpZHRoIHx8IDUwMCwgaGVpZ2h0OiBzaXplLmhlaWdodCB8fCA1MDAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHVwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgICAgICBpZiAocmVuZGVyZXJOb2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHVwZGF0ZURpbWVuc2lvbnMoKSk7XG4gICAgICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlbmRlcmVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgICAgICAgICAgaWYgKHJlc2l6ZU9ic2VydmVyICYmIHJlbmRlcmVyTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHJlbmRlcmVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG59XG5cbmNvbnN0IGNvbnRhaW5lclN0eWxlID0ge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgKi9cbmNvbnN0IHZpZXdDaGFuZ2VkID0gKHByZXZWaWV3cG9ydCwgZXZlbnRUcmFuc2Zvcm0pID0+IHByZXZWaWV3cG9ydC54ICE9PSBldmVudFRyYW5zZm9ybS54IHx8IHByZXZWaWV3cG9ydC55ICE9PSBldmVudFRyYW5zZm9ybS55IHx8IHByZXZWaWV3cG9ydC56b29tICE9PSBldmVudFRyYW5zZm9ybS5rO1xuY29uc3QgZXZlbnRUb0Zsb3dUcmFuc2Zvcm0gPSAoZXZlbnRUcmFuc2Zvcm0pID0+ICh7XG4gICAgeDogZXZlbnRUcmFuc2Zvcm0ueCxcbiAgICB5OiBldmVudFRyYW5zZm9ybS55LFxuICAgIHpvb206IGV2ZW50VHJhbnNmb3JtLmssXG59KTtcbmNvbnN0IGlzV3JhcHBlZFdpdGhDbGFzcyA9IChldmVudCwgY2xhc3NOYW1lKSA9PiBldmVudC50YXJnZXQuY2xvc2VzdChgLiR7Y2xhc3NOYW1lfWApO1xuY29uc3QgaXNSaWdodENsaWNrUGFuID0gKHBhbk9uRHJhZywgdXNlZEJ1dHRvbikgPT4gdXNlZEJ1dHRvbiA9PT0gMiAmJiBBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgcGFuT25EcmFnLmluY2x1ZGVzKDIpO1xuY29uc3Qgd2hlZWxEZWx0YSA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGZhY3RvciA9IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWNPcygpID8gMTAgOiAxO1xuICAgIHJldHVybiAtZXZlbnQuZGVsdGFZICogKGV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDAuMDUgOiBldmVudC5kZWx0YU1vZGUgPyAxIDogMC4wMDIpICogZmFjdG9yO1xufTtcbmNvbnN0IHNlbGVjdG9yJGEgPSAocykgPT4gKHtcbiAgICBkM1pvb206IHMuZDNab29tLFxuICAgIGQzU2VsZWN0aW9uOiBzLmQzU2VsZWN0aW9uLFxuICAgIGQzWm9vbUhhbmRsZXI6IHMuZDNab29tSGFuZGxlcixcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG59KTtcbmNvbnN0IFpvb21QYW5lID0gKHsgb25Nb3ZlLCBvbk1vdmVTdGFydCwgb25Nb3ZlRW5kLCBvblBhbmVDb250ZXh0TWVudSwgem9vbU9uU2Nyb2xsID0gdHJ1ZSwgem9vbU9uUGluY2ggPSB0cnVlLCBwYW5PblNjcm9sbCA9IGZhbHNlLCBwYW5PblNjcm9sbFNwZWVkID0gMC41LCBwYW5PblNjcm9sbE1vZGUgPSBQYW5PblNjcm9sbE1vZGUuRnJlZSwgem9vbU9uRG91YmxlQ2xpY2sgPSB0cnVlLCBlbGVtZW50c1NlbGVjdGFibGUsIHBhbk9uRHJhZyA9IHRydWUsIGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tLCBtYXhab29tLCB6b29tQWN0aXZhdGlvbktleUNvZGUsIHByZXZlbnRTY3JvbGxpbmcgPSB0cnVlLCBjaGlsZHJlbiwgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIH0pID0+IHtcbiAgICBjb25zdCB0aW1lcklkID0gdXNlUmVmKCk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGlzWm9vbWluZ09yUGFubmluZyA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3Qgem9vbWVkV2l0aFJpZ2h0TW91c2VCdXR0b24gPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IHpvb21QYW5lID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHByZXZUcmFuc2Zvcm0gPSB1c2VSZWYoeyB4OiAwLCB5OiAwLCB6b29tOiAwIH0pO1xuICAgIGNvbnN0IHsgZDNab29tLCBkM1NlbGVjdGlvbiwgZDNab29tSGFuZGxlciwgdXNlclNlbGVjdGlvbkFjdGl2ZSB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkYSwgc2hhbGxvdyk7XG4gICAgY29uc3Qgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3Moem9vbUFjdGl2YXRpb25LZXlDb2RlKTtcbiAgICBjb25zdCBtb3VzZUJ1dHRvbiA9IHVzZVJlZigwKTtcbiAgICBjb25zdCBpc1BhblNjcm9sbGluZyA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgcGFuU2Nyb2xsVGltZW91dCA9IHVzZVJlZigpO1xuICAgIHVzZVJlc2l6ZUhhbmRsZXIoem9vbVBhbmUpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh6b29tUGFuZS5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBiYm94ID0gem9vbVBhbmUuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGQzWm9vbUluc3RhbmNlID0gem9vbSgpLnNjYWxlRXh0ZW50KFttaW5ab29tLCBtYXhab29tXSkudHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzZWxlY3Qoem9vbVBhbmUuY3VycmVudCkuY2FsbChkM1pvb21JbnN0YW5jZSk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkVHJhbnNmb3JtID0gem9vbUlkZW50aXR5XG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShkZWZhdWx0Vmlld3BvcnQueCwgZGVmYXVsdFZpZXdwb3J0LnkpXG4gICAgICAgICAgICAgICAgLnNjYWxlKGNsYW1wKGRlZmF1bHRWaWV3cG9ydC56b29tLCBtaW5ab29tLCBtYXhab29tKSk7XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgICAgICAgIFtiYm94LndpZHRoLCBiYm94LmhlaWdodF0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgY29uc3RyYWluZWRUcmFuc2Zvcm0gPSBkM1pvb21JbnN0YW5jZS5jb25zdHJhaW4oKSh1cGRhdGVkVHJhbnNmb3JtLCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgICAgICBkM1pvb21JbnN0YW5jZS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBjb25zdHJhaW5lZFRyYW5zZm9ybSk7XG4gICAgICAgICAgICBkM1pvb21JbnN0YW5jZS53aGVlbERlbHRhKHdoZWVsRGVsdGEpO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGQzWm9vbTogZDNab29tSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgZDNTZWxlY3Rpb246IHNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBkM1pvb21IYW5kbGVyOiBzZWxlY3Rpb24ub24oJ3doZWVsLnpvb20nKSxcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHBhc3MgdHJhbnNmb3JtIGJlY2F1c2Ugem9vbSBoYW5kbGVyIGlzIG5vdCByZWdpc3RlcmVkIHdoZW4gd2Ugc2V0IHRoZSBpbml0aWFsIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogW2NvbnN0cmFpbmVkVHJhbnNmb3JtLngsIGNvbnN0cmFpbmVkVHJhbnNmb3JtLnksIGNvbnN0cmFpbmVkVHJhbnNmb3JtLmtdLFxuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHpvb21QYW5lLmN1cnJlbnQuY2xvc2VzdCgnLnJlYWN0LWZsb3cnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkM1NlbGVjdGlvbiAmJiBkM1pvb20pIHtcbiAgICAgICAgICAgIGlmIChwYW5PblNjcm9sbCAmJiAhem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkICYmICF1c2VyU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgZDNTZWxlY3Rpb24ub24oJ3doZWVsLnpvb20nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFpvb20gPSBkM1NlbGVjdGlvbi5wcm9wZXJ0eSgnX196b29tJykuayB8fCAxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBfaXNNYWNPcyA9IGlzTWFjT3MoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFjb3Mgc2V0cyBjdHJsS2V5PXRydWUgZm9yIHBpbmNoIGdlc3R1cmUgb24gYSB0cmFja3BhZFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiB6b29tT25QaW5jaCAmJiBfaXNNYWNPcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludGVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpbmNoRGVsdGEgPSB3aGVlbERlbHRhKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHpvb20gPSBjdXJyZW50Wm9vbSAqIE1hdGgucG93KDIsIHBpbmNoRGVsdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgZDNab29tLnNjYWxlVG8oZDNTZWxlY3Rpb24sIHpvb20sIHBvaW50LCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVhc2Ugc2Nyb2xsIHNwZWVkIGluIGZpcmVmb3hcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyZWZveDogZGVsdGFNb2RlID09PSAxOyBjaHJvbWU6IGRlbHRhTW9kZSA9PT0gMFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWx0YU5vcm1hbGl6ZSA9IGV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDIwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbHRhWCA9IHBhbk9uU2Nyb2xsTW9kZSA9PT0gUGFuT25TY3JvbGxNb2RlLlZlcnRpY2FsID8gMCA6IGV2ZW50LmRlbHRhWCAqIGRlbHRhTm9ybWFsaXplO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVsdGFZID0gcGFuT25TY3JvbGxNb2RlID09PSBQYW5PblNjcm9sbE1vZGUuSG9yaXpvbnRhbCA/IDAgOiBldmVudC5kZWx0YVkgKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBlbmFibGVzIHZlcnRpY2FsIHNjcm9sbGluZyB3aXRoIHNoaWZ0ICsgc2Nyb2xsIG9uIHdpbmRvd3NcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXNNYWNPcyAmJiBldmVudC5zaGlmdEtleSAmJiBwYW5PblNjcm9sbE1vZGUgIT09IFBhbk9uU2Nyb2xsTW9kZS5WZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFYID0gZXZlbnQuZGVsdGFZICogZGVsdGFOb3JtYWxpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGQzWm9vbS50cmFuc2xhdGVCeShkM1NlbGVjdGlvbiwgLShkZWx0YVggLyBjdXJyZW50Wm9vbSkgKiBwYW5PblNjcm9sbFNwZWVkLCAtKGRlbHRhWSAvIGN1cnJlbnRab29tKSAqIHBhbk9uU2Nyb2xsU3BlZWQsIFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRWaWV3cG9ydCA9IGV2ZW50VG9GbG93VHJhbnNmb3JtKGQzU2VsZWN0aW9uLnByb3BlcnR5KCdfX3pvb20nKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZVN0YXJ0LCBvblZpZXdwb3J0Q2hhbmdlLCBvblZpZXdwb3J0Q2hhbmdlRW5kIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocGFuU2Nyb2xsVGltZW91dC5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHBhbiBvbiBzY3JvbGwgd2UgbmVlZCB0byBoYW5kbGUgdGhlIGV2ZW50IGNhbGxzIG9uIG91ciBvd25cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuJ3QgdXNlIHRoZSBzdGFydCwgem9vbSBhbmQgZW5kIGV2ZW50cyBmcm9tIGQzLXpvb21cbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBzdGFydCBhbmQgbW92ZSBnZXRzIGNhbGxlZCBvbiBldmVyeSBzY3JvbGwgZXZlbnQgYW5kIG5vdCBvbmNlIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1BhblNjcm9sbGluZy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1BhblNjcm9sbGluZy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTW92ZVN0YXJ0Py4oZXZlbnQsIG5leHRWaWV3cG9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlU3RhcnQ/LihuZXh0Vmlld3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1BhblNjcm9sbGluZy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbk1vdmU/LihldmVudCwgbmV4dFZpZXdwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVmlld3BvcnRDaGFuZ2U/LihuZXh0Vmlld3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFuU2Nyb2xsVGltZW91dC5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3ZlRW5kPy4oZXZlbnQsIG5leHRWaWV3cG9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25WaWV3cG9ydENoYW5nZUVuZD8uKG5leHRWaWV3cG9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQYW5TY3JvbGxpbmcuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTUwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZDNab29tSGFuZGxlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkM1NlbGVjdGlvbi5vbignd2hlZWwuem9vbScsIGZ1bmN0aW9uIChldmVudCwgZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRTY3JvbGxpbmcgfHwgaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1doZWVsQ2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZDNab29tSGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50LCBkKTtcbiAgICAgICAgICAgICAgICB9LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICBwYW5PblNjcm9sbCxcbiAgICAgICAgcGFuT25TY3JvbGxNb2RlLFxuICAgICAgICBkM1NlbGVjdGlvbixcbiAgICAgICAgZDNab29tLFxuICAgICAgICBkM1pvb21IYW5kbGVyLFxuICAgICAgICB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsXG4gICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsaW5nLFxuICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICBvbk1vdmVTdGFydCxcbiAgICAgICAgb25Nb3ZlLFxuICAgICAgICBvbk1vdmVFbmQsXG4gICAgXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGQzWm9vbSkge1xuICAgICAgICAgICAgZDNab29tLm9uKCdzdGFydCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZXZlbnQuc291cmNlRXZlbnQgfHwgZXZlbnQuc291cmNlRXZlbnQuaW50ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgaXQgaGVyZSwgYmVjYXVzZSBpdCdzIGFsd2F5cyAwIGluIHRoZSBcInpvb21cIiBldmVudFxuICAgICAgICAgICAgICAgIG1vdXNlQnV0dG9uLmN1cnJlbnQgPSBldmVudC5zb3VyY2VFdmVudD8uYnV0dG9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZVN0YXJ0IH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZsb3dUcmFuc2Zvcm0gPSBldmVudFRvRmxvd1RyYW5zZm9ybShldmVudC50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIGlzWm9vbWluZ09yUGFubmluZy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcmV2VHJhbnNmb3JtLmN1cnJlbnQgPSBmbG93VHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudD8udHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBwYW5lRHJhZ2dpbmc6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uVmlld3BvcnRDaGFuZ2VTdGFydD8uKGZsb3dUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIG9uTW92ZVN0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGZsb3dUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbZDNab29tLCBvbk1vdmVTdGFydF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkM1pvb20pIHtcbiAgICAgICAgICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlICYmICFpc1pvb21pbmdPclBhbm5pbmcuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGQzWm9vbS5vbignem9vbScsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXVzZXJTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBkM1pvb20ub24oJ3pvb20nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvblZpZXdwb3J0Q2hhbmdlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHRyYW5zZm9ybTogW2V2ZW50LnRyYW5zZm9ybS54LCBldmVudC50cmFuc2Zvcm0ueSwgZXZlbnQudHJhbnNmb3JtLmtdIH0pO1xuICAgICAgICAgICAgICAgICAgICB6b29tZWRXaXRoUmlnaHRNb3VzZUJ1dHRvbi5jdXJyZW50ID0gISEob25QYW5lQ29udGV4dE1lbnUgJiYgaXNSaWdodENsaWNrUGFuKHBhbk9uRHJhZywgbW91c2VCdXR0b24uY3VycmVudCA/PyAwKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgob25Nb3ZlIHx8IG9uVmlld3BvcnRDaGFuZ2UpICYmICFldmVudC5zb3VyY2VFdmVudD8uaW50ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsb3dUcmFuc2Zvcm0gPSBldmVudFRvRmxvd1RyYW5zZm9ybShldmVudC50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25WaWV3cG9ydENoYW5nZT8uKGZsb3dUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3ZlPy4oZXZlbnQuc291cmNlRXZlbnQsIGZsb3dUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbdXNlclNlbGVjdGlvbkFjdGl2ZSwgZDNab29tLCBvbk1vdmUsIHBhbk9uRHJhZywgb25QYW5lQ29udGV4dE1lbnVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZDNab29tKSB7XG4gICAgICAgICAgICBkM1pvb20ub24oJ2VuZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZXZlbnQuc291cmNlRXZlbnQgfHwgZXZlbnQuc291cmNlRXZlbnQuaW50ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZUVuZCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpc1pvb21pbmdPclBhbm5pbmcuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgcGFuZURyYWdnaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAob25QYW5lQ29udGV4dE1lbnUgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNSaWdodENsaWNrUGFuKHBhbk9uRHJhZywgbW91c2VCdXR0b24uY3VycmVudCA/PyAwKSAmJlxuICAgICAgICAgICAgICAgICAgICAhem9vbWVkV2l0aFJpZ2h0TW91c2VCdXR0b24uY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBvblBhbmVDb250ZXh0TWVudShldmVudC5zb3VyY2VFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHpvb21lZFdpdGhSaWdodE1vdXNlQnV0dG9uLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoKG9uTW92ZUVuZCB8fCBvblZpZXdwb3J0Q2hhbmdlRW5kKSAmJiB2aWV3Q2hhbmdlZChwcmV2VHJhbnNmb3JtLmN1cnJlbnQsIGV2ZW50LnRyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxvd1RyYW5zZm9ybSA9IGV2ZW50VG9GbG93VHJhbnNmb3JtKGV2ZW50LnRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZUcmFuc2Zvcm0uY3VycmVudCA9IGZsb3dUcmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lcklkLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVmlld3BvcnRDaGFuZ2VFbmQ/LihmbG93VHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTW92ZUVuZD8uKGV2ZW50LnNvdXJjZUV2ZW50LCBmbG93VHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcGFuT25TY3JvbGwgPyAxNTAgOiAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtkM1pvb20sIHBhbk9uU2Nyb2xsLCBwYW5PbkRyYWcsIG9uTW92ZUVuZCwgb25QYW5lQ29udGV4dE1lbnVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZDNab29tKSB7XG4gICAgICAgICAgICBkM1pvb20uZmlsdGVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHpvb21TY3JvbGwgPSB6b29tQWN0aXZhdGlvbktleVByZXNzZWQgfHwgem9vbU9uU2Nyb2xsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpbmNoWm9vbSA9IHpvb21PblBpbmNoICYmIGV2ZW50LmN0cmxLZXk7XG4gICAgICAgICAgICAgICAgaWYgKChwYW5PbkRyYWcgPT09IHRydWUgfHwgKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoMSkpKSAmJlxuICAgICAgICAgICAgICAgICAgICBldmVudC5idXR0b24gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgJ3JlYWN0LWZsb3dfX25vZGUnKSB8fCBpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsICdyZWFjdC1mbG93X19lZGdlJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBhbGwgaW50ZXJhY3Rpb25zIGFyZSBkaXNhYmxlZCwgd2UgcHJldmVudCBhbGwgem9vbSBldmVudHNcbiAgICAgICAgICAgICAgICBpZiAoIXBhbk9uRHJhZyAmJiAhem9vbVNjcm9sbCAmJiAhcGFuT25TY3JvbGwgJiYgIXpvb21PbkRvdWJsZUNsaWNrICYmICF6b29tT25QaW5jaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGR1cmluZyBhIHNlbGVjdGlvbiB3ZSBwcmV2ZW50IGFsbCBvdGhlciBpbnRlcmFjdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAodXNlclNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHpvb20gb24gZG91YmxlIGNsaWNrIGlzIGRpc2FibGVkLCB3ZSBwcmV2ZW50IHRoZSBkb3VibGUgY2xpY2sgZXZlbnRcbiAgICAgICAgICAgICAgICBpZiAoIXpvb21PbkRvdWJsZUNsaWNrICYmIGV2ZW50LnR5cGUgPT09ICdkYmxjbGljaycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgaW5zaWRlIGFuIGVsZW1lbnQgd2l0aCB0aGUgbm93aGVlbCBjbGFzcywgd2UgcHJldmVudCB6b29taW5nXG4gICAgICAgICAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSkgJiYgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBpbnNpZGUgYW4gZWxlbWVudCB3aXRoIHRoZSBub3BhbiBjbGFzcywgd2UgcHJldmVudCBwYW5uaW5nXG4gICAgICAgICAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9QYW5DbGFzc05hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgIChldmVudC50eXBlICE9PSAnd2hlZWwnIHx8IChwYW5PblNjcm9sbCAmJiBldmVudC50eXBlID09PSAnd2hlZWwnICYmICF6b29tQWN0aXZhdGlvbktleVByZXNzZWQpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghem9vbU9uUGluY2ggJiYgZXZlbnQuY3RybEtleSAmJiBldmVudC50eXBlID09PSAnd2hlZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGVyZSBpcyBubyBzY3JvbGwgaGFuZGxpbmcgZW5hYmxlZCwgd2UgcHJldmVudCBhbGwgd2hlZWwgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKCF6b29tU2Nyb2xsICYmICFwYW5PblNjcm9sbCAmJiAhcGluY2hab29tICYmIGV2ZW50LnR5cGUgPT09ICd3aGVlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcGFuZSBpcyBub3QgbW92YWJsZSwgd2UgcHJldmVudCBkcmFnZ2luZyBpdCB3aXRoIG1vdXNlc3RhcnQgb3IgdG91Y2hzdGFydFxuICAgICAgICAgICAgICAgIGlmICghcGFuT25EcmFnICYmIChldmVudC50eXBlID09PSAnbW91c2Vkb3duJyB8fCBldmVudC50eXBlID09PSAndG91Y2hzdGFydCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHBhbmUgaXMgb25seSBtb3ZhYmxlIHVzaW5nIGFsbG93ZWQgY2xpY2tzXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJlxuICAgICAgICAgICAgICAgICAgICAhcGFuT25EcmFnLmluY2x1ZGVzKGV2ZW50LmJ1dHRvbikgJiZcbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IGFsbG93IHJpZ2h0IGNsaWNrcyBpZiBwYW4gb24gZHJhZyBpcyBzZXQgdG8gcmlnaHQgY2xpY2tcbiAgICAgICAgICAgICAgICBjb25zdCBidXR0b25BbGxvd2VkID0gKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoZXZlbnQuYnV0dG9uKSkgfHwgIWV2ZW50LmJ1dHRvbiB8fCBldmVudC5idXR0b24gPD0gMTtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGZpbHRlciBmb3IgZDMtem9vbVxuICAgICAgICAgICAgICAgIHJldHVybiAoIWV2ZW50LmN0cmxLZXkgfHwgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykgJiYgYnV0dG9uQWxsb3dlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICBkM1pvb20sXG4gICAgICAgIHpvb21PblNjcm9sbCxcbiAgICAgICAgem9vbU9uUGluY2gsXG4gICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICB6b29tT25Eb3VibGVDbGljayxcbiAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICBlbGVtZW50c1NlbGVjdGFibGUsXG4gICAgICAgIHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCxcbiAgICBdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fcmVuZGVyZXJcIiwgcmVmOiB6b29tUGFuZSwgc3R5bGU6IGNvbnRhaW5lclN0eWxlIH0sIGNoaWxkcmVuKSk7XG59O1xuXG5jb25zdCBzZWxlY3RvciQ5ID0gKHMpID0+ICh7XG4gICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgIHVzZXJTZWxlY3Rpb25SZWN0OiBzLnVzZXJTZWxlY3Rpb25SZWN0LFxufSk7XG5mdW5jdGlvbiBVc2VyU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvbkFjdGl2ZSwgdXNlclNlbGVjdGlvblJlY3QgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDksIHNoYWxsb3cpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gdXNlclNlbGVjdGlvbkFjdGl2ZSAmJiB1c2VyU2VsZWN0aW9uUmVjdDtcbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fc2VsZWN0aW9uIHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IHVzZXJTZWxlY3Rpb25SZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB1c2VyU2VsZWN0aW9uUmVjdC5oZWlnaHQsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt1c2VyU2VsZWN0aW9uUmVjdC54fXB4LCAke3VzZXJTZWxlY3Rpb25SZWN0Lnl9cHgpYCxcbiAgICAgICAgfSB9KSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVBhcmVudEV4cGFuZChyZXMsIHVwZGF0ZUl0ZW0pIHtcbiAgICBjb25zdCBwYXJlbnQgPSByZXMuZmluZCgoZSkgPT4gZS5pZCA9PT0gdXBkYXRlSXRlbS5wYXJlbnROb2RlKTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGV4dGVuZFdpZHRoID0gdXBkYXRlSXRlbS5wb3NpdGlvbi54ICsgdXBkYXRlSXRlbS53aWR0aCAtIHBhcmVudC53aWR0aDtcbiAgICAgICAgY29uc3QgZXh0ZW5kSGVpZ2h0ID0gdXBkYXRlSXRlbS5wb3NpdGlvbi55ICsgdXBkYXRlSXRlbS5oZWlnaHQgLSBwYXJlbnQuaGVpZ2h0O1xuICAgICAgICBpZiAoZXh0ZW5kV2lkdGggPiAwIHx8IGV4dGVuZEhlaWdodCA+IDAgfHwgdXBkYXRlSXRlbS5wb3NpdGlvbi54IDwgMCB8fCB1cGRhdGVJdGVtLnBvc2l0aW9uLnkgPCAwKSB7XG4gICAgICAgICAgICBwYXJlbnQuc3R5bGUgPSB7IC4uLnBhcmVudC5zdHlsZSB9IHx8IHt9O1xuICAgICAgICAgICAgcGFyZW50LnN0eWxlLndpZHRoID0gcGFyZW50LnN0eWxlLndpZHRoID8/IHBhcmVudC53aWR0aDtcbiAgICAgICAgICAgIHBhcmVudC5zdHlsZS5oZWlnaHQgPSBwYXJlbnQuc3R5bGUuaGVpZ2h0ID8/IHBhcmVudC5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoZXh0ZW5kV2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnN0eWxlLndpZHRoICs9IGV4dGVuZFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dGVuZEhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc3R5bGUuaGVpZ2h0ICs9IGV4dGVuZEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGVJdGVtLnBvc2l0aW9uLnggPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeERpZmYgPSBNYXRoLmFicyh1cGRhdGVJdGVtLnBvc2l0aW9uLngpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5wb3NpdGlvbi54ID0gcGFyZW50LnBvc2l0aW9uLnggLSB4RGlmZjtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc3R5bGUud2lkdGggKz0geERpZmY7XG4gICAgICAgICAgICAgICAgdXBkYXRlSXRlbS5wb3NpdGlvbi54ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGVJdGVtLnBvc2l0aW9uLnkgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeURpZmYgPSBNYXRoLmFicyh1cGRhdGVJdGVtLnBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5wb3NpdGlvbi55ID0gcGFyZW50LnBvc2l0aW9uLnkgLSB5RGlmZjtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc3R5bGUuaGVpZ2h0ICs9IHlEaWZmO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0ucG9zaXRpb24ueSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQud2lkdGggPSBwYXJlbnQuc3R5bGUud2lkdGg7XG4gICAgICAgICAgICBwYXJlbnQuaGVpZ2h0ID0gcGFyZW50LnN0eWxlLmhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5Q2hhbmdlcyhjaGFuZ2VzLCBlbGVtZW50cykge1xuICAgIC8vIHdlIG5lZWQgdGhpcyBoYWNrIHRvIGhhbmRsZSB0aGUgc2V0Tm9kZXMgYW5kIHNldEVkZ2VzIGZ1bmN0aW9uIG9mIHRoZSB1c2VSZWFjdEZsb3cgaG9vayBmb3IgY29udHJvbGxlZCBmbG93c1xuICAgIGlmIChjaGFuZ2VzLnNvbWUoKGMpID0+IGMudHlwZSA9PT0gJ3Jlc2V0JykpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXMuZmlsdGVyKChjKSA9PiBjLnR5cGUgPT09ICdyZXNldCcpLm1hcCgoYykgPT4gYy5pdGVtKTtcbiAgICB9XG4gICAgY29uc3QgaW5pdEVsZW1lbnRzID0gY2hhbmdlcy5maWx0ZXIoKGMpID0+IGMudHlwZSA9PT0gJ2FkZCcpLm1hcCgoYykgPT4gYy5pdGVtKTtcbiAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKChyZXMsIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudENoYW5nZXMgPSBjaGFuZ2VzLmZpbHRlcigoYykgPT4gYy5pZCA9PT0gaXRlbS5pZCk7XG4gICAgICAgIGlmIChjdXJyZW50Q2hhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVJdGVtID0geyAuLi5pdGVtIH07XG4gICAgICAgIGZvciAoY29uc3QgY3VycmVudENoYW5nZSBvZiBjdXJyZW50Q2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnRDaGFuZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtLnNlbGVjdGVkID0gY3VycmVudENoYW5nZS5zZWxlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Bvc2l0aW9uJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Q2hhbmdlLnBvc2l0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0ucG9zaXRpb24gPSBjdXJyZW50Q2hhbmdlLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Q2hhbmdlLnBvc2l0aW9uQWJzb2x1dGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbS5wb3NpdGlvbkFic29sdXRlID0gY3VycmVudENoYW5nZS5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Q2hhbmdlLmRyYWdnaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0uZHJhZ2dpbmcgPSBjdXJyZW50Q2hhbmdlLmRyYWdnaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUl0ZW0uZXhwYW5kUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlUGFyZW50RXhwYW5kKHJlcywgdXBkYXRlSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkaW1lbnNpb25zJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Q2hhbmdlLmRpbWVuc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbS53aWR0aCA9IGN1cnJlbnRDaGFuZ2UuZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtLmhlaWdodCA9IGN1cnJlbnRDaGFuZ2UuZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRDaGFuZ2UudXBkYXRlU3R5bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbS5zdHlsZSA9IHsgLi4uKHVwZGF0ZUl0ZW0uc3R5bGUgfHwge30pLCAuLi5jdXJyZW50Q2hhbmdlLmRpbWVuc2lvbnMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudENoYW5nZS5yZXNpemluZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbS5yZXNpemluZyA9IGN1cnJlbnRDaGFuZ2UucmVzaXppbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlSXRlbS5leHBhbmRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVQYXJlbnRFeHBhbmQocmVzLCB1cGRhdGVJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2godXBkYXRlSXRlbSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgaW5pdEVsZW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgbm9kZXMpIHtcbiAgICByZXR1cm4gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIG5vZGVzKTtcbn1cbmZ1bmN0aW9uIGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgZWRnZXMpIHtcbiAgICByZXR1cm4gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIGVkZ2VzKTtcbn1cbmNvbnN0IGNyZWF0ZVNlbGVjdGlvbkNoYW5nZSA9IChpZCwgc2VsZWN0ZWQpID0+ICh7XG4gICAgaWQsXG4gICAgdHlwZTogJ3NlbGVjdCcsXG4gICAgc2VsZWN0ZWQsXG59KTtcbmZ1bmN0aW9uIGdldFNlbGVjdGlvbkNoYW5nZXMoaXRlbXMsIHNlbGVjdGVkSWRzKSB7XG4gICAgcmV0dXJuIGl0ZW1zLnJlZHVjZSgocmVzLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbGxCZVNlbGVjdGVkID0gc2VsZWN0ZWRJZHMuaW5jbHVkZXMoaXRlbS5pZCk7XG4gICAgICAgIGlmICghaXRlbS5zZWxlY3RlZCAmJiB3aWxsQmVTZWxlY3RlZCkge1xuICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXMucHVzaChjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoaXRlbS5pZCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0uc2VsZWN0ZWQgJiYgIXdpbGxCZVNlbGVjdGVkKSB7XG4gICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXMucHVzaChjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoaXRlbS5pZCwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBUaGUgdXNlciBzZWxlY3Rpb24gcmVjdGFuZ2xlIGdldHMgZGlzcGxheWVkIHdoZW4gYSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB3aGlsZSBwcmVzc2luZyBzaGlmdFxuICovXG5jb25zdCB3cmFwSGFuZGxlciA9IChoYW5kbGVyLCBjb250YWluZXJSZWYpID0+IHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlcj8uKGV2ZW50KTtcbiAgICB9O1xufTtcbmNvbnN0IHNlbGVjdG9yJDggPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBkcmFnZ2luZzogcy5wYW5lRHJhZ2dpbmcsXG59KTtcbmNvbnN0IFBhbmUgPSBtZW1vKCh7IGlzU2VsZWN0aW5nLCBzZWxlY3Rpb25Nb2RlID0gU2VsZWN0aW9uTW9kZS5GdWxsLCBwYW5PbkRyYWcsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBvblBhbmVDbGljaywgb25QYW5lQ29udGV4dE1lbnUsIG9uUGFuZVNjcm9sbCwgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBjaGlsZHJlbiwgfSkgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgcHJldlNlbGVjdGVkTm9kZXNDb3VudCA9IHVzZVJlZigwKTtcbiAgICBjb25zdCBwcmV2U2VsZWN0ZWRFZGdlc0NvdW50ID0gdXNlUmVmKDApO1xuICAgIGNvbnN0IGNvbnRhaW5lckJvdW5kcyA9IHVzZVJlZigpO1xuICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvbkFjdGl2ZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBkcmFnZ2luZyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkOCwgc2hhbGxvdyk7XG4gICAgY29uc3QgcmVzZXRVc2VyU2VsZWN0aW9uID0gKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLCB1c2VyU2VsZWN0aW9uUmVjdDogbnVsbCB9KTtcbiAgICAgICAgcHJldlNlbGVjdGVkTm9kZXNDb3VudC5jdXJyZW50ID0gMDtcbiAgICAgICAgcHJldlNlbGVjdGVkRWRnZXNDb3VudC5jdXJyZW50ID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IG9uQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgb25QYW5lQ2xpY2s/LihldmVudCk7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkucmVzZXRTZWxlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25Db250ZXh0TWVudSA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZz8uaW5jbHVkZXMoMikpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25QYW5lQ29udGV4dE1lbnU/LihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBvbldoZWVsID0gb25QYW5lU2Nyb2xsID8gKGV2ZW50KSA9PiBvblBhbmVTY3JvbGwoZXZlbnQpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uTW91c2VEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVzZXRTZWxlY3RlZEVsZW1lbnRzLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb250YWluZXJCb3VuZHMuY3VycmVudCA9IGRvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIWVsZW1lbnRzU2VsZWN0YWJsZSB8fFxuICAgICAgICAgICAgIWlzU2VsZWN0aW5nIHx8XG4gICAgICAgICAgICBldmVudC5idXR0b24gIT09IDAgfHxcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCAhPT0gY29udGFpbmVyLmN1cnJlbnQgfHxcbiAgICAgICAgICAgICFjb250YWluZXJCb3VuZHMuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCwgY29udGFpbmVyQm91bmRzLmN1cnJlbnQpO1xuICAgICAgICByZXNldFNlbGVjdGVkRWxlbWVudHMoKTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgc3RhcnRYOiB4LFxuICAgICAgICAgICAgICAgIHN0YXJ0WTogeSxcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgb25TZWxlY3Rpb25TdGFydD8uKGV2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uTW91c2VNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvblJlY3QsIG5vZGVJbnRlcm5hbHMsIGVkZ2VzLCB0cmFuc2Zvcm0sIG9uTm9kZXNDaGFuZ2UsIG9uRWRnZXNDaGFuZ2UsIG5vZGVPcmlnaW4sIGdldE5vZGVzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIWlzU2VsZWN0aW5nIHx8ICFjb250YWluZXJCb3VuZHMuY3VycmVudCB8fCAhdXNlclNlbGVjdGlvblJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHVzZXJTZWxlY3Rpb25BY3RpdmU6IHRydWUsIG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICAgICAgY29uc3QgbW91c2VQb3MgPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LCBjb250YWluZXJCb3VuZHMuY3VycmVudCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0WCA9IHVzZXJTZWxlY3Rpb25SZWN0LnN0YXJ0WCA/PyAwO1xuICAgICAgICBjb25zdCBzdGFydFkgPSB1c2VyU2VsZWN0aW9uUmVjdC5zdGFydFkgPz8gMDtcbiAgICAgICAgY29uc3QgbmV4dFVzZXJTZWxlY3RSZWN0ID0ge1xuICAgICAgICAgICAgLi4udXNlclNlbGVjdGlvblJlY3QsXG4gICAgICAgICAgICB4OiBtb3VzZVBvcy54IDwgc3RhcnRYID8gbW91c2VQb3MueCA6IHN0YXJ0WCxcbiAgICAgICAgICAgIHk6IG1vdXNlUG9zLnkgPCBzdGFydFkgPyBtb3VzZVBvcy55IDogc3RhcnRZLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGguYWJzKG1vdXNlUG9zLnggLSBzdGFydFgpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLmFicyhtb3VzZVBvcy55IC0gc3RhcnRZKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBnZXROb2RlcygpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gZ2V0Tm9kZXNJbnNpZGUobm9kZUludGVybmFscywgbmV4dFVzZXJTZWxlY3RSZWN0LCB0cmFuc2Zvcm0sIHNlbGVjdGlvbk1vZGUgPT09IFNlbGVjdGlvbk1vZGUuUGFydGlhbCwgdHJ1ZSwgbm9kZU9yaWdpbik7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRWRnZUlkcyA9IGdldENvbm5lY3RlZEVkZ2VzKHNlbGVjdGVkTm9kZXMsIGVkZ2VzKS5tYXAoKGUpID0+IGUuaWQpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGVJZHMgPSBzZWxlY3RlZE5vZGVzLm1hcCgobikgPT4gbi5pZCk7XG4gICAgICAgIGlmIChwcmV2U2VsZWN0ZWROb2Rlc0NvdW50LmN1cnJlbnQgIT09IHNlbGVjdGVkTm9kZUlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHByZXZTZWxlY3RlZE5vZGVzQ291bnQuY3VycmVudCA9IHNlbGVjdGVkTm9kZUlkcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhub2Rlcywgc2VsZWN0ZWROb2RlSWRzKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9uTm9kZXNDaGFuZ2U/LihjaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlNlbGVjdGVkRWRnZXNDb3VudC5jdXJyZW50ICE9PSBzZWxlY3RlZEVkZ2VJZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwcmV2U2VsZWN0ZWRFZGdlc0NvdW50LmN1cnJlbnQgPSBzZWxlY3RlZEVkZ2VJZHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMoZWRnZXMsIHNlbGVjdGVkRWRnZUlkcyk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvbkVkZ2VzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IG5leHRVc2VyU2VsZWN0UmVjdCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvbk1vdXNlVXAgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvblJlY3QgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB0cmlnZ2VyIGNsaWNrIGZ1bmN0aW9ucyB3aGVuIGluIHNlbGVjdGlvbiBtb2RlIGlmXG4gICAgICAgIC8vIHRoZSB1c2VyIGRpZCBub3QgbW92ZSB0aGUgbW91c2UuXG4gICAgICAgIGlmICghdXNlclNlbGVjdGlvbkFjdGl2ZSAmJiB1c2VyU2VsZWN0aW9uUmVjdCAmJiBldmVudC50YXJnZXQgPT09IGNvbnRhaW5lci5jdXJyZW50KSB7XG4gICAgICAgICAgICBvbkNsaWNrPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IHByZXZTZWxlY3RlZE5vZGVzQ291bnQuY3VycmVudCA+IDAgfSk7XG4gICAgICAgIHJlc2V0VXNlclNlbGVjdGlvbigpO1xuICAgICAgICBvblNlbGVjdGlvbkVuZD8uKGV2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uTW91c2VMZWF2ZSA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAodXNlclNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogcHJldlNlbGVjdGVkTm9kZXNDb3VudC5jdXJyZW50ID4gMCB9KTtcbiAgICAgICAgICAgIG9uU2VsZWN0aW9uRW5kPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc2V0VXNlclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgY29uc3QgaGFzQWN0aXZlU2VsZWN0aW9uID0gZWxlbWVudHNTZWxlY3RhYmxlICYmIChpc1NlbGVjdGluZyB8fCB1c2VyU2VsZWN0aW9uQWN0aXZlKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fcGFuZScsIHsgZHJhZ2dpbmcsIHNlbGVjdGlvbjogaXNTZWxlY3RpbmcgfV0pLCBvbkNsaWNrOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyB1bmRlZmluZWQgOiB3cmFwSGFuZGxlcihvbkNsaWNrLCBjb250YWluZXIpLCBvbkNvbnRleHRNZW51OiB3cmFwSGFuZGxlcihvbkNvbnRleHRNZW51LCBjb250YWluZXIpLCBvbldoZWVsOiB3cmFwSGFuZGxlcihvbldoZWVsLCBjb250YWluZXIpLCBvbk1vdXNlRW50ZXI6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IHVuZGVmaW5lZCA6IG9uUGFuZU1vdXNlRW50ZXIsIG9uTW91c2VEb3duOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyBvbk1vdXNlRG93biA6IHVuZGVmaW5lZCwgb25Nb3VzZU1vdmU6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uTW91c2VNb3ZlIDogb25QYW5lTW91c2VNb3ZlLCBvbk1vdXNlVXA6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uTW91c2VVcCA6IHVuZGVmaW5lZCwgb25Nb3VzZUxlYXZlOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyBvbk1vdXNlTGVhdmUgOiBvblBhbmVNb3VzZUxlYXZlLCByZWY6IGNvbnRhaW5lciwgc3R5bGU6IGNvbnRhaW5lclN0eWxlIH0sXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFVzZXJTZWxlY3Rpb24sIG51bGwpKSk7XG59KTtcblBhbmUuZGlzcGxheU5hbWUgPSAnUGFuZSc7XG5cbmZ1bmN0aW9uIGlzUGFyZW50U2VsZWN0ZWQobm9kZSwgbm9kZUludGVybmFscykge1xuICAgIGlmICghbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGVJbnRlcm5hbHMuZ2V0KG5vZGUucGFyZW50Tm9kZSk7XG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBhcmVudE5vZGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc1BhcmVudFNlbGVjdGVkKHBhcmVudE5vZGUsIG5vZGVJbnRlcm5hbHMpO1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0b3IodGFyZ2V0LCBzZWxlY3Rvciwgbm9kZVJlZikge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKGN1cnJlbnQ/Lm1hdGNoZXMoc2VsZWN0b3IpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBub2RlUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgfSB3aGlsZSAoY3VycmVudCk7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gbG9va3MgZm9yIGFsbCBzZWxlY3RlZCBub2RlcyBhbmQgY3JlYXRlZCBhIE5vZGVEcmFnSXRlbSBmb3IgZWFjaCBvZiB0aGVtXG5mdW5jdGlvbiBnZXREcmFnSXRlbXMobm9kZUludGVybmFscywgbm9kZXNEcmFnZ2FibGUsIG1vdXNlUG9zLCBub2RlSWQpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShub2RlSW50ZXJuYWxzLnZhbHVlcygpKVxuICAgICAgICAuZmlsdGVyKChuKSA9PiAobi5zZWxlY3RlZCB8fCBuLmlkID09PSBub2RlSWQpICYmXG4gICAgICAgICghbi5wYXJlbnROb2RlIHx8ICFpc1BhcmVudFNlbGVjdGVkKG4sIG5vZGVJbnRlcm5hbHMpKSAmJlxuICAgICAgICAobi5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBuLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKSlcbiAgICAgICAgLm1hcCgobikgPT4gKHtcbiAgICAgICAgaWQ6IG4uaWQsXG4gICAgICAgIHBvc2l0aW9uOiBuLnBvc2l0aW9uIHx8IHsgeDogMCwgeTogMCB9LFxuICAgICAgICBwb3NpdGlvbkFic29sdXRlOiBuLnBvc2l0aW9uQWJzb2x1dGUgfHwgeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgIGRpc3RhbmNlOiB7XG4gICAgICAgICAgICB4OiBtb3VzZVBvcy54IC0gKG4ucG9zaXRpb25BYnNvbHV0ZT8ueCA/PyAwKSxcbiAgICAgICAgICAgIHk6IG1vdXNlUG9zLnkgLSAobi5wb3NpdGlvbkFic29sdXRlPy55ID8/IDApLFxuICAgICAgICB9LFxuICAgICAgICBkZWx0YToge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVudDogbi5leHRlbnQsXG4gICAgICAgIHBhcmVudE5vZGU6IG4ucGFyZW50Tm9kZSxcbiAgICAgICAgd2lkdGg6IG4ud2lkdGgsXG4gICAgICAgIGhlaWdodDogbi5oZWlnaHQsXG4gICAgICAgIGV4cGFuZFBhcmVudDogbi5leHBhbmRQYXJlbnQsXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gY2xhbXBOb2RlRXh0ZW50KG5vZGUsIGV4dGVudCkge1xuICAgIGlmICghZXh0ZW50IHx8IGV4dGVudCA9PT0gJ3BhcmVudCcpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVudDtcbiAgICB9XG4gICAgcmV0dXJuIFtleHRlbnRbMF0sIFtleHRlbnRbMV1bMF0gLSAobm9kZS53aWR0aCB8fCAwKSwgZXh0ZW50WzFdWzFdIC0gKG5vZGUuaGVpZ2h0IHx8IDApXV07XG59XG5mdW5jdGlvbiBjYWxjTmV4dFBvc2l0aW9uKG5vZGUsIG5leHRQb3NpdGlvbiwgbm9kZUludGVybmFscywgbm9kZUV4dGVudCwgbm9kZU9yaWdpbiA9IFswLCAwXSwgb25FcnJvcikge1xuICAgIGNvbnN0IGNsYW1wZWROb2RlRXh0ZW50ID0gY2xhbXBOb2RlRXh0ZW50KG5vZGUsIG5vZGUuZXh0ZW50IHx8IG5vZGVFeHRlbnQpO1xuICAgIGxldCBjdXJyZW50RXh0ZW50ID0gY2xhbXBlZE5vZGVFeHRlbnQ7XG4gICAgaWYgKG5vZGUuZXh0ZW50ID09PSAncGFyZW50JyAmJiAhbm9kZS5leHBhbmRQYXJlbnQpIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLndpZHRoICYmIG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlSW50ZXJuYWxzLmdldChub2RlLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgY29uc3QgeyB4OiBwYXJlbnRYLCB5OiBwYXJlbnRZIH0gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKHBhcmVudCwgbm9kZU9yaWdpbikucG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIGN1cnJlbnRFeHRlbnQgPVxuICAgICAgICAgICAgICAgIHBhcmVudCAmJiBpc051bWVyaWMocGFyZW50WCkgJiYgaXNOdW1lcmljKHBhcmVudFkpICYmIGlzTnVtZXJpYyhwYXJlbnQud2lkdGgpICYmIGlzTnVtZXJpYyhwYXJlbnQuaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJlbnRYICsgbm9kZS53aWR0aCAqIG5vZGVPcmlnaW5bMF0sIHBhcmVudFkgKyBub2RlLmhlaWdodCAqIG5vZGVPcmlnaW5bMV1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFggKyBwYXJlbnQud2lkdGggLSBub2RlLndpZHRoICsgbm9kZS53aWR0aCAqIG5vZGVPcmlnaW5bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50WSArIHBhcmVudC5oZWlnaHQgLSBub2RlLmhlaWdodCArIG5vZGUuaGVpZ2h0ICogbm9kZU9yaWdpblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50RXh0ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25FcnJvcj8uKCcwMDUnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNSddKCkpO1xuICAgICAgICAgICAgY3VycmVudEV4dGVudCA9IGNsYW1wZWROb2RlRXh0ZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUuZXh0ZW50ICYmIG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLmV4dGVudCAhPT0gJ3BhcmVudCcpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZUludGVybmFscy5nZXQobm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgY29uc3QgeyB4OiBwYXJlbnRYLCB5OiBwYXJlbnRZIH0gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKHBhcmVudCwgbm9kZU9yaWdpbikucG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgY3VycmVudEV4dGVudCA9IFtcbiAgICAgICAgICAgIFtub2RlLmV4dGVudFswXVswXSArIHBhcmVudFgsIG5vZGUuZXh0ZW50WzBdWzFdICsgcGFyZW50WV0sXG4gICAgICAgICAgICBbbm9kZS5leHRlbnRbMV1bMF0gKyBwYXJlbnRYLCBub2RlLmV4dGVudFsxXVsxXSArIHBhcmVudFldLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBsZXQgcGFyZW50UG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlSW50ZXJuYWxzLmdldChub2RlLnBhcmVudE5vZGUpO1xuICAgICAgICBwYXJlbnRQb3NpdGlvbiA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4ocGFyZW50Tm9kZSwgbm9kZU9yaWdpbikucG9zaXRpb25BYnNvbHV0ZTtcbiAgICB9XG4gICAgY29uc3QgcG9zaXRpb25BYnNvbHV0ZSA9IGN1cnJlbnRFeHRlbnQgJiYgY3VycmVudEV4dGVudCAhPT0gJ3BhcmVudCdcbiAgICAgICAgPyBjbGFtcFBvc2l0aW9uKG5leHRQb3NpdGlvbiwgY3VycmVudEV4dGVudClcbiAgICAgICAgOiBuZXh0UG9zaXRpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHBvc2l0aW9uQWJzb2x1dGUueCAtIHBhcmVudFBvc2l0aW9uLngsXG4gICAgICAgICAgICB5OiBwb3NpdGlvbkFic29sdXRlLnkgLSBwYXJlbnRQb3NpdGlvbi55LFxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbkFic29sdXRlLFxuICAgIH07XG59XG4vLyByZXR1cm5zIHR3byBwYXJhbXM6XG4vLyAxLiB0aGUgZHJhZ2dlZCBub2RlIChvciB0aGUgZmlyc3Qgb2YgdGhlIGxpc3QsIGlmIHdlIGFyZSBkcmFnZ2luZyBhIG5vZGUgc2VsZWN0aW9uKVxuLy8gMi4gYXJyYXkgb2Ygc2VsZWN0ZWQgbm9kZXMgKGZvciBtdWx0aSBzZWxlY3Rpb25zKVxuZnVuY3Rpb24gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHsgbm9kZUlkLCBkcmFnSXRlbXMsIG5vZGVJbnRlcm5hbHMsIH0pIHtcbiAgICBjb25zdCBleHRlbnRlZERyYWdJdGVtcyA9IGRyYWdJdGVtcy5tYXAoKG4pID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVJbnRlcm5hbHMuZ2V0KG4uaWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuLnBvc2l0aW9uLFxuICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZTogbi5wb3NpdGlvbkFic29sdXRlLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBbbm9kZUlkID8gZXh0ZW50ZWREcmFnSXRlbXMuZmluZCgobikgPT4gbi5pZCA9PT0gbm9kZUlkKSA6IGV4dGVudGVkRHJhZ0l0ZW1zWzBdLCBleHRlbnRlZERyYWdJdGVtc107XG59XG5cbmNvbnN0IGdldEhhbmRsZUJvdW5kcyA9IChzZWxlY3Rvciwgbm9kZUVsZW1lbnQsIHpvb20sIG5vZGVPcmlnaW4pID0+IHtcbiAgICBjb25zdCBoYW5kbGVzID0gbm9kZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgaWYgKCFoYW5kbGVzIHx8ICFoYW5kbGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlc0FycmF5ID0gQXJyYXkuZnJvbShoYW5kbGVzKTtcbiAgICBjb25zdCBub2RlQm91bmRzID0gbm9kZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgbm9kZU9mZnNldCA9IHtcbiAgICAgICAgeDogbm9kZUJvdW5kcy53aWR0aCAqIG5vZGVPcmlnaW5bMF0sXG4gICAgICAgIHk6IG5vZGVCb3VuZHMuaGVpZ2h0ICogbm9kZU9yaWdpblsxXSxcbiAgICB9O1xuICAgIHJldHVybiBoYW5kbGVzQXJyYXkubWFwKChoYW5kbGUpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlQm91bmRzID0gaGFuZGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGhhbmRsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFuZGxlaWQnKSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBoYW5kbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZXBvcycpLFxuICAgICAgICAgICAgeDogKGhhbmRsZUJvdW5kcy5sZWZ0IC0gbm9kZUJvdW5kcy5sZWZ0IC0gbm9kZU9mZnNldC54KSAvIHpvb20sXG4gICAgICAgICAgICB5OiAoaGFuZGxlQm91bmRzLnRvcCAtIG5vZGVCb3VuZHMudG9wIC0gbm9kZU9mZnNldC55KSAvIHpvb20sXG4gICAgICAgICAgICAuLi5nZXREaW1lbnNpb25zKGhhbmRsZSksXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZ2V0TW91c2VIYW5kbGVyKGlkLCBnZXRTdGF0ZSwgaGFuZGxlcikge1xuICAgIHJldHVybiBoYW5kbGVyID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBoYW5kbGVyXG4gICAgICAgIDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gZ2V0U3RhdGUoKS5ub2RlSW50ZXJuYWxzLmdldChpZCk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoZXZlbnQsIHsgLi4ubm9kZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbn1cbi8vIHRoaXMgaGFuZGxlciBpcyBjYWxsZWQgYnlcbi8vIDEuIHRoZSBjbGljayBoYW5kbGVyIHdoZW4gbm9kZSBpcyBub3QgZHJhZ2dhYmxlIG9yIHNlbGVjdE5vZGVzT25EcmFnID0gZmFsc2Vcbi8vIG9yXG4vLyAyLiB0aGUgb24gZHJhZyBzdGFydCBoYW5kbGVyIHdoZW4gbm9kZSBpcyBkcmFnZ2FibGUgYW5kIHNlbGVjdE5vZGVzT25EcmFnID0gdHJ1ZVxuZnVuY3Rpb24gaGFuZGxlTm9kZUNsaWNrKHsgaWQsIHN0b3JlLCB1bnNlbGVjdCA9IGZhbHNlLCBub2RlUmVmLCB9KSB7XG4gICAgY29uc3QgeyBhZGRTZWxlY3RlZE5vZGVzLCB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIG11bHRpU2VsZWN0aW9uQWN0aXZlLCBub2RlSW50ZXJuYWxzLCBvbkVycm9yIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IG5vZGUgPSBub2RlSW50ZXJuYWxzLmdldChpZCk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIG9uRXJyb3I/LignMDEyJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTInXShpZCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgIGlmICghbm9kZS5zZWxlY3RlZCkge1xuICAgICAgICBhZGRTZWxlY3RlZE5vZGVzKFtpZF0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh1bnNlbGVjdCB8fCAobm9kZS5zZWxlY3RlZCAmJiBtdWx0aVNlbGVjdGlvbkFjdGl2ZSkpIHtcbiAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzKHsgbm9kZXM6IFtub2RlXSwgZWRnZXM6IFtdIH0pO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gbm9kZVJlZj8uY3VycmVudD8uYmx1cigpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVzZUdldFBvaW50ZXJQb3NpdGlvbigpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgLy8gcmV0dXJucyB0aGUgcG9pbnRlciBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gdGhlIFJGIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgY29uc3QgZ2V0UG9pbnRlclBvc2l0aW9uID0gdXNlQ2FsbGJhY2soKHsgc291cmNlRXZlbnQgfSkgPT4ge1xuICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IHggPSBzb3VyY2VFdmVudC50b3VjaGVzID8gc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRYIDogc291cmNlRXZlbnQuY2xpZW50WDtcbiAgICAgICAgY29uc3QgeSA9IHNvdXJjZUV2ZW50LnRvdWNoZXMgPyBzb3VyY2VFdmVudC50b3VjaGVzWzBdLmNsaWVudFkgOiBzb3VyY2VFdmVudC5jbGllbnRZO1xuICAgICAgICBjb25zdCBwb2ludGVyUG9zID0ge1xuICAgICAgICAgICAgeDogKHggLSB0cmFuc2Zvcm1bMF0pIC8gdHJhbnNmb3JtWzJdLFxuICAgICAgICAgICAgeTogKHkgLSB0cmFuc2Zvcm1bMV0pIC8gdHJhbnNmb3JtWzJdLFxuICAgICAgICB9O1xuICAgICAgICAvLyB3ZSBuZWVkIHRoZSBzbmFwcGVkIHBvc2l0aW9uIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gc2tpcCB1bm5lY2Vzc2FyeSBkcmFnIGV2ZW50c1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeFNuYXBwZWQ6IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFswXSAqIE1hdGgucm91bmQocG9pbnRlclBvcy54IC8gc25hcEdyaWRbMF0pIDogcG9pbnRlclBvcy54LFxuICAgICAgICAgICAgeVNuYXBwZWQ6IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFsxXSAqIE1hdGgucm91bmQocG9pbnRlclBvcy55IC8gc25hcEdyaWRbMV0pIDogcG9pbnRlclBvcy55LFxuICAgICAgICAgICAgLi4ucG9pbnRlclBvcyxcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGdldFBvaW50ZXJQb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gd3JhcFNlbGVjdGlvbkRyYWdGdW5jKHNlbGVjdGlvbkZ1bmMpIHtcbiAgICByZXR1cm4gKGV2ZW50LCBfLCBub2RlcykgPT4gc2VsZWN0aW9uRnVuYz8uKGV2ZW50LCBub2Rlcyk7XG59XG5mdW5jdGlvbiB1c2VEcmFnKHsgbm9kZVJlZiwgZGlzYWJsZWQgPSBmYWxzZSwgbm9EcmFnQ2xhc3NOYW1lLCBoYW5kbGVTZWxlY3Rvciwgbm9kZUlkLCBpc1NlbGVjdGFibGUsIHNlbGVjdE5vZGVzT25EcmFnLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IFtkcmFnZ2luZywgc2V0RHJhZ2dpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGRyYWdJdGVtcyA9IHVzZVJlZihbXSk7XG4gICAgY29uc3QgbGFzdFBvcyA9IHVzZVJlZih7IHg6IG51bGwsIHk6IG51bGwgfSk7XG4gICAgY29uc3QgYXV0b1BhbklkID0gdXNlUmVmKDApO1xuICAgIGNvbnN0IGNvbnRhaW5lckJvdW5kcyA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBtb3VzZVBvc2l0aW9uID0gdXNlUmVmKHsgeDogMCwgeTogMCB9KTtcbiAgICBjb25zdCBkcmFnRXZlbnQgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgYXV0b1BhblN0YXJ0ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGRyYWdTdGFydGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBnZXRQb2ludGVyUG9zaXRpb24gPSB1c2VHZXRQb2ludGVyUG9zaXRpb24oKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobm9kZVJlZj8uY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc2VsZWN0KG5vZGVSZWYuY3VycmVudCk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVOb2RlcyA9ICh7IHgsIHkgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUludGVybmFscywgb25Ob2RlRHJhZywgb25TZWxlY3Rpb25EcmFnLCB1cGRhdGVOb2RlUG9zaXRpb25zLCBub2RlRXh0ZW50LCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgb25FcnJvciwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgbGFzdFBvcy5jdXJyZW50ID0geyB4LCB5IH07XG4gICAgICAgICAgICAgICAgbGV0IGhhc0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBub2Rlc0JveCA9IHsgeDogMCwgeTogMCwgeDI6IDAsIHkyOiAwIH07XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdJdGVtcy5jdXJyZW50Lmxlbmd0aCA+IDEgJiYgbm9kZUV4dGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gZ2V0Tm9kZXNCb3VuZHMoZHJhZ0l0ZW1zLmN1cnJlbnQsIG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgICAgICAgICBub2Rlc0JveCA9IHJlY3RUb0JveChyZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLmN1cnJlbnQgPSBkcmFnSXRlbXMuY3VycmVudC5tYXAoKG4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFBvc2l0aW9uID0geyB4OiB4IC0gbi5kaXN0YW5jZS54LCB5OiB5IC0gbi5kaXN0YW5jZS55IH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbmFwVG9HcmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24ueCA9IHNuYXBHcmlkWzBdICogTWF0aC5yb3VuZChuZXh0UG9zaXRpb24ueCAvIHNuYXBHcmlkWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbi55ID0gc25hcEdyaWRbMV0gKiBNYXRoLnJvdW5kKG5leHRQb3NpdGlvbi55IC8gc25hcEdyaWRbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIHNlbGVjdGlvbiB3aXRoIG11bHRpcGxlIG5vZGVzIGFuZCBhIG5vZGUgZXh0ZW50IGlzIHNldCwgd2UgbmVlZCB0byBhZGp1c3QgdGhlIG5vZGUgZXh0ZW50IGZvciBlYWNoIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFzZWQgb24gaXRzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIG5vZGUgc3RheXMgYXQgaXQncyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGp1c3RlZE5vZGVFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBbbm9kZUV4dGVudFswXVswXSwgbm9kZUV4dGVudFswXVsxXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbbm9kZUV4dGVudFsxXVswXSwgbm9kZUV4dGVudFsxXVsxXV0sXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmFnSXRlbXMuY3VycmVudC5sZW5ndGggPiAxICYmIG5vZGVFeHRlbnQgJiYgIW4uZXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZE5vZGVFeHRlbnRbMF1bMF0gPSBuLnBvc2l0aW9uQWJzb2x1dGUueCAtIG5vZGVzQm94LnggKyBub2RlRXh0ZW50WzBdWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWROb2RlRXh0ZW50WzFdWzBdID0gbi5wb3NpdGlvbkFic29sdXRlLnggKyAobi53aWR0aCA/PyAwKSAtIG5vZGVzQm94LngyICsgbm9kZUV4dGVudFsxXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdGVkTm9kZUV4dGVudFswXVsxXSA9IG4ucG9zaXRpb25BYnNvbHV0ZS55IC0gbm9kZXNCb3gueSArIG5vZGVFeHRlbnRbMF1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZE5vZGVFeHRlbnRbMV1bMV0gPSBuLnBvc2l0aW9uQWJzb2x1dGUueSArIChuLmhlaWdodCA/PyAwKSAtIG5vZGVzQm94LnkyICsgbm9kZUV4dGVudFsxXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkUG9zID0gY2FsY05leHRQb3NpdGlvbihuLCBuZXh0UG9zaXRpb24sIG5vZGVJbnRlcm5hbHMsIGFkanVzdGVkTm9kZUV4dGVudCwgbm9kZU9yaWdpbiwgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgd2Ugb25seSBmaXJlIGEgY2hhbmdlIGV2ZW50IHdoZW4gdGhlcmUgaXMgYSBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2hhbmdlID0gaGFzQ2hhbmdlIHx8IG4ucG9zaXRpb24ueCAhPT0gdXBkYXRlZFBvcy5wb3NpdGlvbi54IHx8IG4ucG9zaXRpb24ueSAhPT0gdXBkYXRlZFBvcy5wb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgICAgICBuLnBvc2l0aW9uID0gdXBkYXRlZFBvcy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgbi5wb3NpdGlvbkFic29sdXRlID0gdXBkYXRlZFBvcy5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMoZHJhZ0l0ZW1zLmN1cnJlbnQsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNldERyYWdnaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uRHJhZyA9IG5vZGVJZCA/IG9uTm9kZURyYWcgOiB3cmFwU2VsZWN0aW9uRHJhZ0Z1bmMob25TZWxlY3Rpb25EcmFnKTtcbiAgICAgICAgICAgICAgICBpZiAob25EcmFnICYmIGRyYWdFdmVudC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50Tm9kZSwgbm9kZXNdID0gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtczogZHJhZ0l0ZW1zLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlSW50ZXJuYWxzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb25EcmFnKGRyYWdFdmVudC5jdXJyZW50LCBjdXJyZW50Tm9kZSwgbm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhdXRvUGFuID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghY29udGFpbmVyQm91bmRzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBbeE1vdmVtZW50LCB5TW92ZW1lbnRdID0gY2FsY0F1dG9QYW4obW91c2VQb3NpdGlvbi5jdXJyZW50LCBjb250YWluZXJCb3VuZHMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHhNb3ZlbWVudCAhPT0gMCB8fCB5TW92ZW1lbnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHBhbkJ5IH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0UG9zLmN1cnJlbnQueCA9IChsYXN0UG9zLmN1cnJlbnQueCA/PyAwKSAtIHhNb3ZlbWVudCAvIHRyYW5zZm9ybVsyXTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBvcy5jdXJyZW50LnkgPSAobGFzdFBvcy5jdXJyZW50LnkgPz8gMCkgLSB5TW92ZW1lbnQgLyB0cmFuc2Zvcm1bMl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYW5CeSh7IHg6IHhNb3ZlbWVudCwgeTogeU1vdmVtZW50IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVOb2RlcyhsYXN0UG9zLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF1dG9QYW5JZC5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGF1dG9QYW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0RHJhZyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUludGVybmFscywgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIG5vZGVzRHJhZ2dhYmxlLCB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIG9uTm9kZURyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnU3RhcnQsIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGRyYWdTdGFydGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uU3RhcnQgPSBub2RlSWQgPyBvbk5vZGVEcmFnU3RhcnQgOiB3cmFwU2VsZWN0aW9uRHJhZ0Z1bmMob25TZWxlY3Rpb25EcmFnU3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmICgoIXNlbGVjdE5vZGVzT25EcmFnIHx8ICFpc1NlbGVjdGFibGUpICYmICFtdWx0aVNlbGVjdGlvbkFjdGl2ZSAmJiBub2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlSW50ZXJuYWxzLmdldChub2RlSWQpPy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXNldCBzZWxlY3RlZCBub2RlcyB3aGVuIHNlbGVjdE5vZGVzT25EcmFnPWZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZUlkICYmIGlzU2VsZWN0YWJsZSAmJiBzZWxlY3ROb2Rlc09uRHJhZykge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJlZjogbm9kZVJlZixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIGxhc3RQb3MuY3VycmVudCA9IHBvaW50ZXJQb3M7XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLmN1cnJlbnQgPSBnZXREcmFnSXRlbXMobm9kZUludGVybmFscywgbm9kZXNEcmFnZ2FibGUsIHBvaW50ZXJQb3MsIG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKG9uU3RhcnQgJiYgZHJhZ0l0ZW1zLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2N1cnJlbnROb2RlLCBub2Rlc10gPSBnZXRFdmVudEhhbmRsZXJQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zOiBkcmFnSXRlbXMuY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbnRlcm5hbHMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvblN0YXJ0KGV2ZW50LnNvdXJjZUV2ZW50LCBjdXJyZW50Tm9kZSwgbm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24ub24oJy5kcmFnJywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkcmFnSGFuZGxlciA9IGRyYWcoKVxuICAgICAgICAgICAgICAgICAgICAub24oJ3N0YXJ0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9tTm9kZSwgbm9kZURyYWdUaHJlc2hvbGQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlRHJhZ1RocmVzaG9sZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREcmFnKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludGVyUG9zID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBvcy5jdXJyZW50ID0gcG9pbnRlclBvcztcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyQm91bmRzLmN1cnJlbnQgPSBkb21Ob2RlPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICBtb3VzZVBvc2l0aW9uLmN1cnJlbnQgPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCBjb250YWluZXJCb3VuZHMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdkcmFnJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGF1dG9QYW5Pbk5vZGVEcmFnLCBub2RlRHJhZ1RocmVzaG9sZCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdXRvUGFuU3RhcnRlZC5jdXJyZW50ICYmIGRyYWdTdGFydGVkLmN1cnJlbnQgJiYgYXV0b1Bhbk9uTm9kZURyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1BhbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IHBvaW50ZXJQb3MueFNuYXBwZWQgLSAobGFzdFBvcz8uY3VycmVudD8ueCA/PyAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBwb2ludGVyUG9zLnlTbmFwcGVkIC0gKGxhc3RQb3M/LmN1cnJlbnQ/LnkgPz8gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IG5vZGVEcmFnVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREcmFnKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIGV2ZW50cyB3aXRob3V0IG1vdmVtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICgobGFzdFBvcy5jdXJyZW50LnggIT09IHBvaW50ZXJQb3MueFNuYXBwZWQgfHwgbGFzdFBvcy5jdXJyZW50LnkgIT09IHBvaW50ZXJQb3MueVNuYXBwZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnSXRlbXMuY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ1N0YXJ0ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0V2ZW50LmN1cnJlbnQgPSBldmVudC5zb3VyY2VFdmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlUG9zaXRpb24uY3VycmVudCA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIGNvbnRhaW5lckJvdW5kcy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVzKHBvaW50ZXJQb3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdlbmQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkcmFnU3RhcnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0RHJhZ2dpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhdXRvUGFuU3RhcnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdTdGFydGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYXV0b1BhbklkLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ0l0ZW1zLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdXBkYXRlTm9kZVBvc2l0aW9ucywgbm9kZUludGVybmFscywgb25Ob2RlRHJhZ1N0b3AsIG9uU2VsZWN0aW9uRHJhZ1N0b3AgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvblN0b3AgPSBub2RlSWQgPyBvbk5vZGVEcmFnU3RvcCA6IHdyYXBTZWxlY3Rpb25EcmFnRnVuYyhvblNlbGVjdGlvbkRyYWdTdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMoZHJhZ0l0ZW1zLmN1cnJlbnQsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25TdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2N1cnJlbnROb2RlLCBub2Rlc10gPSBnZXRFdmVudEhhbmRsZXJQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtczogZHJhZ0l0ZW1zLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbnRlcm5hbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdG9wKGV2ZW50LnNvdXJjZUV2ZW50LCBjdXJyZW50Tm9kZSwgbm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0RyYWdnYWJsZSA9ICFldmVudC5idXR0b24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghbm9EcmFnQ2xhc3NOYW1lIHx8ICFoYXNTZWxlY3Rvcih0YXJnZXQsIGAuJHtub0RyYWdDbGFzc05hbWV9YCwgbm9kZVJlZikpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWhhbmRsZVNlbGVjdG9yIHx8IGhhc1NlbGVjdG9yKHRhcmdldCwgaGFuZGxlU2VsZWN0b3IsIG5vZGVSZWYpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRHJhZ2dhYmxlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5jYWxsKGRyYWdIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24ub24oJy5kcmFnJywgbnVsbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgbm9kZVJlZixcbiAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgIG5vRHJhZ0NsYXNzTmFtZSxcbiAgICAgICAgaGFuZGxlU2VsZWN0b3IsXG4gICAgICAgIGlzU2VsZWN0YWJsZSxcbiAgICAgICAgc3RvcmUsXG4gICAgICAgIG5vZGVJZCxcbiAgICAgICAgc2VsZWN0Tm9kZXNPbkRyYWcsXG4gICAgICAgIGdldFBvaW50ZXJQb3NpdGlvbixcbiAgICBdKTtcbiAgICByZXR1cm4gZHJhZ2dpbmc7XG59XG5cbmZ1bmN0aW9uIHVzZVVwZGF0ZU5vZGVQb3NpdGlvbnMoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHVwZGF0ZVBvc2l0aW9ucyA9IHVzZUNhbGxiYWNrKChwYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBub2RlSW50ZXJuYWxzLCBub2RlRXh0ZW50LCB1cGRhdGVOb2RlUG9zaXRpb25zLCBnZXROb2Rlcywgc25hcFRvR3JpZCwgc25hcEdyaWQsIG9uRXJyb3IsIG5vZGVzRHJhZ2dhYmxlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gZ2V0Tm9kZXMoKS5maWx0ZXIoKG4pID0+IG4uc2VsZWN0ZWQgJiYgKG4uZHJhZ2dhYmxlIHx8IChub2Rlc0RyYWdnYWJsZSAmJiB0eXBlb2Ygbi5kcmFnZ2FibGUgPT09ICd1bmRlZmluZWQnKSkpO1xuICAgICAgICAvLyBieSBkZWZhdWx0IGEgbm9kZSBtb3ZlcyA1cHggb24gZWFjaCBrZXkgcHJlc3MsIG9yIDIwcHggaWYgc2hpZnQgaXMgcHJlc3NlZFxuICAgICAgICAvLyBpZiBzbmFwIGdyaWQgaXMgZW5hYmxlZCwgd2UgdXNlIHRoYXQgZm9yIHRoZSB2ZWxvY2l0eS5cbiAgICAgICAgY29uc3QgeFZlbG8gPSBzbmFwVG9HcmlkID8gc25hcEdyaWRbMF0gOiA1O1xuICAgICAgICBjb25zdCB5VmVsbyA9IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFsxXSA6IDU7XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IHBhcmFtcy5pc1NoaWZ0UHJlc3NlZCA/IDQgOiAxO1xuICAgICAgICBjb25zdCBwb3NpdGlvbkRpZmZYID0gcGFyYW1zLnggKiB4VmVsbyAqIGZhY3RvcjtcbiAgICAgICAgY29uc3QgcG9zaXRpb25EaWZmWSA9IHBhcmFtcy55ICogeVZlbG8gKiBmYWN0b3I7XG4gICAgICAgIGNvbnN0IG5vZGVVcGRhdGVzID0gc2VsZWN0ZWROb2Rlcy5tYXAoKG4pID0+IHtcbiAgICAgICAgICAgIGlmIChuLnBvc2l0aW9uQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSB7IHg6IG4ucG9zaXRpb25BYnNvbHV0ZS54ICsgcG9zaXRpb25EaWZmWCwgeTogbi5wb3NpdGlvbkFic29sdXRlLnkgKyBwb3NpdGlvbkRpZmZZIH07XG4gICAgICAgICAgICAgICAgaWYgKHNuYXBUb0dyaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uLnggPSBzbmFwR3JpZFswXSAqIE1hdGgucm91bmQobmV4dFBvc2l0aW9uLnggLyBzbmFwR3JpZFswXSk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbi55ID0gc25hcEdyaWRbMV0gKiBNYXRoLnJvdW5kKG5leHRQb3NpdGlvbi55IC8gc25hcEdyaWRbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uQWJzb2x1dGUsIHBvc2l0aW9uIH0gPSBjYWxjTmV4dFBvc2l0aW9uKG4sIG5leHRQb3NpdGlvbiwgbm9kZUludGVybmFscywgbm9kZUV4dGVudCwgdW5kZWZpbmVkLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBuLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgbi5wb3NpdGlvbkFic29sdXRlID0gcG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9KTtcbiAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhub2RlVXBkYXRlcywgdHJ1ZSwgZmFsc2UpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdXBkYXRlUG9zaXRpb25zO1xufVxuXG5jb25zdCBhcnJvd0tleURpZmZzID0ge1xuICAgIEFycm93VXA6IHsgeDogMCwgeTogLTEgfSxcbiAgICBBcnJvd0Rvd246IHsgeDogMCwgeTogMSB9LFxuICAgIEFycm93TGVmdDogeyB4OiAtMSwgeTogMCB9LFxuICAgIEFycm93UmlnaHQ6IHsgeDogMSwgeTogMCB9LFxufTtcbnZhciB3cmFwTm9kZSA9IChOb2RlQ29tcG9uZW50KSA9PiB7XG4gICAgY29uc3QgTm9kZVdyYXBwZXIgPSAoeyBpZCwgdHlwZSwgZGF0YSwgeFBvcywgeVBvcywgeFBvc09yaWdpbiwgeVBvc09yaWdpbiwgc2VsZWN0ZWQsIG9uQ2xpY2ssIG9uTW91c2VFbnRlciwgb25Nb3VzZU1vdmUsIG9uTW91c2VMZWF2ZSwgb25Db250ZXh0TWVudSwgb25Eb3VibGVDbGljaywgc3R5bGUsIGNsYXNzTmFtZSwgaXNEcmFnZ2FibGUsIGlzU2VsZWN0YWJsZSwgaXNDb25uZWN0YWJsZSwgaXNGb2N1c2FibGUsIHNlbGVjdE5vZGVzT25EcmFnLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24sIGhpZGRlbiwgcmVzaXplT2JzZXJ2ZXIsIGRyYWdIYW5kbGUsIHpJbmRleCwgaXNQYXJlbnQsIG5vRHJhZ0NsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGluaXRpYWxpemVkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBhcmlhTGFiZWwsIHJmSWQsIH0pID0+IHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgICAgICBjb25zdCBub2RlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgICAgICBjb25zdCBwcmV2U291cmNlUG9zaXRpb24gPSB1c2VSZWYoc291cmNlUG9zaXRpb24pO1xuICAgICAgICBjb25zdCBwcmV2VGFyZ2V0UG9zaXRpb24gPSB1c2VSZWYodGFyZ2V0UG9zaXRpb24pO1xuICAgICAgICBjb25zdCBwcmV2VHlwZSA9IHVzZVJlZih0eXBlKTtcbiAgICAgICAgY29uc3QgaGFzUG9pbnRlckV2ZW50cyA9IGlzU2VsZWN0YWJsZSB8fCBpc0RyYWdnYWJsZSB8fCBvbkNsaWNrIHx8IG9uTW91c2VFbnRlciB8fCBvbk1vdXNlTW92ZSB8fCBvbk1vdXNlTGVhdmU7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVBvc2l0aW9ucyA9IHVzZVVwZGF0ZU5vZGVQb3NpdGlvbnMoKTtcbiAgICAgICAgY29uc3Qgb25Nb3VzZUVudGVySGFuZGxlciA9IGdldE1vdXNlSGFuZGxlcihpZCwgc3RvcmUuZ2V0U3RhdGUsIG9uTW91c2VFbnRlcik7XG4gICAgICAgIGNvbnN0IG9uTW91c2VNb3ZlSGFuZGxlciA9IGdldE1vdXNlSGFuZGxlcihpZCwgc3RvcmUuZ2V0U3RhdGUsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgY29uc3Qgb25Nb3VzZUxlYXZlSGFuZGxlciA9IGdldE1vdXNlSGFuZGxlcihpZCwgc3RvcmUuZ2V0U3RhdGUsIG9uTW91c2VMZWF2ZSk7XG4gICAgICAgIGNvbnN0IG9uQ29udGV4dE1lbnVIYW5kbGVyID0gZ2V0TW91c2VIYW5kbGVyKGlkLCBzdG9yZS5nZXRTdGF0ZSwgb25Db250ZXh0TWVudSk7XG4gICAgICAgIGNvbnN0IG9uRG91YmxlQ2xpY2tIYW5kbGVyID0gZ2V0TW91c2VIYW5kbGVyKGlkLCBzdG9yZS5nZXRTdGF0ZSwgb25Eb3VibGVDbGljayk7XG4gICAgICAgIGNvbnN0IG9uU2VsZWN0Tm9kZUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZURyYWdUaHJlc2hvbGQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBpZiAoaXNTZWxlY3RhYmxlICYmICghc2VsZWN0Tm9kZXNPbkRyYWcgfHwgIWlzRHJhZ2dhYmxlIHx8IG5vZGVEcmFnVGhyZXNob2xkID4gMCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGhhbmRsZXIgZ2V0cyBjYWxsZWQgd2l0aGluIHRoZSBkcmFnIHN0YXJ0IGV2ZW50IHdoZW4gc2VsZWN0Tm9kZXNPbkRyYWc9dHJ1ZVxuICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVDbGljayh7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZVJlZixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHN0b3JlLmdldFN0YXRlKCkubm9kZUludGVybmFscy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIHsgLi4ubm9kZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzSW5wdXRET01Ob2RlKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtZW50U2VsZWN0aW9uS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpICYmIGlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuc2VsZWN0ID0gZXZlbnQua2V5ID09PSAnRXNjYXBlJztcbiAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIHVuc2VsZWN0LFxuICAgICAgICAgICAgICAgICAgICBub2RlUmVmLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWRpc2FibGVLZXlib2FyZEExMXkgJiZcbiAgICAgICAgICAgICAgICBpc0RyYWdnYWJsZSAmJlxuICAgICAgICAgICAgICAgIHNlbGVjdGVkICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFycm93S2V5RGlmZnMsIGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGFyaWFMaXZlTWVzc2FnZTogYE1vdmVkIHNlbGVjdGVkIG5vZGUgJHtldmVudC5rZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdBcnJvdycsICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCl9LiBOZXcgcG9zaXRpb24sIHg6ICR7fn54UG9zfSwgeTogJHt+fnlQb3N9YCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB1cGRhdGVQb3NpdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICB4OiBhcnJvd0tleURpZmZzW2V2ZW50LmtleV0ueCxcbiAgICAgICAgICAgICAgICAgICAgeTogYXJyb3dLZXlEaWZmc1tldmVudC5rZXldLnksXG4gICAgICAgICAgICAgICAgICAgIGlzU2hpZnRQcmVzc2VkOiBldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlUmVmLmN1cnJlbnQgJiYgIWhpZGRlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJOb2RlID0gbm9kZVJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy5vYnNlcnZlKGN1cnJOb2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gcmVzaXplT2JzZXJ2ZXI/LnVub2JzZXJ2ZShjdXJyTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtoaWRkZW5dKTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIHVzZXIgcHJvZ3JhbW1hdGljYWxseSBjaGFuZ2VzIHRoZSBzb3VyY2Ugb3IgaGFuZGxlIHBvc2l0aW9uLCB3ZSByZS1pbml0aWFsaXplIHRoZSBub2RlXG4gICAgICAgICAgICBjb25zdCB0eXBlQ2hhbmdlZCA9IHByZXZUeXBlLmN1cnJlbnQgIT09IHR5cGU7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQb3NDaGFuZ2VkID0gcHJldlNvdXJjZVBvc2l0aW9uLmN1cnJlbnQgIT09IHNvdXJjZVBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UG9zQ2hhbmdlZCA9IHByZXZUYXJnZXRQb3NpdGlvbi5jdXJyZW50ICE9PSB0YXJnZXRQb3NpdGlvbjtcbiAgICAgICAgICAgIGlmIChub2RlUmVmLmN1cnJlbnQgJiYgKHR5cGVDaGFuZ2VkIHx8IHNvdXJjZVBvc0NoYW5nZWQgfHwgdGFyZ2V0UG9zQ2hhbmdlZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlR5cGUuY3VycmVudCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VQb3NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZTb3VyY2VQb3NpdGlvbi5jdXJyZW50ID0gc291cmNlUG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRQb3NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZUYXJnZXRQb3NpdGlvbi5jdXJyZW50ID0gdGFyZ2V0UG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkudXBkYXRlTm9kZURpbWVuc2lvbnMoW3sgaWQsIG5vZGVFbGVtZW50OiBub2RlUmVmLmN1cnJlbnQsIGZvcmNlVXBkYXRlOiB0cnVlIH1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW2lkLCB0eXBlLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb25dKTtcbiAgICAgICAgY29uc3QgZHJhZ2dpbmcgPSB1c2VEcmFnKHtcbiAgICAgICAgICAgIG5vZGVSZWYsXG4gICAgICAgICAgICBkaXNhYmxlZDogaGlkZGVuIHx8ICFpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgIG5vRHJhZ0NsYXNzTmFtZSxcbiAgICAgICAgICAgIGhhbmRsZVNlbGVjdG9yOiBkcmFnSGFuZGxlLFxuICAgICAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgICAgIGlzU2VsZWN0YWJsZSxcbiAgICAgICAgICAgIHNlbGVjdE5vZGVzT25EcmFnLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhpZGRlbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX25vZGUnLFxuICAgICAgICAgICAgICAgIGByZWFjdC1mbG93X19ub2RlLSR7dHlwZX1gLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBvdmVyd3JpdGFibGUgYnkgcGFzc2luZyBgbm9wYW5gIGFzIGEgY2xhc3MgbmFtZVxuICAgICAgICAgICAgICAgICAgICBbbm9QYW5DbGFzc05hbWVdOiBpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogaXNQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKSwgcmVmOiBub2RlUmVmLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIHpJbmRleCxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt4UG9zT3JpZ2lufXB4LCR7eVBvc09yaWdpbn1weClgLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IGhhc1BvaW50ZXJFdmVudHMgPyAnYWxsJyA6ICdub25lJyxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpbml0aWFsaXplZCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgfSwgXCJkYXRhLWlkXCI6IGlkLCBcImRhdGEtdGVzdGlkXCI6IGByZl9fbm9kZS0ke2lkfWAsIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVySGFuZGxlciwgb25Nb3VzZU1vdmU6IG9uTW91c2VNb3ZlSGFuZGxlciwgb25Nb3VzZUxlYXZlOiBvbk1vdXNlTGVhdmVIYW5kbGVyLCBvbkNvbnRleHRNZW51OiBvbkNvbnRleHRNZW51SGFuZGxlciwgb25DbGljazogb25TZWxlY3ROb2RlSGFuZGxlciwgb25Eb3VibGVDbGljazogb25Eb3VibGVDbGlja0hhbmRsZXIsIG9uS2V5RG93bjogaXNGb2N1c2FibGUgPyBvbktleURvd24gOiB1bmRlZmluZWQsIHRhYkluZGV4OiBpc0ZvY3VzYWJsZSA/IDAgOiB1bmRlZmluZWQsIHJvbGU6IGlzRm9jdXNhYmxlID8gJ2J1dHRvbicgOiB1bmRlZmluZWQsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBkaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogYCR7QVJJQV9OT0RFX0RFU0NfS0VZfS0ke3JmSWR9YCwgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChQcm92aWRlciwgeyB2YWx1ZTogaWQgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE5vZGVDb21wb25lbnQsIHsgaWQ6IGlkLCBkYXRhOiBkYXRhLCB0eXBlOiB0eXBlLCB4UG9zOiB4UG9zLCB5UG9zOiB5UG9zLCBzZWxlY3RlZDogc2VsZWN0ZWQsIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUsIHNvdXJjZVBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBkcmFnZ2luZzogZHJhZ2dpbmcsIGRyYWdIYW5kbGU6IGRyYWdIYW5kbGUsIHpJbmRleDogekluZGV4IH0pKSkpO1xuICAgIH07XG4gICAgTm9kZVdyYXBwZXIuZGlzcGxheU5hbWUgPSAnTm9kZVdyYXBwZXInO1xuICAgIHJldHVybiBtZW1vKE5vZGVXcmFwcGVyKTtcbn07XG5cbi8qKlxuICogVGhlIG5vZGVzIHNlbGVjdGlvbiByZWN0YW5nbGUgZ2V0cyBkaXNwbGF5ZWQgd2hlbiBhIHVzZXJcbiAqIG1hZGUgYSBzZWxlY3Rpb24gd2l0aCBvbiBvciBzZXZlcmFsIG5vZGVzXG4gKi9cbmNvbnN0IHNlbGVjdG9yJDcgPSAocykgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzLmdldE5vZGVzKCkuZmlsdGVyKChuKSA9PiBuLnNlbGVjdGVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5nZXROb2Rlc0JvdW5kcyhzZWxlY3RlZE5vZGVzLCBzLm5vZGVPcmlnaW4pLFxuICAgICAgICB0cmFuc2Zvcm1TdHJpbmc6IGB0cmFuc2xhdGUoJHtzLnRyYW5zZm9ybVswXX1weCwke3MudHJhbnNmb3JtWzFdfXB4KSBzY2FsZSgke3MudHJhbnNmb3JtWzJdfSlgLFxuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgfTtcbn07XG5mdW5jdGlvbiBOb2Rlc1NlbGVjdGlvbih7IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB4OiBsZWZ0LCB5OiB0b3AsIHRyYW5zZm9ybVN0cmluZywgdXNlclNlbGVjdGlvbkFjdGl2ZSB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkNywgc2hhbGxvdyk7XG4gICAgY29uc3QgdXBkYXRlUG9zaXRpb25zID0gdXNlVXBkYXRlTm9kZVBvc2l0aW9ucygpO1xuICAgIGNvbnN0IG5vZGVSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFkaXNhYmxlS2V5Ym9hcmRBMTF5KSB7XG4gICAgICAgICAgICBub2RlUmVmLmN1cnJlbnQ/LmZvY3VzKHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbZGlzYWJsZUtleWJvYXJkQTExeV0pO1xuICAgIHVzZURyYWcoe1xuICAgICAgICBub2RlUmVmLFxuICAgIH0pO1xuICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlIHx8ICF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvbkNvbnRleHRNZW51ID0gb25TZWxlY3Rpb25Db250ZXh0TWVudVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHN0b3JlXG4gICAgICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgICAgICAuZ2V0Tm9kZXMoKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG4pID0+IG4uc2VsZWN0ZWQpO1xuICAgICAgICAgICAgb25TZWxlY3Rpb25Db250ZXh0TWVudShldmVudCwgc2VsZWN0ZWROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJyb3dLZXlEaWZmcywgZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgdXBkYXRlUG9zaXRpb25zKHtcbiAgICAgICAgICAgICAgICB4OiBhcnJvd0tleURpZmZzW2V2ZW50LmtleV0ueCxcbiAgICAgICAgICAgICAgICB5OiBhcnJvd0tleURpZmZzW2V2ZW50LmtleV0ueSxcbiAgICAgICAgICAgICAgICBpc1NoaWZ0UHJlc3NlZDogZXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX25vZGVzc2VsZWN0aW9uJywgJ3JlYWN0LWZsb3dfX2NvbnRhaW5lcicsIG5vUGFuQ2xhc3NOYW1lXSksIHN0eWxlOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVN0cmluZyxcbiAgICAgICAgfSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBub2RlUmVmLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbm9kZXNzZWxlY3Rpb24tcmVjdFwiLCBvbkNvbnRleHRNZW51OiBvbkNvbnRleHRNZW51LCB0YWJJbmRleDogZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6IC0xLCBvbktleURvd246IGRpc2FibGVLZXlib2FyZEExMXkgPyB1bmRlZmluZWQgOiBvbktleURvd24sIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgfSB9KSkpO1xufVxudmFyIE5vZGVzU2VsZWN0aW9uJDEgPSBtZW1vKE5vZGVzU2VsZWN0aW9uKTtcblxuY29uc3Qgc2VsZWN0b3IkNiA9IChzKSA9PiBzLm5vZGVzU2VsZWN0aW9uQWN0aXZlO1xuY29uc3QgRmxvd1JlbmRlcmVyID0gKHsgY2hpbGRyZW4sIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGwsIGRlbGV0ZUtleUNvZGUsIG9uTW92ZSwgb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZCwgc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlLCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBlbGVtZW50c1NlbGVjdGFibGUsIHpvb21PblNjcm9sbCwgem9vbU9uUGluY2gsIHBhbk9uU2Nyb2xsOiBfcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZSwgem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uRHJhZzogX3Bhbk9uRHJhZywgZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb20sIG1heFpvb20sIHByZXZlbnRTY3JvbGxpbmcsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCB9KSA9PiB7XG4gICAgY29uc3Qgbm9kZXNTZWxlY3Rpb25BY3RpdmUgPSB1c2VTdG9yZShzZWxlY3RvciQ2KTtcbiAgICBjb25zdCBzZWxlY3Rpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3Moc2VsZWN0aW9uS2V5Q29kZSk7XG4gICAgY29uc3QgcGFuQWN0aXZhdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhwYW5BY3RpdmF0aW9uS2V5Q29kZSk7XG4gICAgY29uc3QgcGFuT25EcmFnID0gcGFuQWN0aXZhdGlvbktleVByZXNzZWQgfHwgX3Bhbk9uRHJhZztcbiAgICBjb25zdCBwYW5PblNjcm9sbCA9IHBhbkFjdGl2YXRpb25LZXlQcmVzc2VkIHx8IF9wYW5PblNjcm9sbDtcbiAgICBjb25zdCBpc1NlbGVjdGluZyA9IHNlbGVjdGlvbktleVByZXNzZWQgfHwgKHNlbGVjdGlvbk9uRHJhZyAmJiBwYW5PbkRyYWcgIT09IHRydWUpO1xuICAgIHVzZUdsb2JhbEtleUhhbmRsZXIoeyBkZWxldGVLZXlDb2RlLCBtdWx0aVNlbGVjdGlvbktleUNvZGUgfSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFpvb21QYW5lLCB7IG9uTW92ZTogb25Nb3ZlLCBvbk1vdmVTdGFydDogb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZDogb25Nb3ZlRW5kLCBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCB6b29tT25TY3JvbGw6IHpvb21PblNjcm9sbCwgem9vbU9uUGluY2g6IHpvb21PblBpbmNoLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljazogem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uRHJhZzogIXNlbGVjdGlvbktleVByZXNzZWQgJiYgcGFuT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBwcmV2ZW50U2Nyb2xsaW5nOiBwcmV2ZW50U2Nyb2xsaW5nLCBub1doZWVsQ2xhc3NOYW1lOiBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChQYW5lLCB7IG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lQ29udGV4dE1lbnU6IG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGw6IG9uUGFuZVNjcm9sbCwgcGFuT25EcmFnOiBwYW5PbkRyYWcsIGlzU2VsZWN0aW5nOiAhIWlzU2VsZWN0aW5nLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlIH0sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIG5vZGVzU2VsZWN0aW9uQWN0aXZlICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KE5vZGVzU2VsZWN0aW9uJDEsIHsgb25TZWxlY3Rpb25Db250ZXh0TWVudTogb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pKSkpKTtcbn07XG5GbG93UmVuZGVyZXIuZGlzcGxheU5hbWUgPSAnRmxvd1JlbmRlcmVyJztcbnZhciBGbG93UmVuZGVyZXIkMSA9IG1lbW8oRmxvd1JlbmRlcmVyKTtcblxuZnVuY3Rpb24gdXNlVmlzaWJsZU5vZGVzKG9ubHlSZW5kZXJWaXNpYmxlKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygocykgPT4gb25seVJlbmRlclZpc2libGVcbiAgICAgICAgPyBnZXROb2Rlc0luc2lkZShzLm5vZGVJbnRlcm5hbHMsIHsgeDogMCwgeTogMCwgd2lkdGg6IHMud2lkdGgsIGhlaWdodDogcy5oZWlnaHQgfSwgcy50cmFuc2Zvcm0sIHRydWUpXG4gICAgICAgIDogcy5nZXROb2RlcygpLCBbb25seVJlbmRlclZpc2libGVdKSk7XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlVHlwZXMobm9kZVR5cGVzKSB7XG4gICAgY29uc3Qgc3RhbmRhcmRUeXBlcyA9IHtcbiAgICAgICAgaW5wdXQ6IHdyYXBOb2RlKChub2RlVHlwZXMuaW5wdXQgfHwgSW5wdXROb2RlJDEpKSxcbiAgICAgICAgZGVmYXVsdDogd3JhcE5vZGUoKG5vZGVUeXBlcy5kZWZhdWx0IHx8IERlZmF1bHROb2RlJDEpKSxcbiAgICAgICAgb3V0cHV0OiB3cmFwTm9kZSgobm9kZVR5cGVzLm91dHB1dCB8fCBPdXRwdXROb2RlJDEpKSxcbiAgICAgICAgZ3JvdXA6IHdyYXBOb2RlKChub2RlVHlwZXMuZ3JvdXAgfHwgR3JvdXBOb2RlKSksXG4gICAgfTtcbiAgICBjb25zdCB3cmFwcGVkVHlwZXMgPSB7fTtcbiAgICBjb25zdCBzcGVjaWFsVHlwZXMgPSBPYmplY3Qua2V5cyhub2RlVHlwZXMpXG4gICAgICAgIC5maWx0ZXIoKGspID0+ICFbJ2lucHV0JywgJ2RlZmF1bHQnLCAnb3V0cHV0JywgJ2dyb3VwJ10uaW5jbHVkZXMoaykpXG4gICAgICAgIC5yZWR1Y2UoKHJlcywga2V5KSA9PiB7XG4gICAgICAgIHJlc1trZXldID0gd3JhcE5vZGUoKG5vZGVUeXBlc1trZXldIHx8IERlZmF1bHROb2RlJDEpKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCB3cmFwcGVkVHlwZXMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YW5kYXJkVHlwZXMsXG4gICAgICAgIC4uLnNwZWNpYWxUeXBlcyxcbiAgICB9O1xufVxuY29uc3QgZ2V0UG9zaXRpb25XaXRoT3JpZ2luID0gKHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgb3JpZ2luLCB9KSA9PiB7XG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9XG4gICAgaWYgKG9yaWdpblswXSA8IDAgfHwgb3JpZ2luWzFdIDwgMCB8fCBvcmlnaW5bMF0gPiAxIHx8IG9yaWdpblsxXSA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4IC0gd2lkdGggKiBvcmlnaW5bMF0sXG4gICAgICAgIHk6IHkgLSBoZWlnaHQgKiBvcmlnaW5bMV0sXG4gICAgfTtcbn07XG5cbmNvbnN0IHNlbGVjdG9yJDUgPSAocykgPT4gKHtcbiAgICBub2Rlc0RyYWdnYWJsZTogcy5ub2Rlc0RyYWdnYWJsZSxcbiAgICBub2Rlc0Nvbm5lY3RhYmxlOiBzLm5vZGVzQ29ubmVjdGFibGUsXG4gICAgbm9kZXNGb2N1c2FibGU6IHMubm9kZXNGb2N1c2FibGUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICB1cGRhdGVOb2RlRGltZW5zaW9uczogcy51cGRhdGVOb2RlRGltZW5zaW9ucyxcbiAgICBvbkVycm9yOiBzLm9uRXJyb3IsXG59KTtcbmNvbnN0IE5vZGVSZW5kZXJlciA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgbm9kZXNEcmFnZ2FibGUsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIHVwZGF0ZU5vZGVEaW1lbnNpb25zLCBvbkVycm9yIH0gPSB1c2VTdG9yZShzZWxlY3RvciQ1LCBzaGFsbG93KTtcbiAgICBjb25zdCBub2RlcyA9IHVzZVZpc2libGVOb2Rlcyhwcm9wcy5vbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzKTtcbiAgICBjb25zdCByZXNpemVPYnNlcnZlclJlZiA9IHVzZVJlZigpO1xuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlcyA9IGVudHJpZXMubWFwKChlbnRyeSkgPT4gKHtcbiAgICAgICAgICAgICAgICBpZDogZW50cnkudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpLFxuICAgICAgICAgICAgICAgIG5vZGVFbGVtZW50OiBlbnRyeS50YXJnZXQsXG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGU6IHRydWUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB1cGRhdGVOb2RlRGltZW5zaW9ucyh1cGRhdGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc2l6ZU9ic2VydmVyUmVmLmN1cnJlbnQgPSBvYnNlcnZlcjtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXJSZWY/LmN1cnJlbnQ/LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX25vZGVzXCIsIHN0eWxlOiBjb250YWluZXJTdHlsZSB9LCBub2Rlcy5tYXAoKG5vZGUpID0+IHtcbiAgICAgICAgbGV0IG5vZGVUeXBlID0gbm9kZS50eXBlIHx8ICdkZWZhdWx0JztcbiAgICAgICAgaWYgKCFwcm9wcy5ub2RlVHlwZXNbbm9kZVR5cGVdKSB7XG4gICAgICAgICAgICBvbkVycm9yPy4oJzAwMycsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAzJ10obm9kZVR5cGUpKTtcbiAgICAgICAgICAgIG5vZGVUeXBlID0gJ2RlZmF1bHQnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IE5vZGVDb21wb25lbnQgPSAocHJvcHMubm9kZVR5cGVzW25vZGVUeXBlXSB8fCBwcm9wcy5ub2RlVHlwZXMuZGVmYXVsdCk7XG4gICAgICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gISEobm9kZS5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBub2RlLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RhYmxlID0gISEobm9kZS5zZWxlY3RhYmxlIHx8IChlbGVtZW50c1NlbGVjdGFibGUgJiYgdHlwZW9mIG5vZGUuc2VsZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICAgICAgY29uc3QgaXNDb25uZWN0YWJsZSA9ICEhKG5vZGUuY29ubmVjdGFibGUgfHwgKG5vZGVzQ29ubmVjdGFibGUgJiYgdHlwZW9mIG5vZGUuY29ubmVjdGFibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgICAgIGNvbnN0IGlzRm9jdXNhYmxlID0gISEobm9kZS5mb2N1c2FibGUgfHwgKG5vZGVzRm9jdXNhYmxlICYmIHR5cGVvZiBub2RlLmZvY3VzYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICAgICAgY29uc3QgY2xhbXBlZFBvc2l0aW9uID0gcHJvcHMubm9kZUV4dGVudFxuICAgICAgICAgICAgPyBjbGFtcFBvc2l0aW9uKG5vZGUucG9zaXRpb25BYnNvbHV0ZSwgcHJvcHMubm9kZUV4dGVudClcbiAgICAgICAgICAgIDogbm9kZS5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICBjb25zdCBwb3NYID0gY2xhbXBlZFBvc2l0aW9uPy54ID8/IDA7XG4gICAgICAgIGNvbnN0IHBvc1kgPSBjbGFtcGVkUG9zaXRpb24/LnkgPz8gMDtcbiAgICAgICAgY29uc3QgcG9zT3JpZ2luID0gZ2V0UG9zaXRpb25XaXRoT3JpZ2luKHtcbiAgICAgICAgICAgIHg6IHBvc1gsXG4gICAgICAgICAgICB5OiBwb3NZLFxuICAgICAgICAgICAgd2lkdGg6IG5vZGUud2lkdGggPz8gMCxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgPz8gMCxcbiAgICAgICAgICAgIG9yaWdpbjogcHJvcHMubm9kZU9yaWdpbixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChOb2RlQ29tcG9uZW50LCB7IGtleTogbm9kZS5pZCwgaWQ6IG5vZGUuaWQsIGNsYXNzTmFtZTogbm9kZS5jbGFzc05hbWUsIHN0eWxlOiBub2RlLnN0eWxlLCB0eXBlOiBub2RlVHlwZSwgZGF0YTogbm9kZS5kYXRhLCBzb3VyY2VQb3NpdGlvbjogbm9kZS5zb3VyY2VQb3NpdGlvbiB8fCBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFBvc2l0aW9uOiBub2RlLnRhcmdldFBvc2l0aW9uIHx8IFBvc2l0aW9uLlRvcCwgaGlkZGVuOiBub2RlLmhpZGRlbiwgeFBvczogcG9zWCwgeVBvczogcG9zWSwgeFBvc09yaWdpbjogcG9zT3JpZ2luLngsIHlQb3NPcmlnaW46IHBvc09yaWdpbi55LCBzZWxlY3ROb2Rlc09uRHJhZzogcHJvcHMuc2VsZWN0Tm9kZXNPbkRyYWcsIG9uQ2xpY2s6IHByb3BzLm9uTm9kZUNsaWNrLCBvbk1vdXNlRW50ZXI6IHByb3BzLm9uTm9kZU1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlOiBwcm9wcy5vbk5vZGVNb3VzZU1vdmUsIG9uTW91c2VMZWF2ZTogcHJvcHMub25Ob2RlTW91c2VMZWF2ZSwgb25Db250ZXh0TWVudTogcHJvcHMub25Ob2RlQ29udGV4dE1lbnUsIG9uRG91YmxlQ2xpY2s6IHByb3BzLm9uTm9kZURvdWJsZUNsaWNrLCBzZWxlY3RlZDogISFub2RlLnNlbGVjdGVkLCBpc0RyYWdnYWJsZTogaXNEcmFnZ2FibGUsIGlzU2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlLCBpc0ZvY3VzYWJsZTogaXNGb2N1c2FibGUsIHJlc2l6ZU9ic2VydmVyOiByZXNpemVPYnNlcnZlciwgZHJhZ0hhbmRsZTogbm9kZS5kcmFnSGFuZGxlLCB6SW5kZXg6IG5vZGVbaW50ZXJuYWxzU3ltYm9sXT8ueiA/PyAwLCBpc1BhcmVudDogISFub2RlW2ludGVybmFsc1N5bWJvbF0/LmlzUGFyZW50LCBub0RyYWdDbGFzc05hbWU6IHByb3BzLm5vRHJhZ0NsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IHByb3BzLm5vUGFuQ2xhc3NOYW1lLCBpbml0aWFsaXplZDogISFub2RlLndpZHRoICYmICEhbm9kZS5oZWlnaHQsIHJmSWQ6IHByb3BzLnJmSWQsIGRpc2FibGVLZXlib2FyZEExMXk6IHByb3BzLmRpc2FibGVLZXlib2FyZEExMXksIGFyaWFMYWJlbDogbm9kZS5hcmlhTGFiZWwgfSkpO1xuICAgIH0pKSk7XG59O1xuTm9kZVJlbmRlcmVyLmRpc3BsYXlOYW1lID0gJ05vZGVSZW5kZXJlcic7XG52YXIgTm9kZVJlbmRlcmVyJDEgPSBtZW1vKE5vZGVSZW5kZXJlcik7XG5cbmNvbnN0IHNoaWZ0WCA9ICh4LCBzaGlmdCwgcG9zaXRpb24pID0+IHtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLkxlZnQpXG4gICAgICAgIHJldHVybiB4IC0gc2hpZnQ7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5SaWdodClcbiAgICAgICAgcmV0dXJuIHggKyBzaGlmdDtcbiAgICByZXR1cm4geDtcbn07XG5jb25zdCBzaGlmdFkgPSAoeSwgc2hpZnQsIHBvc2l0aW9uKSA9PiB7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5Ub3ApXG4gICAgICAgIHJldHVybiB5IC0gc2hpZnQ7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5Cb3R0b20pXG4gICAgICAgIHJldHVybiB5ICsgc2hpZnQ7XG4gICAgcmV0dXJuIHk7XG59O1xuY29uc3QgRWRnZVVwZGF0ZXJDbGFzc05hbWUgPSAncmVhY3QtZmxvd19fZWRnZXVwZGF0ZXInO1xuY29uc3QgRWRnZUFuY2hvciA9ICh7IHBvc2l0aW9uLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMgPSAxMCwgb25Nb3VzZURvd24sIG9uTW91c2VFbnRlciwgb25Nb3VzZU91dCwgdHlwZSwgfSkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwgeyBvbk1vdXNlRG93bjogb25Nb3VzZURvd24sIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyLCBvbk1vdXNlT3V0OiBvbk1vdXNlT3V0LCBjbGFzc05hbWU6IGNjKFtFZGdlVXBkYXRlckNsYXNzTmFtZSwgYCR7RWRnZVVwZGF0ZXJDbGFzc05hbWV9LSR7dHlwZX1gXSksIGN4OiBzaGlmdFgoY2VudGVyWCwgcmFkaXVzLCBwb3NpdGlvbiksIGN5OiBzaGlmdFkoY2VudGVyWSwgcmFkaXVzLCBwb3NpdGlvbiksIHI6IHJhZGl1cywgc3Ryb2tlOiBcInRyYW5zcGFyZW50XCIsIGZpbGw6IFwidHJhbnNwYXJlbnRcIiB9KSk7XG5cbmNvbnN0IGFsd2F5c1ZhbGlkQ29ubmVjdGlvbiA9ICgpID0+IHRydWU7XG52YXIgd3JhcEVkZ2UgPSAoRWRnZUNvbXBvbmVudCkgPT4ge1xuICAgIGNvbnN0IEVkZ2VXcmFwcGVyID0gKHsgaWQsIGNsYXNzTmFtZSwgdHlwZSwgZGF0YSwgb25DbGljaywgb25FZGdlRG91YmxlQ2xpY2ssIHNlbGVjdGVkLCBhbmltYXRlZCwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgc291cmNlLCB0YXJnZXQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiwgZWxlbWVudHNTZWxlY3RhYmxlLCBoaWRkZW4sIHNvdXJjZUhhbmRsZUlkLCB0YXJnZXRIYW5kbGVJZCwgb25Db250ZXh0TWVudSwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlLCBlZGdlVXBkYXRlclJhZGl1cywgb25FZGdlVXBkYXRlLCBvbkVkZ2VVcGRhdGVTdGFydCwgb25FZGdlVXBkYXRlRW5kLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCByZklkLCBhcmlhTGFiZWwsIGlzRm9jdXNhYmxlLCBpc1VwZGF0YWJsZSwgcGF0aE9wdGlvbnMsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgZWRnZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgICAgICAgY29uc3QgW3VwZGF0ZUhvdmVyLCBzZXRVcGRhdGVIb3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgICAgIGNvbnN0IFt1cGRhdGluZywgc2V0VXBkYXRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgICAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgICAgIGNvbnN0IG1hcmtlclN0YXJ0VXJsID0gdXNlTWVtbygoKSA9PiBgdXJsKCMke2dldE1hcmtlcklkKG1hcmtlclN0YXJ0LCByZklkKX0pYCwgW21hcmtlclN0YXJ0LCByZklkXSk7XG4gICAgICAgIGNvbnN0IG1hcmtlckVuZFVybCA9IHVzZU1lbW8oKCkgPT4gYHVybCgjJHtnZXRNYXJrZXJJZChtYXJrZXJFbmQsIHJmSWQpfSlgLCBbbWFya2VyRW5kLCByZklkXSk7XG4gICAgICAgIGlmIChoaWRkZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uRWRnZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGVkZ2VzLCBhZGRTZWxlY3RlZEVkZ2VzLCB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIG11bHRpU2VsZWN0aW9uQWN0aXZlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgZWRnZSA9IGVkZ2VzLmZpbmQoKGUpID0+IGUuaWQgPT09IGlkKTtcbiAgICAgICAgICAgIGlmICghZWRnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtZW50c1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZS5zZWxlY3RlZCAmJiBtdWx0aVNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBub2RlczogW10sIGVkZ2VzOiBbZWRnZV0gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VSZWYuY3VycmVudD8uYmx1cigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2VsZWN0ZWRFZGdlcyhbaWRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIGVkZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkVkZ2VEb3VibGVDbGlja0hhbmRsZXIgPSBnZXRNb3VzZUhhbmRsZXIkMShpZCwgc3RvcmUuZ2V0U3RhdGUsIG9uRWRnZURvdWJsZUNsaWNrKTtcbiAgICAgICAgY29uc3Qgb25FZGdlQ29udGV4dE1lbnUgPSBnZXRNb3VzZUhhbmRsZXIkMShpZCwgc3RvcmUuZ2V0U3RhdGUsIG9uQ29udGV4dE1lbnUpO1xuICAgICAgICBjb25zdCBvbkVkZ2VNb3VzZUVudGVyID0gZ2V0TW91c2VIYW5kbGVyJDEoaWQsIHN0b3JlLmdldFN0YXRlLCBvbk1vdXNlRW50ZXIpO1xuICAgICAgICBjb25zdCBvbkVkZ2VNb3VzZU1vdmUgPSBnZXRNb3VzZUhhbmRsZXIkMShpZCwgc3RvcmUuZ2V0U3RhdGUsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgY29uc3Qgb25FZGdlTW91c2VMZWF2ZSA9IGdldE1vdXNlSGFuZGxlciQxKGlkLCBzdG9yZS5nZXRTdGF0ZSwgb25Nb3VzZUxlYXZlKTtcbiAgICAgICAgY29uc3QgaGFuZGxlRWRnZVVwZGF0ZXIgPSAoZXZlbnQsIGlzU291cmNlSGFuZGxlKSA9PiB7XG4gICAgICAgICAgICAvLyBhdm9pZCB0cmlnZ2VyaW5nIGVkZ2UgdXBkYXRlciBpZiBtb3VzZSBidG4gaXMgbm90IGxlZnRcbiAgICAgICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGVkZ2VzLCBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb25TdG9yZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVJZCA9IGlzU291cmNlSGFuZGxlID8gdGFyZ2V0IDogc291cmNlO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlSWQgPSAoaXNTb3VyY2VIYW5kbGUgPyB0YXJnZXRIYW5kbGVJZCA6IHNvdXJjZUhhbmRsZUlkKSB8fCBudWxsO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlVHlwZSA9IGlzU291cmNlSGFuZGxlID8gJ3RhcmdldCcgOiAnc291cmNlJztcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRDb25uZWN0aW9uID0gaXNWYWxpZENvbm5lY3Rpb25TdG9yZSB8fCBhbHdheXNWYWxpZENvbm5lY3Rpb247XG4gICAgICAgICAgICBjb25zdCBpc1RhcmdldCA9IGlzU291cmNlSGFuZGxlO1xuICAgICAgICAgICAgY29uc3QgZWRnZSA9IGVkZ2VzLmZpbmQoKGUpID0+IGUuaWQgPT09IGlkKTtcbiAgICAgICAgICAgIHNldFVwZGF0aW5nKHRydWUpO1xuICAgICAgICAgICAgb25FZGdlVXBkYXRlU3RhcnQ/LihldmVudCwgZWRnZSwgaGFuZGxlVHlwZSk7XG4gICAgICAgICAgICBjb25zdCBfb25FZGdlVXBkYXRlRW5kID0gKGV2dCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFVwZGF0aW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBvbkVkZ2VVcGRhdGVFbmQ/LihldnQsIGVkZ2UsIGhhbmRsZVR5cGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9uQ29ubmVjdEVkZ2UgPSAoY29ubmVjdGlvbikgPT4gb25FZGdlVXBkYXRlPy4oZWRnZSwgY29ubmVjdGlvbik7XG4gICAgICAgICAgICBoYW5kbGVQb2ludGVyRG93bih7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgaGFuZGxlSWQsXG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIG9uQ29ubmVjdDogb25Db25uZWN0RWRnZSxcbiAgICAgICAgICAgICAgICBpc1RhcmdldCxcbiAgICAgICAgICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICAgICAgICAgICAgc2V0U3RhdGU6IHN0b3JlLnNldFN0YXRlLFxuICAgICAgICAgICAgICAgIGlzVmFsaWRDb25uZWN0aW9uLFxuICAgICAgICAgICAgICAgIGVkZ2VVcGRhdGVyVHlwZTogaGFuZGxlVHlwZSxcbiAgICAgICAgICAgICAgICBvbkVkZ2VVcGRhdGVFbmQ6IF9vbkVkZ2VVcGRhdGVFbmQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25FZGdlVXBkYXRlclNvdXJjZU1vdXNlRG93biA9IChldmVudCkgPT4gaGFuZGxlRWRnZVVwZGF0ZXIoZXZlbnQsIHRydWUpO1xuICAgICAgICBjb25zdCBvbkVkZ2VVcGRhdGVyVGFyZ2V0TW91c2VEb3duID0gKGV2ZW50KSA9PiBoYW5kbGVFZGdlVXBkYXRlcihldmVudCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBvbkVkZ2VVcGRhdGVyTW91c2VFbnRlciA9ICgpID0+IHNldFVwZGF0ZUhvdmVyKHRydWUpO1xuICAgICAgICBjb25zdCBvbkVkZ2VVcGRhdGVyTW91c2VPdXQgPSAoKSA9PiBzZXRVcGRhdGVIb3ZlcihmYWxzZSk7XG4gICAgICAgIGNvbnN0IGluYWN0aXZlID0gIWVsZW1lbnRzU2VsZWN0YWJsZSAmJiAhb25DbGljaztcbiAgICAgICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudFNlbGVjdGlvbktleXMuaW5jbHVkZXMoZXZlbnQua2V5KSAmJiBlbGVtZW50c1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgYWRkU2VsZWN0ZWRFZGdlcywgZWRnZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5zZWxlY3QgPSBldmVudC5rZXkgPT09ICdFc2NhcGUnO1xuICAgICAgICAgICAgICAgIGlmICh1bnNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICBlZGdlUmVmLmN1cnJlbnQ/LmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzKHsgZWRnZXM6IFtlZGdlcy5maW5kKChlKSA9PiBlLmlkID09PSBpZCldIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2VsZWN0ZWRFZGdlcyhbaWRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwgeyBjbGFzc05hbWU6IGNjKFtcbiAgICAgICAgICAgICAgICAncmVhY3QtZmxvd19fZWRnZScsXG4gICAgICAgICAgICAgICAgYHJlYWN0LWZsb3dfX2VkZ2UtJHt0eXBlfWAsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHsgc2VsZWN0ZWQsIGFuaW1hdGVkLCBpbmFjdGl2ZSwgdXBkYXRpbmc6IHVwZGF0ZUhvdmVyIH0sXG4gICAgICAgICAgICBdKSwgb25DbGljazogb25FZGdlQ2xpY2ssIG9uRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrSGFuZGxlciwgb25Db250ZXh0TWVudTogb25FZGdlQ29udGV4dE1lbnUsIG9uTW91c2VFbnRlcjogb25FZGdlTW91c2VFbnRlciwgb25Nb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlOiBvbkVkZ2VNb3VzZUxlYXZlLCBvbktleURvd246IGlzRm9jdXNhYmxlID8gb25LZXlEb3duIDogdW5kZWZpbmVkLCB0YWJJbmRleDogaXNGb2N1c2FibGUgPyAwIDogdW5kZWZpbmVkLCByb2xlOiBpc0ZvY3VzYWJsZSA/ICdidXR0b24nIDogJ2ltZycsIFwiZGF0YS10ZXN0aWRcIjogYHJmX19lZGdlLSR7aWR9YCwgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFyaWFMYWJlbCA/IGFyaWFMYWJlbCA6IGBFZGdlIGZyb20gJHtzb3VyY2V9IHRvICR7dGFyZ2V0fWAsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBpc0ZvY3VzYWJsZSA/IGAke0FSSUFfRURHRV9ERVNDX0tFWX0tJHtyZklkfWAgOiB1bmRlZmluZWQsIHJlZjogZWRnZVJlZiB9LFxuICAgICAgICAgICAgIXVwZGF0aW5nICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KEVkZ2VDb21wb25lbnQsIHsgaWQ6IGlkLCBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHNlbGVjdGVkOiBzZWxlY3RlZCwgYW5pbWF0ZWQ6IGFuaW1hdGVkLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgZGF0YTogZGF0YSwgc3R5bGU6IHN0eWxlLCBzb3VyY2VYOiBzb3VyY2VYLCBzb3VyY2VZOiBzb3VyY2VZLCB0YXJnZXRYOiB0YXJnZXRYLCB0YXJnZXRZOiB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbjogc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgc291cmNlSGFuZGxlSWQ6IHNvdXJjZUhhbmRsZUlkLCB0YXJnZXRIYW5kbGVJZDogdGFyZ2V0SGFuZGxlSWQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydFVybCwgbWFya2VyRW5kOiBtYXJrZXJFbmRVcmwsIHBhdGhPcHRpb25zOiBwYXRoT3B0aW9ucywgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSksXG4gICAgICAgICAgICBpc1VwZGF0YWJsZSAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICAoaXNVcGRhdGFibGUgPT09ICdzb3VyY2UnIHx8IGlzVXBkYXRhYmxlID09PSB0cnVlKSAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChFZGdlQW5jaG9yLCB7IHBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgY2VudGVyWDogc291cmNlWCwgY2VudGVyWTogc291cmNlWSwgcmFkaXVzOiBlZGdlVXBkYXRlclJhZGl1cywgb25Nb3VzZURvd246IG9uRWRnZVVwZGF0ZXJTb3VyY2VNb3VzZURvd24sIG9uTW91c2VFbnRlcjogb25FZGdlVXBkYXRlck1vdXNlRW50ZXIsIG9uTW91c2VPdXQ6IG9uRWRnZVVwZGF0ZXJNb3VzZU91dCwgdHlwZTogXCJzb3VyY2VcIiB9KSksXG4gICAgICAgICAgICAgICAgKGlzVXBkYXRhYmxlID09PSAndGFyZ2V0JyB8fCBpc1VwZGF0YWJsZSA9PT0gdHJ1ZSkgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRnZUFuY2hvciwgeyBwb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIGNlbnRlclg6IHRhcmdldFgsIGNlbnRlclk6IHRhcmdldFksIHJhZGl1czogZWRnZVVwZGF0ZXJSYWRpdXMsIG9uTW91c2VEb3duOiBvbkVkZ2VVcGRhdGVyVGFyZ2V0TW91c2VEb3duLCBvbk1vdXNlRW50ZXI6IG9uRWRnZVVwZGF0ZXJNb3VzZUVudGVyLCBvbk1vdXNlT3V0OiBvbkVkZ2VVcGRhdGVyTW91c2VPdXQsIHR5cGU6IFwidGFyZ2V0XCIgfSkpKSkpKTtcbiAgICB9O1xuICAgIEVkZ2VXcmFwcGVyLmRpc3BsYXlOYW1lID0gJ0VkZ2VXcmFwcGVyJztcbiAgICByZXR1cm4gbWVtbyhFZGdlV3JhcHBlcik7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVFZGdlVHlwZXMoZWRnZVR5cGVzKSB7XG4gICAgY29uc3Qgc3RhbmRhcmRUeXBlcyA9IHtcbiAgICAgICAgZGVmYXVsdDogd3JhcEVkZ2UoKGVkZ2VUeXBlcy5kZWZhdWx0IHx8IEJlemllckVkZ2UpKSxcbiAgICAgICAgc3RyYWlnaHQ6IHdyYXBFZGdlKChlZGdlVHlwZXMuYmV6aWVyIHx8IFN0cmFpZ2h0RWRnZSkpLFxuICAgICAgICBzdGVwOiB3cmFwRWRnZSgoZWRnZVR5cGVzLnN0ZXAgfHwgU3RlcEVkZ2UpKSxcbiAgICAgICAgc21vb3Roc3RlcDogd3JhcEVkZ2UoKGVkZ2VUeXBlcy5zdGVwIHx8IFNtb290aFN0ZXBFZGdlKSksXG4gICAgICAgIHNpbXBsZWJlemllcjogd3JhcEVkZ2UoKGVkZ2VUeXBlcy5zaW1wbGViZXppZXIgfHwgU2ltcGxlQmV6aWVyRWRnZSkpLFxuICAgIH07XG4gICAgY29uc3Qgd3JhcHBlZFR5cGVzID0ge307XG4gICAgY29uc3Qgc3BlY2lhbFR5cGVzID0gT2JqZWN0LmtleXMoZWRnZVR5cGVzKVxuICAgICAgICAuZmlsdGVyKChrKSA9PiAhWydkZWZhdWx0JywgJ2JlemllciddLmluY2x1ZGVzKGspKVxuICAgICAgICAucmVkdWNlKChyZXMsIGtleSkgPT4ge1xuICAgICAgICByZXNba2V5XSA9IHdyYXBFZGdlKChlZGdlVHlwZXNba2V5XSB8fCBCZXppZXJFZGdlKSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgd3JhcHBlZFR5cGVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGFuZGFyZFR5cGVzLFxuICAgICAgICAuLi5zcGVjaWFsVHlwZXMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZVBvc2l0aW9uKHBvc2l0aW9uLCBub2RlUmVjdCwgaGFuZGxlID0gbnVsbCkge1xuICAgIGNvbnN0IHggPSAoaGFuZGxlPy54IHx8IDApICsgbm9kZVJlY3QueDtcbiAgICBjb25zdCB5ID0gKGhhbmRsZT8ueSB8fCAwKSArIG5vZGVSZWN0Lnk7XG4gICAgY29uc3Qgd2lkdGggPSBoYW5kbGU/LndpZHRoIHx8IG5vZGVSZWN0LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGhhbmRsZT8uaGVpZ2h0IHx8IG5vZGVSZWN0LmhlaWdodDtcbiAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgUG9zaXRpb24uVG9wOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4ICsgd2lkdGggLyAyLFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4ICsgd2lkdGgsXG4gICAgICAgICAgICAgICAgeTogeSArIGhlaWdodCAvIDIsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkJvdHRvbTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogeCArIHdpZHRoIC8gMixcbiAgICAgICAgICAgICAgICB5OiB5ICsgaGVpZ2h0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5MZWZ0OlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHk6IHkgKyBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRIYW5kbGUoYm91bmRzLCBoYW5kbGVJZCkge1xuICAgIGlmICghYm91bmRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoYm91bmRzLmxlbmd0aCA9PT0gMSB8fCAhaGFuZGxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGJvdW5kc1swXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGJvdW5kcy5maW5kKChkKSA9PiBkLmlkID09PSBoYW5kbGVJZCkgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBnZXRFZGdlUG9zaXRpb25zID0gKHNvdXJjZU5vZGVSZWN0LCBzb3VyY2VIYW5kbGUsIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXROb2RlUmVjdCwgdGFyZ2V0SGFuZGxlLCB0YXJnZXRQb3NpdGlvbikgPT4ge1xuICAgIGNvbnN0IHNvdXJjZUhhbmRsZVBvcyA9IGdldEhhbmRsZVBvc2l0aW9uKHNvdXJjZVBvc2l0aW9uLCBzb3VyY2VOb2RlUmVjdCwgc291cmNlSGFuZGxlKTtcbiAgICBjb25zdCB0YXJnZXRIYW5kbGVQb3MgPSBnZXRIYW5kbGVQb3NpdGlvbih0YXJnZXRQb3NpdGlvbiwgdGFyZ2V0Tm9kZVJlY3QsIHRhcmdldEhhbmRsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlWDogc291cmNlSGFuZGxlUG9zLngsXG4gICAgICAgIHNvdXJjZVk6IHNvdXJjZUhhbmRsZVBvcy55LFxuICAgICAgICB0YXJnZXRYOiB0YXJnZXRIYW5kbGVQb3MueCxcbiAgICAgICAgdGFyZ2V0WTogdGFyZ2V0SGFuZGxlUG9zLnksXG4gICAgfTtcbn07XG5mdW5jdGlvbiBpc0VkZ2VWaXNpYmxlKHsgc291cmNlUG9zLCB0YXJnZXRQb3MsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIHRyYW5zZm9ybSwgfSkge1xuICAgIGNvbnN0IGVkZ2VCb3ggPSB7XG4gICAgICAgIHg6IE1hdGgubWluKHNvdXJjZVBvcy54LCB0YXJnZXRQb3MueCksXG4gICAgICAgIHk6IE1hdGgubWluKHNvdXJjZVBvcy55LCB0YXJnZXRQb3MueSksXG4gICAgICAgIHgyOiBNYXRoLm1heChzb3VyY2VQb3MueCArIHNvdXJjZVdpZHRoLCB0YXJnZXRQb3MueCArIHRhcmdldFdpZHRoKSxcbiAgICAgICAgeTI6IE1hdGgubWF4KHNvdXJjZVBvcy55ICsgc291cmNlSGVpZ2h0LCB0YXJnZXRQb3MueSArIHRhcmdldEhlaWdodCksXG4gICAgfTtcbiAgICBpZiAoZWRnZUJveC54ID09PSBlZGdlQm94LngyKSB7XG4gICAgICAgIGVkZ2VCb3gueDIgKz0gMTtcbiAgICB9XG4gICAgaWYgKGVkZ2VCb3gueSA9PT0gZWRnZUJveC55Mikge1xuICAgICAgICBlZGdlQm94LnkyICs9IDE7XG4gICAgfVxuICAgIGNvbnN0IHZpZXdCb3ggPSByZWN0VG9Cb3goe1xuICAgICAgICB4OiAoMCAtIHRyYW5zZm9ybVswXSkgLyB0cmFuc2Zvcm1bMl0sXG4gICAgICAgIHk6ICgwIC0gdHJhbnNmb3JtWzFdKSAvIHRyYW5zZm9ybVsyXSxcbiAgICAgICAgd2lkdGg6IHdpZHRoIC8gdHJhbnNmb3JtWzJdLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCAvIHRyYW5zZm9ybVsyXSxcbiAgICB9KTtcbiAgICBjb25zdCB4T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHZpZXdCb3gueDIsIGVkZ2VCb3gueDIpIC0gTWF0aC5tYXgodmlld0JveC54LCBlZGdlQm94LngpKTtcbiAgICBjb25zdCB5T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHZpZXdCb3gueTIsIGVkZ2VCb3gueTIpIC0gTWF0aC5tYXgodmlld0JveC55LCBlZGdlQm94LnkpKTtcbiAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBNYXRoLmNlaWwoeE92ZXJsYXAgKiB5T3ZlcmxhcCk7XG4gICAgcmV0dXJuIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG59XG5mdW5jdGlvbiBnZXROb2RlRGF0YShub2RlKSB7XG4gICAgY29uc3QgaGFuZGxlQm91bmRzID0gbm9kZT8uW2ludGVybmFsc1N5bWJvbF0/LmhhbmRsZUJvdW5kcyB8fCBudWxsO1xuICAgIGNvbnN0IGlzVmFsaWQgPSBoYW5kbGVCb3VuZHMgJiZcbiAgICAgICAgbm9kZT8ud2lkdGggJiZcbiAgICAgICAgbm9kZT8uaGVpZ2h0ICYmXG4gICAgICAgIHR5cGVvZiBub2RlPy5wb3NpdGlvbkFic29sdXRlPy54ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2Ygbm9kZT8ucG9zaXRpb25BYnNvbHV0ZT8ueSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgICAgeDogbm9kZT8ucG9zaXRpb25BYnNvbHV0ZT8ueCB8fCAwLFxuICAgICAgICAgICAgeTogbm9kZT8ucG9zaXRpb25BYnNvbHV0ZT8ueSB8fCAwLFxuICAgICAgICAgICAgd2lkdGg6IG5vZGU/LndpZHRoIHx8IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IG5vZGU/LmhlaWdodCB8fCAwLFxuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVCb3VuZHMsXG4gICAgICAgICEhaXNWYWxpZCxcbiAgICBdO1xufVxuXG5jb25zdCBkZWZhdWx0RWRnZVRyZWUgPSBbeyBsZXZlbDogMCwgaXNNYXhMZXZlbDogdHJ1ZSwgZWRnZXM6IFtdIH1dO1xuZnVuY3Rpb24gZ3JvdXBFZGdlc0J5WkxldmVsKGVkZ2VzLCBub2RlSW50ZXJuYWxzLCBlbGV2YXRlRWRnZXNPblNlbGVjdCA9IGZhbHNlKSB7XG4gICAgbGV0IG1heExldmVsID0gLTE7XG4gICAgY29uc3QgbGV2ZWxMb29rdXAgPSBlZGdlcy5yZWR1Y2UoKHRyZWUsIGVkZ2UpID0+IHtcbiAgICAgICAgY29uc3QgaGFzWkluZGV4ID0gaXNOdW1lcmljKGVkZ2UuekluZGV4KTtcbiAgICAgICAgbGV0IHogPSBoYXNaSW5kZXggPyBlZGdlLnpJbmRleCA6IDA7XG4gICAgICAgIGlmIChlbGV2YXRlRWRnZXNPblNlbGVjdCkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IG5vZGVJbnRlcm5hbHMuZ2V0KGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBub2RlSW50ZXJuYWxzLmdldChlZGdlLnNvdXJjZSk7XG4gICAgICAgICAgICBjb25zdCBlZGdlT3JDb25uZWN0ZWROb2RlU2VsZWN0ZWQgPSBlZGdlLnNlbGVjdGVkIHx8IHRhcmdldE5vZGU/LnNlbGVjdGVkIHx8IHNvdXJjZU5vZGU/LnNlbGVjdGVkO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRaSW5kZXggPSBNYXRoLm1heChzb3VyY2VOb2RlPy5baW50ZXJuYWxzU3ltYm9sXT8ueiB8fCAwLCB0YXJnZXROb2RlPy5baW50ZXJuYWxzU3ltYm9sXT8ueiB8fCAwLCAxMDAwKTtcbiAgICAgICAgICAgIHogPSAoaGFzWkluZGV4ID8gZWRnZS56SW5kZXggOiAwKSArIChlZGdlT3JDb25uZWN0ZWROb2RlU2VsZWN0ZWQgPyBzZWxlY3RlZFpJbmRleCA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmVlW3pdKSB7XG4gICAgICAgICAgICB0cmVlW3pdLnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cmVlW3pdID0gW2VkZ2VdO1xuICAgICAgICB9XG4gICAgICAgIG1heExldmVsID0geiA+IG1heExldmVsID8geiA6IG1heExldmVsO1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9LCB7fSk7XG4gICAgY29uc3QgZWRnZVRyZWUgPSBPYmplY3QuZW50cmllcyhsZXZlbExvb2t1cCkubWFwKChba2V5LCBlZGdlc10pID0+IHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSAra2V5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgIGlzTWF4TGV2ZWw6IGxldmVsID09PSBtYXhMZXZlbCxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBpZiAoZWRnZVRyZWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RWRnZVRyZWU7XG4gICAgfVxuICAgIHJldHVybiBlZGdlVHJlZTtcbn1cbmZ1bmN0aW9uIHVzZVZpc2libGVFZGdlcyhvbmx5UmVuZGVyVmlzaWJsZSwgbm9kZUludGVybmFscywgZWxldmF0ZUVkZ2VzT25TZWxlY3QpIHtcbiAgICBjb25zdCBlZGdlcyA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzKSA9PiB7XG4gICAgICAgIGlmICghb25seVJlbmRlclZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzLmVkZ2VzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzLmVkZ2VzLmZpbHRlcigoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlTm9kZSA9IG5vZGVJbnRlcm5hbHMuZ2V0KGUuc291cmNlKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBub2RlSW50ZXJuYWxzLmdldChlLnRhcmdldCk7XG4gICAgICAgICAgICByZXR1cm4gKHNvdXJjZU5vZGU/LndpZHRoICYmXG4gICAgICAgICAgICAgICAgc291cmNlTm9kZT8uaGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZT8ud2lkdGggJiZcbiAgICAgICAgICAgICAgICB0YXJnZXROb2RlPy5oZWlnaHQgJiZcbiAgICAgICAgICAgICAgICBpc0VkZ2VWaXNpYmxlKHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlUG9zOiBzb3VyY2VOb2RlLnBvc2l0aW9uQWJzb2x1dGUgfHwgeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFBvczogdGFyZ2V0Tm9kZS5wb3NpdGlvbkFic29sdXRlIHx8IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VXaWR0aDogc291cmNlTm9kZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlSGVpZ2h0OiBzb3VyY2VOb2RlLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0V2lkdGg6IHRhcmdldE5vZGUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEhlaWdodDogdGFyZ2V0Tm9kZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHMudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfSwgW29ubHlSZW5kZXJWaXNpYmxlLCBub2RlSW50ZXJuYWxzXSkpO1xuICAgIHJldHVybiBncm91cEVkZ2VzQnlaTGV2ZWwoZWRnZXMsIG5vZGVJbnRlcm5hbHMsIGVsZXZhdGVFZGdlc09uU2VsZWN0KTtcbn1cblxuY29uc3QgQXJyb3dTeW1ib2wgPSAoeyBjb2xvciA9ICdub25lJywgc3Ryb2tlV2lkdGggPSAxIH0pID0+IHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwb2x5bGluZVwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIH0sIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgZmlsbDogXCJub25lXCIsIHBvaW50czogXCItNSwtNCAwLDAgLTUsNFwiIH0pKTtcbn07XG5jb25zdCBBcnJvd0Nsb3NlZFN5bWJvbCA9ICh7IGNvbG9yID0gJ25vbmUnLCBzdHJva2VXaWR0aCA9IDEgfSkgPT4ge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogY29sb3IsXG4gICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICB9LCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIHBvaW50czogXCItNSwtNCAwLDAgLTUsNCAtNSwtNFwiIH0pKTtcbn07XG5jb25zdCBNYXJrZXJTeW1ib2xzID0ge1xuICAgIFtNYXJrZXJUeXBlLkFycm93XTogQXJyb3dTeW1ib2wsXG4gICAgW01hcmtlclR5cGUuQXJyb3dDbG9zZWRdOiBBcnJvd0Nsb3NlZFN5bWJvbCxcbn07XG5mdW5jdGlvbiB1c2VNYXJrZXJTeW1ib2wodHlwZSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBzeW1ib2wgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3ltYm9sRXhpc3RzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKE1hcmtlclN5bWJvbHMsIHR5cGUpO1xuICAgICAgICBpZiAoIXN5bWJvbEV4aXN0cykge1xuICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAwOScsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA5J10odHlwZSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hcmtlclN5bWJvbHNbdHlwZV07XG4gICAgfSwgW3R5cGVdKTtcbiAgICByZXR1cm4gc3ltYm9sO1xufVxuXG5jb25zdCBNYXJrZXIgPSAoeyBpZCwgdHlwZSwgY29sb3IsIHdpZHRoID0gMTIuNSwgaGVpZ2h0ID0gMTIuNSwgbWFya2VyVW5pdHMgPSAnc3Ryb2tlV2lkdGgnLCBzdHJva2VXaWR0aCwgb3JpZW50ID0gJ2F1dG8tc3RhcnQtcmV2ZXJzZScsIH0pID0+IHtcbiAgICBjb25zdCBTeW1ib2wgPSB1c2VNYXJrZXJTeW1ib2wodHlwZSk7XG4gICAgaWYgKCFTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcIm1hcmtlclwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19hcnJvd2hlYWRcIiwgaWQ6IGlkLCBtYXJrZXJXaWR0aDogYCR7d2lkdGh9YCwgbWFya2VySGVpZ2h0OiBgJHtoZWlnaHR9YCwgdmlld0JveDogXCItMTAgLTEwIDIwIDIwXCIsIG1hcmtlclVuaXRzOiBtYXJrZXJVbml0cywgb3JpZW50OiBvcmllbnQsIHJlZlg6IFwiMFwiLCByZWZZOiBcIjBcIiB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFN5bWJvbCwgeyBjb2xvcjogY29sb3IsIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCB9KSkpO1xufTtcbmNvbnN0IG1hcmtlclNlbGVjdG9yID0gKHsgZGVmYXVsdENvbG9yLCByZklkIH0pID0+IChzKSA9PiB7XG4gICAgY29uc3QgaWRzID0gW107XG4gICAgcmV0dXJuIHMuZWRnZXNcbiAgICAgICAgLnJlZHVjZSgobWFya2VycywgZWRnZSkgPT4ge1xuICAgICAgICBbZWRnZS5tYXJrZXJTdGFydCwgZWRnZS5tYXJrZXJFbmRdLmZvckVhY2goKG1hcmtlcikgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtlciAmJiB0eXBlb2YgbWFya2VyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlcklkID0gZ2V0TWFya2VySWQobWFya2VyLCByZklkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkcy5pbmNsdWRlcyhtYXJrZXJJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKHsgaWQ6IG1hcmtlcklkLCBjb2xvcjogbWFya2VyLmNvbG9yIHx8IGRlZmF1bHRDb2xvciwgLi4ubWFya2VyIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChtYXJrZXJJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfSwgW10pXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmlkLmxvY2FsZUNvbXBhcmUoYi5pZCkpO1xufTtcbi8vIHdoZW4geW91IGhhdmUgbXVsdGlwbGUgZmxvd3Mgb24gYSBwYWdlIGFuZCB5b3UgaGlkZSB0aGUgZmlyc3Qgb25lLCB0aGUgb3RoZXIgb25lcyBoYXZlIG5vIG1hcmtlcnMgYW55bW9yZVxuLy8gd2hlbiB0aGV5IGRvIGhhdmUgbWFya2VycyB3aXRoIHRoZSBzYW1lIGlkcy4gVG8gcHJldmVudCB0aGlzIHRoZSB1c2VyIGNhbiBwYXNzIGEgdW5pcXVlIGlkIHRvIHRoZSByZWFjdCBmbG93IHdyYXBwZXJcbi8vIHRoYXQgd2UgY2FuIHRoZW4gdXNlIGZvciBjcmVhdGluZyBvdXIgdW5pcXVlIG1hcmtlciBpZHNcbmNvbnN0IE1hcmtlckRlZmluaXRpb25zID0gKHsgZGVmYXVsdENvbG9yLCByZklkIH0pID0+IHtcbiAgICBjb25zdCBtYXJrZXJzID0gdXNlU3RvcmUodXNlQ2FsbGJhY2sobWFya2VyU2VsZWN0b3IoeyBkZWZhdWx0Q29sb3IsIHJmSWQgfSksIFtkZWZhdWx0Q29sb3IsIHJmSWRdKSwgXG4gICAgLy8gdGhlIGlkIGluY2x1ZGVzIGFsbCBtYXJrZXIgb3B0aW9ucywgc28gd2UganVzdCBuZWVkIHRvIGxvb2sgYXQgdGhhdCBwYXJ0IG9mIHRoZSBtYXJrZXJcbiAgICAoYSwgYikgPT4gIShhLmxlbmd0aCAhPT0gYi5sZW5ndGggfHwgYS5zb21lKChtLCBpKSA9PiBtLmlkICE9PSBiW2ldLmlkKSkpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRlZnNcIiwgbnVsbCwgbWFya2Vycy5tYXAoKG1hcmtlcikgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya2VyLCB7IGlkOiBtYXJrZXIuaWQsIGtleTogbWFya2VyLmlkLCB0eXBlOiBtYXJrZXIudHlwZSwgY29sb3I6IG1hcmtlci5jb2xvciwgd2lkdGg6IG1hcmtlci53aWR0aCwgaGVpZ2h0OiBtYXJrZXIuaGVpZ2h0LCBtYXJrZXJVbml0czogbWFya2VyLm1hcmtlclVuaXRzLCBzdHJva2VXaWR0aDogbWFya2VyLnN0cm9rZVdpZHRoLCBvcmllbnQ6IG1hcmtlci5vcmllbnQgfSkpKSkpO1xufTtcbk1hcmtlckRlZmluaXRpb25zLmRpc3BsYXlOYW1lID0gJ01hcmtlckRlZmluaXRpb25zJztcbnZhciBNYXJrZXJEZWZpbml0aW9ucyQxID0gbWVtbyhNYXJrZXJEZWZpbml0aW9ucyk7XG5cbmNvbnN0IHNlbGVjdG9yJDQgPSAocykgPT4gKHtcbiAgICBub2Rlc0Nvbm5lY3RhYmxlOiBzLm5vZGVzQ29ubmVjdGFibGUsXG4gICAgZWRnZXNGb2N1c2FibGU6IHMuZWRnZXNGb2N1c2FibGUsXG4gICAgZWRnZXNVcGRhdGFibGU6IHMuZWRnZXNVcGRhdGFibGUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICB3aWR0aDogcy53aWR0aCxcbiAgICBoZWlnaHQ6IHMuaGVpZ2h0LFxuICAgIGNvbm5lY3Rpb25Nb2RlOiBzLmNvbm5lY3Rpb25Nb2RlLFxuICAgIG5vZGVJbnRlcm5hbHM6IHMubm9kZUludGVybmFscyxcbiAgICBvbkVycm9yOiBzLm9uRXJyb3IsXG59KTtcbmNvbnN0IEVkZ2VSZW5kZXJlciA9ICh7IGRlZmF1bHRNYXJrZXJDb2xvciwgb25seVJlbmRlclZpc2libGVFbGVtZW50cywgZWxldmF0ZUVkZ2VzT25TZWxlY3QsIHJmSWQsIGVkZ2VUeXBlcywgbm9QYW5DbGFzc05hbWUsIG9uRWRnZVVwZGF0ZSwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZSwgb25FZGdlQ2xpY2ssIGVkZ2VVcGRhdGVyUmFkaXVzLCBvbkVkZ2VEb3VibGVDbGljaywgb25FZGdlVXBkYXRlU3RhcnQsIG9uRWRnZVVwZGF0ZUVuZCwgY2hpbGRyZW4sIH0pID0+IHtcbiAgICBjb25zdCB7IGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1VwZGF0YWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCB3aWR0aCwgaGVpZ2h0LCBjb25uZWN0aW9uTW9kZSwgbm9kZUludGVybmFscywgb25FcnJvciB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkNCwgc2hhbGxvdyk7XG4gICAgY29uc3QgZWRnZVRyZWUgPSB1c2VWaXNpYmxlRWRnZXMob25seVJlbmRlclZpc2libGVFbGVtZW50cywgbm9kZUludGVybmFscywgZWxldmF0ZUVkZ2VzT25TZWxlY3QpO1xuICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgZWRnZVRyZWUubWFwKCh7IGxldmVsLCBlZGdlcywgaXNNYXhMZXZlbCB9KSA9PiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IGtleTogbGV2ZWwsIHN0eWxlOiB7IHpJbmRleDogbGV2ZWwgfSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2VzIHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiIH0sXG4gICAgICAgICAgICBpc01heExldmVsICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya2VyRGVmaW5pdGlvbnMkMSwgeyBkZWZhdWx0Q29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgcmZJZDogcmZJZCB9KSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIG51bGwsIGVkZ2VzLm1hcCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzb3VyY2VOb2RlUmVjdCwgc291cmNlSGFuZGxlQm91bmRzLCBzb3VyY2VJc1ZhbGlkXSA9IGdldE5vZGVEYXRhKG5vZGVJbnRlcm5hbHMuZ2V0KGVkZ2Uuc291cmNlKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgW3RhcmdldE5vZGVSZWN0LCB0YXJnZXRIYW5kbGVCb3VuZHMsIHRhcmdldElzVmFsaWRdID0gZ2V0Tm9kZURhdGEobm9kZUludGVybmFscy5nZXQoZWRnZS50YXJnZXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZUlzVmFsaWQgfHwgIXRhcmdldElzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBlZGdlVHlwZSA9IGVkZ2UudHlwZSB8fCAnZGVmYXVsdCc7XG4gICAgICAgICAgICAgICAgaWYgKCFlZGdlVHlwZXNbZWRnZVR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I/LignMDExJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTEnXShlZGdlVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICBlZGdlVHlwZSA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgRWRnZUNvbXBvbmVudCA9IGVkZ2VUeXBlc1tlZGdlVHlwZV0gfHwgZWRnZVR5cGVzLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBjb25uZWN0aW9uIHR5cGUgaXMgbG9vc2Ugd2UgY2FuIGRlZmluZSBhbGwgaGFuZGxlcyBhcyBzb3VyY2VzIGFuZCBjb25uZWN0IHNvdXJjZSAtPiBzb3VyY2VcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXROb2RlSGFuZGxlcyA9IGNvbm5lY3Rpb25Nb2RlID09PSBDb25uZWN0aW9uTW9kZS5TdHJpY3RcbiAgICAgICAgICAgICAgICAgICAgPyB0YXJnZXRIYW5kbGVCb3VuZHMudGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIDogKHRhcmdldEhhbmRsZUJvdW5kcy50YXJnZXQgPz8gW10pLmNvbmNhdCh0YXJnZXRIYW5kbGVCb3VuZHMuc291cmNlID8/IFtdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VIYW5kbGUgPSBnZXRIYW5kbGUoc291cmNlSGFuZGxlQm91bmRzLnNvdXJjZSwgZWRnZS5zb3VyY2VIYW5kbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEhhbmRsZSA9IGdldEhhbmRsZSh0YXJnZXROb2RlSGFuZGxlcywgZWRnZS50YXJnZXRIYW5kbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9uID0gc291cmNlSGFuZGxlPy5wb3NpdGlvbiB8fCBQb3NpdGlvbi5Cb3R0b207XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSB0YXJnZXRIYW5kbGU/LnBvc2l0aW9uIHx8IFBvc2l0aW9uLlRvcDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0ZvY3VzYWJsZSA9ICEhKGVkZ2UuZm9jdXNhYmxlIHx8IChlZGdlc0ZvY3VzYWJsZSAmJiB0eXBlb2YgZWRnZS5mb2N1c2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNVcGRhdGFibGUgPSB0eXBlb2Ygb25FZGdlVXBkYXRlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAoZWRnZS51cGRhdGFibGUgfHwgKGVkZ2VzVXBkYXRhYmxlICYmIHR5cGVvZiBlZGdlLnVwZGF0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZUhhbmRsZSB8fCAhdGFyZ2V0SGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I/LignMDA4JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDgnXShzb3VyY2VIYW5kbGUsIGVkZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSB9ID0gZ2V0RWRnZVBvc2l0aW9ucyhzb3VyY2VOb2RlUmVjdCwgc291cmNlSGFuZGxlLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0Tm9kZVJlY3QsIHRhcmdldEhhbmRsZSwgdGFyZ2V0UG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChFZGdlQ29tcG9uZW50LCB7IGtleTogZWRnZS5pZCwgaWQ6IGVkZ2UuaWQsIGNsYXNzTmFtZTogY2MoW2VkZ2UuY2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZV0pLCB0eXBlOiBlZGdlVHlwZSwgZGF0YTogZWRnZS5kYXRhLCBzZWxlY3RlZDogISFlZGdlLnNlbGVjdGVkLCBhbmltYXRlZDogISFlZGdlLmFuaW1hdGVkLCBoaWRkZW46ICEhZWRnZS5oaWRkZW4sIGxhYmVsOiBlZGdlLmxhYmVsLCBsYWJlbFN0eWxlOiBlZGdlLmxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBlZGdlLmxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGVkZ2UubGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogZWRnZS5sYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogZWRnZS5sYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogZWRnZS5zdHlsZSwgc291cmNlOiBlZGdlLnNvdXJjZSwgdGFyZ2V0OiBlZGdlLnRhcmdldCwgc291cmNlSGFuZGxlSWQ6IGVkZ2Uuc291cmNlSGFuZGxlLCB0YXJnZXRIYW5kbGVJZDogZWRnZS50YXJnZXRIYW5kbGUsIG1hcmtlckVuZDogZWRnZS5tYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBlZGdlLm1hcmtlclN0YXJ0LCBzb3VyY2VYOiBzb3VyY2VYLCBzb3VyY2VZOiBzb3VyY2VZLCB0YXJnZXRYOiB0YXJnZXRYLCB0YXJnZXRZOiB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbjogc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIG9uRWRnZVVwZGF0ZTogb25FZGdlVXBkYXRlLCBvbkNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25Nb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIG9uQ2xpY2s6IG9uRWRnZUNsaWNrLCBlZGdlVXBkYXRlclJhZGl1czogZWRnZVVwZGF0ZXJSYWRpdXMsIG9uRWRnZURvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGljaywgb25FZGdlVXBkYXRlU3RhcnQ6IG9uRWRnZVVwZGF0ZVN0YXJ0LCBvbkVkZ2VVcGRhdGVFbmQ6IG9uRWRnZVVwZGF0ZUVuZCwgcmZJZDogcmZJZCwgYXJpYUxhYmVsOiBlZGdlLmFyaWFMYWJlbCwgaXNGb2N1c2FibGU6IGlzRm9jdXNhYmxlLCBpc1VwZGF0YWJsZTogaXNVcGRhdGFibGUsIHBhdGhPcHRpb25zOiAncGF0aE9wdGlvbnMnIGluIGVkZ2UgPyBlZGdlLnBhdGhPcHRpb25zIDogdW5kZWZpbmVkLCBpbnRlcmFjdGlvbldpZHRoOiBlZGdlLmludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgICAgICAgICAgfSkpKSkpLFxuICAgICAgICBjaGlsZHJlbikpO1xufTtcbkVkZ2VSZW5kZXJlci5kaXNwbGF5TmFtZSA9ICdFZGdlUmVuZGVyZXInO1xudmFyIEVkZ2VSZW5kZXJlciQxID0gbWVtbyhFZGdlUmVuZGVyZXIpO1xuXG5jb25zdCBzZWxlY3RvciQzID0gKHMpID0+IGB0cmFuc2xhdGUoJHtzLnRyYW5zZm9ybVswXX1weCwke3MudHJhbnNmb3JtWzFdfXB4KSBzY2FsZSgke3MudHJhbnNmb3JtWzJdfSlgO1xuZnVuY3Rpb24gVmlld3BvcnQoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gdXNlU3RvcmUoc2VsZWN0b3IkMyk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3ZpZXdwb3J0IHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiLCBzdHlsZTogeyB0cmFuc2Zvcm0gfSB9LCBjaGlsZHJlbikpO1xufVxuXG5mdW5jdGlvbiB1c2VPbkluaXRIYW5kbGVyKG9uSW5pdCkge1xuICAgIGNvbnN0IHJmSW5zdGFuY2UgPSB1c2VSZWFjdEZsb3coKTtcbiAgICBjb25zdCBpc0luaXRpYWxpemVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWlzSW5pdGlhbGl6ZWQuY3VycmVudCAmJiByZkluc3RhbmNlLnZpZXdwb3J0SW5pdGlhbGl6ZWQgJiYgb25Jbml0KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG9uSW5pdChyZkluc3RhbmNlKSwgMSk7XG4gICAgICAgICAgICBpc0luaXRpYWxpemVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSwgW29uSW5pdCwgcmZJbnN0YW5jZS52aWV3cG9ydEluaXRpYWxpemVkXSk7XG59XG5cbmNvbnN0IG9wcG9zaXRlUG9zaXRpb24gPSB7XG4gICAgW1Bvc2l0aW9uLkxlZnRdOiBQb3NpdGlvbi5SaWdodCxcbiAgICBbUG9zaXRpb24uUmlnaHRdOiBQb3NpdGlvbi5MZWZ0LFxuICAgIFtQb3NpdGlvbi5Ub3BdOiBQb3NpdGlvbi5Cb3R0b20sXG4gICAgW1Bvc2l0aW9uLkJvdHRvbV06IFBvc2l0aW9uLlRvcCxcbn07XG5jb25zdCBDb25uZWN0aW9uTGluZSA9ICh7IG5vZGVJZCwgaGFuZGxlVHlwZSwgc3R5bGUsIHR5cGUgPSBDb25uZWN0aW9uTGluZVR5cGUuQmV6aWVyLCBDdXN0b21Db21wb25lbnQsIGNvbm5lY3Rpb25TdGF0dXMsIH0pID0+IHtcbiAgICBjb25zdCB7IGZyb21Ob2RlLCBoYW5kbGVJZCwgdG9YLCB0b1ksIGNvbm5lY3Rpb25Nb2RlIH0gPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygocykgPT4gKHtcbiAgICAgICAgZnJvbU5vZGU6IHMubm9kZUludGVybmFscy5nZXQobm9kZUlkKSxcbiAgICAgICAgaGFuZGxlSWQ6IHMuY29ubmVjdGlvbkhhbmRsZUlkLFxuICAgICAgICB0b1g6IChzLmNvbm5lY3Rpb25Qb3NpdGlvbi54IC0gcy50cmFuc2Zvcm1bMF0pIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIHRvWTogKHMuY29ubmVjdGlvblBvc2l0aW9uLnkgLSBzLnRyYW5zZm9ybVsxXSkgLyBzLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgY29ubmVjdGlvbk1vZGU6IHMuY29ubmVjdGlvbk1vZGUsXG4gICAgfSksIFtub2RlSWRdKSwgc2hhbGxvdyk7XG4gICAgY29uc3QgZnJvbUhhbmRsZUJvdW5kcyA9IGZyb21Ob2RlPy5baW50ZXJuYWxzU3ltYm9sXT8uaGFuZGxlQm91bmRzO1xuICAgIGxldCBoYW5kbGVCb3VuZHMgPSBmcm9tSGFuZGxlQm91bmRzPy5baGFuZGxlVHlwZV07XG4gICAgaWYgKGNvbm5lY3Rpb25Nb2RlID09PSBDb25uZWN0aW9uTW9kZS5Mb29zZSkge1xuICAgICAgICBoYW5kbGVCb3VuZHMgPSBoYW5kbGVCb3VuZHMgPyBoYW5kbGVCb3VuZHMgOiBmcm9tSGFuZGxlQm91bmRzPy5baGFuZGxlVHlwZSA9PT0gJ3NvdXJjZScgPyAndGFyZ2V0JyA6ICdzb3VyY2UnXTtcbiAgICB9XG4gICAgaWYgKCFmcm9tTm9kZSB8fCAhaGFuZGxlQm91bmRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSGFuZGxlID0gaGFuZGxlSWQgPyBoYW5kbGVCb3VuZHMuZmluZCgoZCkgPT4gZC5pZCA9PT0gaGFuZGxlSWQpIDogaGFuZGxlQm91bmRzWzBdO1xuICAgIGNvbnN0IGZyb21IYW5kbGVYID0gZnJvbUhhbmRsZSA/IGZyb21IYW5kbGUueCArIGZyb21IYW5kbGUud2lkdGggLyAyIDogKGZyb21Ob2RlLndpZHRoID8/IDApIC8gMjtcbiAgICBjb25zdCBmcm9tSGFuZGxlWSA9IGZyb21IYW5kbGUgPyBmcm9tSGFuZGxlLnkgKyBmcm9tSGFuZGxlLmhlaWdodCAvIDIgOiBmcm9tTm9kZS5oZWlnaHQgPz8gMDtcbiAgICBjb25zdCBmcm9tWCA9IChmcm9tTm9kZS5wb3NpdGlvbkFic29sdXRlPy54ID8/IDApICsgZnJvbUhhbmRsZVg7XG4gICAgY29uc3QgZnJvbVkgPSAoZnJvbU5vZGUucG9zaXRpb25BYnNvbHV0ZT8ueSA/PyAwKSArIGZyb21IYW5kbGVZO1xuICAgIGNvbnN0IGZyb21Qb3NpdGlvbiA9IGZyb21IYW5kbGU/LnBvc2l0aW9uO1xuICAgIGNvbnN0IHRvUG9zaXRpb24gPSBmcm9tUG9zaXRpb24gPyBvcHBvc2l0ZVBvc2l0aW9uW2Zyb21Qb3NpdGlvbl0gOiBudWxsO1xuICAgIGlmICghZnJvbVBvc2l0aW9uIHx8ICF0b1Bvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoQ3VzdG9tQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDdXN0b21Db21wb25lbnQsIHsgY29ubmVjdGlvbkxpbmVUeXBlOiB0eXBlLCBjb25uZWN0aW9uTGluZVN0eWxlOiBzdHlsZSwgZnJvbU5vZGU6IGZyb21Ob2RlLCBmcm9tSGFuZGxlOiBmcm9tSGFuZGxlLCBmcm9tWDogZnJvbVgsIGZyb21ZOiBmcm9tWSwgdG9YOiB0b1gsIHRvWTogdG9ZLCBmcm9tUG9zaXRpb246IGZyb21Qb3NpdGlvbiwgdG9Qb3NpdGlvbjogdG9Qb3NpdGlvbiwgY29ubmVjdGlvblN0YXR1czogY29ubmVjdGlvblN0YXR1cyB9KSk7XG4gICAgfVxuICAgIGxldCBkQXR0ciA9ICcnO1xuICAgIGNvbnN0IHBhdGhQYXJhbXMgPSB7XG4gICAgICAgIHNvdXJjZVg6IGZyb21YLFxuICAgICAgICBzb3VyY2VZOiBmcm9tWSxcbiAgICAgICAgc291cmNlUG9zaXRpb246IGZyb21Qb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0WDogdG9YLFxuICAgICAgICB0YXJnZXRZOiB0b1ksXG4gICAgICAgIHRhcmdldFBvc2l0aW9uOiB0b1Bvc2l0aW9uLFxuICAgIH07XG4gICAgaWYgKHR5cGUgPT09IENvbm5lY3Rpb25MaW5lVHlwZS5CZXppZXIpIHtcbiAgICAgICAgLy8gd2UgYXNzdW1lIHRoZSBkZXN0aW5hdGlvbiBwb3NpdGlvbiBpcyBvcHBvc2l0ZSB0byB0aGUgc291cmNlIHBvc2l0aW9uXG4gICAgICAgIFtkQXR0cl0gPSBnZXRCZXppZXJQYXRoKHBhdGhQYXJhbXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBDb25uZWN0aW9uTGluZVR5cGUuU3RlcCkge1xuICAgICAgICBbZEF0dHJdID0gZ2V0U21vb3RoU3RlcFBhdGgoe1xuICAgICAgICAgICAgLi4ucGF0aFBhcmFtcyxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IENvbm5lY3Rpb25MaW5lVHlwZS5TbW9vdGhTdGVwKSB7XG4gICAgICAgIFtkQXR0cl0gPSBnZXRTbW9vdGhTdGVwUGF0aChwYXRoUGFyYW1zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gQ29ubmVjdGlvbkxpbmVUeXBlLlNpbXBsZUJlemllcikge1xuICAgICAgICBbZEF0dHJdID0gZ2V0U2ltcGxlQmV6aWVyUGF0aChwYXRoUGFyYW1zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRBdHRyID0gYE0ke2Zyb21YfSwke2Zyb21ZfSAke3RvWH0sJHt0b1l9YDtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogZEF0dHIsIGZpbGw6IFwibm9uZVwiLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29ubmVjdGlvbi1wYXRoXCIsIHN0eWxlOiBzdHlsZSB9KTtcbn07XG5Db25uZWN0aW9uTGluZS5kaXNwbGF5TmFtZSA9ICdDb25uZWN0aW9uTGluZSc7XG5jb25zdCBzZWxlY3RvciQyID0gKHMpID0+ICh7XG4gICAgbm9kZUlkOiBzLmNvbm5lY3Rpb25Ob2RlSWQsXG4gICAgaGFuZGxlVHlwZTogcy5jb25uZWN0aW9uSGFuZGxlVHlwZSxcbiAgICBub2Rlc0Nvbm5lY3RhYmxlOiBzLm5vZGVzQ29ubmVjdGFibGUsXG4gICAgY29ubmVjdGlvblN0YXR1czogcy5jb25uZWN0aW9uU3RhdHVzLFxuICAgIHdpZHRoOiBzLndpZHRoLFxuICAgIGhlaWdodDogcy5oZWlnaHQsXG59KTtcbmZ1bmN0aW9uIENvbm5lY3Rpb25MaW5lV3JhcHBlcih7IGNvbnRhaW5lclN0eWxlLCBzdHlsZSwgdHlwZSwgY29tcG9uZW50IH0pIHtcbiAgICBjb25zdCB7IG5vZGVJZCwgaGFuZGxlVHlwZSwgbm9kZXNDb25uZWN0YWJsZSwgd2lkdGgsIGhlaWdodCwgY29ubmVjdGlvblN0YXR1cyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkMiwgc2hhbGxvdyk7XG4gICAgY29uc3QgaXNWYWxpZCA9ICEhKG5vZGVJZCAmJiBoYW5kbGVUeXBlICYmIHdpZHRoICYmIG5vZGVzQ29ubmVjdGFibGUpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgc3R5bGU6IGNvbnRhaW5lclN0eWxlLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZXMgcmVhY3QtZmxvd19fY29ubmVjdGlvbmxpbmUgcmVhY3QtZmxvd19fY29udGFpbmVyXCIgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fY29ubmVjdGlvbicsIGNvbm5lY3Rpb25TdGF0dXNdKSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0aW9uTGluZSwgeyBub2RlSWQ6IG5vZGVJZCwgaGFuZGxlVHlwZTogaGFuZGxlVHlwZSwgc3R5bGU6IHN0eWxlLCB0eXBlOiB0eXBlLCBDdXN0b21Db21wb25lbnQ6IGNvbXBvbmVudCwgY29ubmVjdGlvblN0YXR1czogY29ubmVjdGlvblN0YXR1cyB9KSkpKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHVzZU5vZGVPckVkZ2VUeXBlcyhub2RlT3JFZGdlVHlwZXMsIGNyZWF0ZVR5cGVzKSB7XG4gICAgY29uc3QgdHlwZXNLZXlzUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB0eXBlc1BhcnNlZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVLZXlzID0gT2JqZWN0LmtleXMobm9kZU9yRWRnZVR5cGVzKTtcbiAgICAgICAgICAgIGlmIChzaGFsbG93KHR5cGVzS2V5c1JlZi5jdXJyZW50LCB0eXBlS2V5cykpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDAyJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDInXSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGVzS2V5c1JlZi5jdXJyZW50ID0gdHlwZUtleXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVR5cGVzKG5vZGVPckVkZ2VUeXBlcyk7XG4gICAgfSwgW25vZGVPckVkZ2VUeXBlc10pO1xuICAgIHJldHVybiB0eXBlc1BhcnNlZDtcbn1cblxuY29uc3QgR3JhcGhWaWV3ID0gKHsgbm9kZVR5cGVzLCBlZGdlVHlwZXMsIG9uTW92ZSwgb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZCwgb25Jbml0LCBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2ssIG9uTm9kZURvdWJsZUNsaWNrLCBvbkVkZ2VEb3VibGVDbGljaywgb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudSwgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQsIGNvbm5lY3Rpb25MaW5lVHlwZSwgY29ubmVjdGlvbkxpbmVTdHlsZSwgY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUsIHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZywgc2VsZWN0aW9uTW9kZSwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBkZWxldGVLZXlDb2RlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBlbGVtZW50c1NlbGVjdGFibGUsIHNlbGVjdE5vZGVzT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZywgZGVmYXVsdE1hcmtlckNvbG9yLCB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoLCBwYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljaywgcGFuT25EcmFnLCBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51LCBvbkVkZ2VVcGRhdGUsIG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmUsIGVkZ2VVcGRhdGVyUmFkaXVzLCBvbkVkZ2VVcGRhdGVTdGFydCwgb25FZGdlVXBkYXRlRW5kLCBub0RyYWdDbGFzc05hbWUsIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBlbGV2YXRlRWRnZXNPblNlbGVjdCwgZGlzYWJsZUtleWJvYXJkQTExeSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgcmZJZCwgfSkgPT4ge1xuICAgIGNvbnN0IG5vZGVUeXBlc1dyYXBwZWQgPSB1c2VOb2RlT3JFZGdlVHlwZXMobm9kZVR5cGVzLCBjcmVhdGVOb2RlVHlwZXMpO1xuICAgIGNvbnN0IGVkZ2VUeXBlc1dyYXBwZWQgPSB1c2VOb2RlT3JFZGdlVHlwZXMoZWRnZVR5cGVzLCBjcmVhdGVFZGdlVHlwZXMpO1xuICAgIHVzZU9uSW5pdEhhbmRsZXIob25Jbml0KTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvd1JlbmRlcmVyJDEsIHsgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lQ29udGV4dE1lbnU6IG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGw6IG9uUGFuZVNjcm9sbCwgZGVsZXRlS2V5Q29kZTogZGVsZXRlS2V5Q29kZSwgc2VsZWN0aW9uS2V5Q29kZTogc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnOiBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlOiBtdWx0aVNlbGVjdGlvbktleUNvZGUsIHBhbkFjdGl2YXRpb25LZXlDb2RlOiBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlOiB6b29tQWN0aXZhdGlvbktleUNvZGUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCBvbk1vdmU6IG9uTW92ZSwgb25Nb3ZlU3RhcnQ6IG9uTW92ZVN0YXJ0LCBvbk1vdmVFbmQ6IG9uTW92ZUVuZCwgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgZGVmYXVsdFZpZXdwb3J0OiBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudDogdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBvblNlbGVjdGlvbkNvbnRleHRNZW51OiBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBwcmV2ZW50U2Nyb2xsaW5nOiBwcmV2ZW50U2Nyb2xsaW5nLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVmlld3BvcnQsIG51bGwsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEVkZ2VSZW5kZXJlciQxLCB7IGVkZ2VUeXBlczogZWRnZVR5cGVzV3JhcHBlZCwgb25FZGdlQ2xpY2s6IG9uRWRnZUNsaWNrLCBvbkVkZ2VEb3VibGVDbGljazogb25FZGdlRG91YmxlQ2xpY2ssIG9uRWRnZVVwZGF0ZTogb25FZGdlVXBkYXRlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBvbkVkZ2VDb250ZXh0TWVudTogb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXI6IG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlOiBvbkVkZ2VNb3VzZUxlYXZlLCBvbkVkZ2VVcGRhdGVTdGFydDogb25FZGdlVXBkYXRlU3RhcnQsIG9uRWRnZVVwZGF0ZUVuZDogb25FZGdlVXBkYXRlRW5kLCBlZGdlVXBkYXRlclJhZGl1czogZWRnZVVwZGF0ZXJSYWRpdXMsIGRlZmF1bHRNYXJrZXJDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIGVsZXZhdGVFZGdlc09uU2VsZWN0OiAhIWVsZXZhdGVFZGdlc09uU2VsZWN0LCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCByZklkOiByZklkIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0aW9uTGluZVdyYXBwZXIsIHsgc3R5bGU6IGNvbm5lY3Rpb25MaW5lU3R5bGUsIHR5cGU6IGNvbm5lY3Rpb25MaW5lVHlwZSwgY29tcG9uZW50OiBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29udGFpbmVyU3R5bGU6IGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUgfSkpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlbGFiZWwtcmVuZGVyZXJcIiB9KSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTm9kZVJlbmRlcmVyJDEsIHsgbm9kZVR5cGVzOiBub2RlVHlwZXNXcmFwcGVkLCBvbk5vZGVDbGljazogb25Ob2RlQ2xpY2ssIG9uTm9kZURvdWJsZUNsaWNrOiBvbk5vZGVEb3VibGVDbGljaywgb25Ob2RlTW91c2VFbnRlcjogb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlOiBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmU6IG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51OiBvbk5vZGVDb250ZXh0TWVudSwgc2VsZWN0Tm9kZXNPbkRyYWc6IHNlbGVjdE5vZGVzT25EcmFnLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIG5vRHJhZ0NsYXNzTmFtZTogbm9EcmFnQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCByZklkOiByZklkIH0pKSkpO1xufTtcbkdyYXBoVmlldy5kaXNwbGF5TmFtZSA9ICdHcmFwaFZpZXcnO1xudmFyIEdyYXBoVmlldyQxID0gbWVtbyhHcmFwaFZpZXcpO1xuXG5jb25zdCBpbmZpbml0ZUV4dGVudCA9IFtcbiAgICBbTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFldLFxuICAgIFtOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWV0sXG5dO1xuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgIHJmSWQ6ICcxJyxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgdHJhbnNmb3JtOiBbMCwgMCwgMV0sXG4gICAgbm9kZUludGVybmFsczogbmV3IE1hcCgpLFxuICAgIGVkZ2VzOiBbXSxcbiAgICBvbk5vZGVzQ2hhbmdlOiBudWxsLFxuICAgIG9uRWRnZXNDaGFuZ2U6IG51bGwsXG4gICAgaGFzRGVmYXVsdE5vZGVzOiBmYWxzZSxcbiAgICBoYXNEZWZhdWx0RWRnZXM6IGZhbHNlLFxuICAgIGQzWm9vbTogbnVsbCxcbiAgICBkM1NlbGVjdGlvbjogbnVsbCxcbiAgICBkM1pvb21IYW5kbGVyOiB1bmRlZmluZWQsXG4gICAgbWluWm9vbTogMC41LFxuICAgIG1heFpvb206IDIsXG4gICAgdHJhbnNsYXRlRXh0ZW50OiBpbmZpbml0ZUV4dGVudCxcbiAgICBub2RlRXh0ZW50OiBpbmZpbml0ZUV4dGVudCxcbiAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgdXNlclNlbGVjdGlvblJlY3Q6IG51bGwsXG4gICAgY29ubmVjdGlvbk5vZGVJZDogbnVsbCxcbiAgICBjb25uZWN0aW9uSGFuZGxlSWQ6IG51bGwsXG4gICAgY29ubmVjdGlvbkhhbmRsZVR5cGU6ICdzb3VyY2UnLFxuICAgIGNvbm5lY3Rpb25Qb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sXG4gICAgY29ubmVjdGlvblN0YXR1czogbnVsbCxcbiAgICBjb25uZWN0aW9uTW9kZTogQ29ubmVjdGlvbk1vZGUuU3RyaWN0LFxuICAgIGRvbU5vZGU6IG51bGwsXG4gICAgcGFuZURyYWdnaW5nOiBmYWxzZSxcbiAgICBub1BhbkNsYXNzTmFtZTogJ25vcGFuJyxcbiAgICBub2RlT3JpZ2luOiBbMCwgMF0sXG4gICAgbm9kZURyYWdUaHJlc2hvbGQ6IDAsXG4gICAgc25hcEdyaWQ6IFsxNSwgMTVdLFxuICAgIHNuYXBUb0dyaWQ6IGZhbHNlLFxuICAgIG5vZGVzRHJhZ2dhYmxlOiB0cnVlLFxuICAgIG5vZGVzQ29ubmVjdGFibGU6IHRydWUsXG4gICAgbm9kZXNGb2N1c2FibGU6IHRydWUsXG4gICAgZWRnZXNGb2N1c2FibGU6IHRydWUsXG4gICAgZWRnZXNVcGRhdGFibGU6IHRydWUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiB0cnVlLFxuICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0OiB0cnVlLFxuICAgIGZpdFZpZXdPbkluaXQ6IGZhbHNlLFxuICAgIGZpdFZpZXdPbkluaXREb25lOiBmYWxzZSxcbiAgICBmaXRWaWV3T25Jbml0T3B0aW9uczogdW5kZWZpbmVkLFxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlOiBbXSxcbiAgICBtdWx0aVNlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgY29ubmVjdGlvblN0YXJ0SGFuZGxlOiBudWxsLFxuICAgIGNvbm5lY3Rpb25FbmRIYW5kbGU6IG51bGwsXG4gICAgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IG51bGwsXG4gICAgY29ubmVjdE9uQ2xpY2s6IHRydWUsXG4gICAgYXJpYUxpdmVNZXNzYWdlOiAnJyxcbiAgICBhdXRvUGFuT25Db25uZWN0OiB0cnVlLFxuICAgIGF1dG9QYW5Pbk5vZGVEcmFnOiB0cnVlLFxuICAgIGNvbm5lY3Rpb25SYWRpdXM6IDIwLFxuICAgIG9uRXJyb3I6IGRldldhcm4sXG4gICAgaXNWYWxpZENvbm5lY3Rpb246IHVuZGVmaW5lZCxcbn07XG5cbmNvbnN0IGNyZWF0ZVJGU3RvcmUgPSAoKSA9PiBjcmVhdGVXaXRoRXF1YWxpdHlGbigoc2V0LCBnZXQpID0+ICh7XG4gICAgLi4uaW5pdGlhbFN0YXRlLFxuICAgIHNldE5vZGVzOiAobm9kZXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBub2RlSW50ZXJuYWxzLCBub2RlT3JpZ2luLCBlbGV2YXRlTm9kZXNPblNlbGVjdCB9ID0gZ2V0KCk7XG4gICAgICAgIHNldCh7IG5vZGVJbnRlcm5hbHM6IGNyZWF0ZU5vZGVJbnRlcm5hbHMobm9kZXMsIG5vZGVJbnRlcm5hbHMsIG5vZGVPcmlnaW4sIGVsZXZhdGVOb2Rlc09uU2VsZWN0KSB9KTtcbiAgICB9LFxuICAgIGdldE5vZGVzOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGdldCgpLm5vZGVJbnRlcm5hbHMudmFsdWVzKCkpO1xuICAgIH0sXG4gICAgc2V0RWRnZXM6IChlZGdlcykgPT4ge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHRFZGdlT3B0aW9ucyA9IHt9IH0gPSBnZXQoKTtcbiAgICAgICAgc2V0KHsgZWRnZXM6IGVkZ2VzLm1hcCgoZSkgPT4gKHsgLi4uZGVmYXVsdEVkZ2VPcHRpb25zLCAuLi5lIH0pKSB9KTtcbiAgICB9LFxuICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzOiAobm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc0RlZmF1bHROb2RlcyA9IHR5cGVvZiBub2RlcyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGNvbnN0IGhhc0RlZmF1bHRFZGdlcyA9IHR5cGVvZiBlZGdlcyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGNvbnN0IG5vZGVJbnRlcm5hbHMgPSBoYXNEZWZhdWx0Tm9kZXNcbiAgICAgICAgICAgID8gY3JlYXRlTm9kZUludGVybmFscyhub2RlcywgbmV3IE1hcCgpLCBnZXQoKS5ub2RlT3JpZ2luLCBnZXQoKS5lbGV2YXRlTm9kZXNPblNlbGVjdClcbiAgICAgICAgICAgIDogbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBuZXh0RWRnZXMgPSBoYXNEZWZhdWx0RWRnZXMgPyBlZGdlcyA6IFtdO1xuICAgICAgICBzZXQoeyBub2RlSW50ZXJuYWxzLCBlZGdlczogbmV4dEVkZ2VzLCBoYXNEZWZhdWx0Tm9kZXMsIGhhc0RlZmF1bHRFZGdlcyB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZU5vZGVEaW1lbnNpb25zOiAodXBkYXRlcykgPT4ge1xuICAgICAgICBjb25zdCB7IG9uTm9kZXNDaGFuZ2UsIG5vZGVJbnRlcm5hbHMsIGZpdFZpZXdPbkluaXQsIGZpdFZpZXdPbkluaXREb25lLCBmaXRWaWV3T25Jbml0T3B0aW9ucywgZG9tTm9kZSwgbm9kZU9yaWdpbiwgfSA9IGdldCgpO1xuICAgICAgICBjb25zdCB2aWV3cG9ydE5vZGUgPSBkb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fdmlld3BvcnQnKTtcbiAgICAgICAgaWYgKCF2aWV3cG9ydE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHZpZXdwb3J0Tm9kZSk7XG4gICAgICAgIGNvbnN0IHsgbTIyOiB6b29tIH0gPSBuZXcgd2luZG93LkRPTU1hdHJpeFJlYWRPbmx5KHN0eWxlLnRyYW5zZm9ybSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSB1cGRhdGVzLnJlZHVjZSgocmVzLCB1cGRhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlSW50ZXJuYWxzLmdldCh1cGRhdGUuaWQpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaW1lbnNpb25zID0gZ2V0RGltZW5zaW9ucyh1cGRhdGUubm9kZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvVXBkYXRlID0gISEoZGltZW5zaW9ucy53aWR0aCAmJlxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCAmJlxuICAgICAgICAgICAgICAgICAgICAobm9kZS53aWR0aCAhPT0gZGltZW5zaW9ucy53aWR0aCB8fCBub2RlLmhlaWdodCAhPT0gZGltZW5zaW9ucy5oZWlnaHQgfHwgdXBkYXRlLmZvcmNlVXBkYXRlKSk7XG4gICAgICAgICAgICAgICAgaWYgKGRvVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbnRlcm5hbHMuc2V0KG5vZGUuaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBbaW50ZXJuYWxzU3ltYm9sXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm5vZGVbaW50ZXJuYWxzU3ltYm9sXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVCb3VuZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBnZXRIYW5kbGVCb3VuZHMoJy5zb3VyY2UnLCB1cGRhdGUubm9kZUVsZW1lbnQsIHpvb20sIG5vZGVPcmlnaW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGdldEhhbmRsZUJvdW5kcygnLnRhcmdldCcsIHVwZGF0ZS5ub2RlRWxlbWVudCwgem9vbSwgbm9kZU9yaWdpbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHVwZGF0ZUFic29sdXRlTm9kZVBvc2l0aW9ucyhub2RlSW50ZXJuYWxzLCBub2RlT3JpZ2luKTtcbiAgICAgICAgY29uc3QgbmV4dEZpdFZpZXdPbkluaXREb25lID0gZml0Vmlld09uSW5pdERvbmUgfHxcbiAgICAgICAgICAgIChmaXRWaWV3T25Jbml0ICYmICFmaXRWaWV3T25Jbml0RG9uZSAmJiBmaXRWaWV3KGdldCwgeyBpbml0aWFsOiB0cnVlLCAuLi5maXRWaWV3T25Jbml0T3B0aW9ucyB9KSk7XG4gICAgICAgIHNldCh7IG5vZGVJbnRlcm5hbHM6IG5ldyBNYXAobm9kZUludGVybmFscyksIGZpdFZpZXdPbkluaXREb25lOiBuZXh0Rml0Vmlld09uSW5pdERvbmUgfSk7XG4gICAgICAgIGlmIChjaGFuZ2VzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvbk5vZGVzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnM6IChub2RlRHJhZ0l0ZW1zLCBwb3NpdGlvbkNoYW5nZWQgPSB0cnVlLCBkcmFnZ2luZyA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdHJpZ2dlck5vZGVDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IG5vZGVEcmFnSXRlbXMubWFwKChub2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlLnBvc2l0aW9uQWJzb2x1dGUgPSBub2RlLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgICAgICAgICAgY2hhbmdlLnBvc2l0aW9uID0gbm9kZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgfSxcbiAgICB0cmlnZ2VyTm9kZUNoYW5nZXM6IChjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25Ob2Rlc0NoYW5nZSwgbm9kZUludGVybmFscywgaGFzRGVmYXVsdE5vZGVzLCBub2RlT3JpZ2luLCBnZXROb2RlcywgZWxldmF0ZU5vZGVzT25TZWxlY3QgfSA9IGdldCgpO1xuICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIGdldE5vZGVzKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHROb2RlSW50ZXJuYWxzID0gY3JlYXRlTm9kZUludGVybmFscyhub2Rlcywgbm9kZUludGVybmFscywgbm9kZU9yaWdpbiwgZWxldmF0ZU5vZGVzT25TZWxlY3QpO1xuICAgICAgICAgICAgICAgIHNldCh7IG5vZGVJbnRlcm5hbHM6IG5leHROb2RlSW50ZXJuYWxzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZT8uKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhZGRTZWxlY3RlZE5vZGVzOiAoc2VsZWN0ZWROb2RlSWRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VzLCBnZXROb2RlcyB9ID0gZ2V0KCk7XG4gICAgICAgIGxldCBjaGFuZ2VkTm9kZXM7XG4gICAgICAgIGxldCBjaGFuZ2VkRWRnZXMgPSBudWxsO1xuICAgICAgICBpZiAobXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgIGNoYW5nZWROb2RlcyA9IHNlbGVjdGVkTm9kZUlkcy5tYXAoKG5vZGVJZCkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKG5vZGVJZCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbmdlZE5vZGVzID0gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhnZXROb2RlcygpLCBzZWxlY3RlZE5vZGVJZHMpO1xuICAgICAgICAgICAgY2hhbmdlZEVkZ2VzID0gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlcywgW10pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZU5vZGVzQW5kRWRnZXNTZWxlY3Rpb25zKHtcbiAgICAgICAgICAgIGNoYW5nZWROb2RlcyxcbiAgICAgICAgICAgIGNoYW5nZWRFZGdlcyxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIHNldCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBhZGRTZWxlY3RlZEVkZ2VzOiAoc2VsZWN0ZWRFZGdlSWRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VzLCBnZXROb2RlcyB9ID0gZ2V0KCk7XG4gICAgICAgIGxldCBjaGFuZ2VkRWRnZXM7XG4gICAgICAgIGxldCBjaGFuZ2VkTm9kZXMgPSBudWxsO1xuICAgICAgICBpZiAobXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgIGNoYW5nZWRFZGdlcyA9IHNlbGVjdGVkRWRnZUlkcy5tYXAoKGVkZ2VJZCkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2VJZCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbmdlZEVkZ2VzID0gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlcywgc2VsZWN0ZWRFZGdlSWRzKTtcbiAgICAgICAgICAgIGNoYW5nZWROb2RlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMoZ2V0Tm9kZXMoKSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZU5vZGVzQW5kRWRnZXNTZWxlY3Rpb25zKHtcbiAgICAgICAgICAgIGNoYW5nZWROb2RlcyxcbiAgICAgICAgICAgIGNoYW5nZWRFZGdlcyxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIHNldCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXM6ICh7IG5vZGVzLCBlZGdlcyB9ID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgeyBlZGdlczogc3RvcmVFZGdlcywgZ2V0Tm9kZXMgfSA9IGdldCgpO1xuICAgICAgICBjb25zdCBub2Rlc1RvVW5zZWxlY3QgPSBub2RlcyA/IG5vZGVzIDogZ2V0Tm9kZXMoKTtcbiAgICAgICAgY29uc3QgZWRnZXNUb1Vuc2VsZWN0ID0gZWRnZXMgPyBlZGdlcyA6IHN0b3JlRWRnZXM7XG4gICAgICAgIGNvbnN0IGNoYW5nZWROb2RlcyA9IG5vZGVzVG9VbnNlbGVjdC5tYXAoKG4pID0+IHtcbiAgICAgICAgICAgIG4uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobi5pZCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2hhbmdlZEVkZ2VzID0gZWRnZXNUb1Vuc2VsZWN0Lm1hcCgoZWRnZSkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2UuaWQsIGZhbHNlKSk7XG4gICAgICAgIHVwZGF0ZU5vZGVzQW5kRWRnZXNTZWxlY3Rpb25zKHtcbiAgICAgICAgICAgIGNoYW5nZWROb2RlcyxcbiAgICAgICAgICAgIGNoYW5nZWRFZGdlcyxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIHNldCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXRNaW5ab29tOiAobWluWm9vbSkgPT4ge1xuICAgICAgICBjb25zdCB7IGQzWm9vbSwgbWF4Wm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgIGQzWm9vbT8uc2NhbGVFeHRlbnQoW21pblpvb20sIG1heFpvb21dKTtcbiAgICAgICAgc2V0KHsgbWluWm9vbSB9KTtcbiAgICB9LFxuICAgIHNldE1heFpvb206IChtYXhab29tKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZDNab29tLCBtaW5ab29tIH0gPSBnZXQoKTtcbiAgICAgICAgZDNab29tPy5zY2FsZUV4dGVudChbbWluWm9vbSwgbWF4Wm9vbV0pO1xuICAgICAgICBzZXQoeyBtYXhab29tIH0pO1xuICAgIH0sXG4gICAgc2V0VHJhbnNsYXRlRXh0ZW50OiAodHJhbnNsYXRlRXh0ZW50KSA9PiB7XG4gICAgICAgIGdldCgpLmQzWm9vbT8udHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgIHNldCh7IHRyYW5zbGF0ZUV4dGVudCB9KTtcbiAgICB9LFxuICAgIHJlc2V0U2VsZWN0ZWRFbGVtZW50czogKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGVkZ2VzLCBnZXROb2RlcyB9ID0gZ2V0KCk7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gZ2V0Tm9kZXMoKTtcbiAgICAgICAgY29uc3Qgbm9kZXNUb1Vuc2VsZWN0ID0gbm9kZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKGUpID0+IGUuc2VsZWN0ZWQpXG4gICAgICAgICAgICAubWFwKChuKSA9PiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobi5pZCwgZmFsc2UpKTtcbiAgICAgICAgY29uc3QgZWRnZXNUb1Vuc2VsZWN0ID0gZWRnZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKGUpID0+IGUuc2VsZWN0ZWQpXG4gICAgICAgICAgICAubWFwKChlKSA9PiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoZS5pZCwgZmFsc2UpKTtcbiAgICAgICAgdXBkYXRlTm9kZXNBbmRFZGdlc1NlbGVjdGlvbnMoe1xuICAgICAgICAgICAgY2hhbmdlZE5vZGVzOiBub2Rlc1RvVW5zZWxlY3QsXG4gICAgICAgICAgICBjaGFuZ2VkRWRnZXM6IGVkZ2VzVG9VbnNlbGVjdCxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIHNldCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXROb2RlRXh0ZW50OiAobm9kZUV4dGVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IG5vZGVJbnRlcm5hbHMgfSA9IGdldCgpO1xuICAgICAgICBub2RlSW50ZXJuYWxzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIG5vZGUucG9zaXRpb25BYnNvbHV0ZSA9IGNsYW1wUG9zaXRpb24obm9kZS5wb3NpdGlvbiwgbm9kZUV4dGVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXQoe1xuICAgICAgICAgICAgbm9kZUV4dGVudCxcbiAgICAgICAgICAgIG5vZGVJbnRlcm5hbHM6IG5ldyBNYXAobm9kZUludGVybmFscyksXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgcGFuQnk6IChkZWx0YSkgPT4ge1xuICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgd2lkdGgsIGhlaWdodCwgZDNab29tLCBkM1NlbGVjdGlvbiwgdHJhbnNsYXRlRXh0ZW50IH0gPSBnZXQoKTtcbiAgICAgICAgaWYgKCFkM1pvb20gfHwgIWQzU2VsZWN0aW9uIHx8ICghZGVsdGEueCAmJiAhZGVsdGEueSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0VHJhbnNmb3JtID0gem9vbUlkZW50aXR5XG4gICAgICAgICAgICAudHJhbnNsYXRlKHRyYW5zZm9ybVswXSArIGRlbHRhLngsIHRyYW5zZm9ybVsxXSArIGRlbHRhLnkpXG4gICAgICAgICAgICAuc2NhbGUodHJhbnNmb3JtWzJdKTtcbiAgICAgICAgY29uc3QgZXh0ZW50ID0gW1xuICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgICAgW3dpZHRoLCBoZWlnaHRdLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBjb25zdHJhaW5lZFRyYW5zZm9ybSA9IGQzWm9vbT8uY29uc3RyYWluKCkobmV4dFRyYW5zZm9ybSwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgICAgICBkM1pvb20udHJhbnNmb3JtKGQzU2VsZWN0aW9uLCBjb25zdHJhaW5lZFRyYW5zZm9ybSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybUNoYW5nZWQgPSB0cmFuc2Zvcm1bMF0gIT09IGNvbnN0cmFpbmVkVHJhbnNmb3JtLnggfHxcbiAgICAgICAgICAgIHRyYW5zZm9ybVsxXSAhPT0gY29uc3RyYWluZWRUcmFuc2Zvcm0ueSB8fFxuICAgICAgICAgICAgdHJhbnNmb3JtWzJdICE9PSBjb25zdHJhaW5lZFRyYW5zZm9ybS5rO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtQ2hhbmdlZDtcbiAgICB9LFxuICAgIGNhbmNlbENvbm5lY3Rpb246ICgpID0+IHNldCh7XG4gICAgICAgIGNvbm5lY3Rpb25Ob2RlSWQ6IGluaXRpYWxTdGF0ZS5jb25uZWN0aW9uTm9kZUlkLFxuICAgICAgICBjb25uZWN0aW9uSGFuZGxlSWQ6IGluaXRpYWxTdGF0ZS5jb25uZWN0aW9uSGFuZGxlSWQsXG4gICAgICAgIGNvbm5lY3Rpb25IYW5kbGVUeXBlOiBpbml0aWFsU3RhdGUuY29ubmVjdGlvbkhhbmRsZVR5cGUsXG4gICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6IGluaXRpYWxTdGF0ZS5jb25uZWN0aW9uU3RhdHVzLFxuICAgICAgICBjb25uZWN0aW9uU3RhcnRIYW5kbGU6IGluaXRpYWxTdGF0ZS5jb25uZWN0aW9uU3RhcnRIYW5kbGUsXG4gICAgICAgIGNvbm5lY3Rpb25FbmRIYW5kbGU6IGluaXRpYWxTdGF0ZS5jb25uZWN0aW9uRW5kSGFuZGxlLFxuICAgIH0pLFxuICAgIHJlc2V0OiAoKSA9PiBzZXQoeyAuLi5pbml0aWFsU3RhdGUgfSksXG59KSwgT2JqZWN0LmlzKTtcblxuY29uc3QgUmVhY3RGbG93UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgY29uc3Qgc3RvcmVSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgaWYgKCFzdG9yZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHN0b3JlUmVmLmN1cnJlbnQgPSBjcmVhdGVSRlN0b3JlKCk7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFByb3ZpZGVyJDEsIHsgdmFsdWU6IHN0b3JlUmVmLmN1cnJlbnQgfSwgY2hpbGRyZW4pO1xufTtcblJlYWN0Rmxvd1Byb3ZpZGVyLmRpc3BsYXlOYW1lID0gJ1JlYWN0Rmxvd1Byb3ZpZGVyJztcblxuY29uc3QgV3JhcHBlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICBjb25zdCBpc1dyYXBwZWQgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKGlzV3JhcHBlZCkge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgaXQgd2l0aCBhIGZyYWdtZW50IGJlY2F1c2UgaXQncyBub3QgYWxsb3dlZCBmb3IgY2hpbGRyZW4gdG8gYmUgYSBSZWFjdE5vZGVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0RlZmluaXRlbHlUeXBlZC9EZWZpbml0ZWx5VHlwZWQvaXNzdWVzLzE4MDUxXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0Rmxvd1Byb3ZpZGVyLCBudWxsLCBjaGlsZHJlbik7XG59O1xuV3JhcHBlci5kaXNwbGF5TmFtZSA9ICdSZWFjdEZsb3dXcmFwcGVyJztcblxuY29uc3QgZGVmYXVsdE5vZGVUeXBlcyA9IHtcbiAgICBpbnB1dDogSW5wdXROb2RlJDEsXG4gICAgZGVmYXVsdDogRGVmYXVsdE5vZGUkMSxcbiAgICBvdXRwdXQ6IE91dHB1dE5vZGUkMSxcbiAgICBncm91cDogR3JvdXBOb2RlLFxufTtcbmNvbnN0IGRlZmF1bHRFZGdlVHlwZXMgPSB7XG4gICAgZGVmYXVsdDogQmV6aWVyRWRnZSxcbiAgICBzdHJhaWdodDogU3RyYWlnaHRFZGdlLFxuICAgIHN0ZXA6IFN0ZXBFZGdlLFxuICAgIHNtb290aHN0ZXA6IFNtb290aFN0ZXBFZGdlLFxuICAgIHNpbXBsZWJlemllcjogU2ltcGxlQmV6aWVyRWRnZSxcbn07XG5jb25zdCBpbml0Tm9kZU9yaWdpbiA9IFswLCAwXTtcbmNvbnN0IGluaXRTbmFwR3JpZCA9IFsxNSwgMTVdO1xuY29uc3QgaW5pdERlZmF1bHRWaWV3cG9ydCA9IHsgeDogMCwgeTogMCwgem9vbTogMSB9O1xuY29uc3Qgd3JhcHBlclN0eWxlID0ge1xuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIHpJbmRleDogMCxcbn07XG5jb25zdCBSZWFjdEZsb3cgPSBmb3J3YXJkUmVmKCh7IG5vZGVzLCBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIGNsYXNzTmFtZSwgbm9kZVR5cGVzID0gZGVmYXVsdE5vZGVUeXBlcywgZWRnZVR5cGVzID0gZGVmYXVsdEVkZ2VUeXBlcywgb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrLCBvbkluaXQsIG9uTW92ZSwgb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZCwgb25Db25uZWN0LCBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kLCBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBvbkNsaWNrQ29ubmVjdEVuZCwgb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudSwgb25Ob2RlRG91YmxlQ2xpY2ssIG9uTm9kZURyYWdTdGFydCwgb25Ob2RlRHJhZywgb25Ob2RlRHJhZ1N0b3AsIG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGUsIG9uU2VsZWN0aW9uQ2hhbmdlLCBvblNlbGVjdGlvbkRyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnLCBvblNlbGVjdGlvbkRyYWdTdG9wLCBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgY29ubmVjdGlvbk1vZGUgPSBDb25uZWN0aW9uTW9kZS5TdHJpY3QsIGNvbm5lY3Rpb25MaW5lVHlwZSA9IENvbm5lY3Rpb25MaW5lVHlwZS5CZXppZXIsIGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50LCBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlLCBkZWxldGVLZXlDb2RlID0gJ0JhY2tzcGFjZScsIHNlbGVjdGlvbktleUNvZGUgPSAnU2hpZnQnLCBzZWxlY3Rpb25PbkRyYWcgPSBmYWxzZSwgc2VsZWN0aW9uTW9kZSA9IFNlbGVjdGlvbk1vZGUuRnVsbCwgcGFuQWN0aXZhdGlvbktleUNvZGUgPSAnU3BhY2UnLCBtdWx0aVNlbGVjdGlvbktleUNvZGUgPSBpc01hY09zKCkgPyAnTWV0YScgOiAnQ29udHJvbCcsIHpvb21BY3RpdmF0aW9uS2V5Q29kZSA9IGlzTWFjT3MoKSA/ICdNZXRhJyA6ICdDb250cm9sJywgc25hcFRvR3JpZCA9IGZhbHNlLCBzbmFwR3JpZCA9IGluaXRTbmFwR3JpZCwgb25seVJlbmRlclZpc2libGVFbGVtZW50cyA9IGZhbHNlLCBzZWxlY3ROb2Rlc09uRHJhZyA9IHRydWUsIG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgbm9kZU9yaWdpbiA9IGluaXROb2RlT3JpZ2luLCBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNVcGRhdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgZGVmYXVsdFZpZXdwb3J0ID0gaW5pdERlZmF1bHRWaWV3cG9ydCwgbWluWm9vbSA9IDAuNSwgbWF4Wm9vbSA9IDIsIHRyYW5zbGF0ZUV4dGVudCA9IGluZmluaXRlRXh0ZW50LCBwcmV2ZW50U2Nyb2xsaW5nID0gdHJ1ZSwgbm9kZUV4dGVudCwgZGVmYXVsdE1hcmtlckNvbG9yID0gJyNiMWIxYjcnLCB6b29tT25TY3JvbGwgPSB0cnVlLCB6b29tT25QaW5jaCA9IHRydWUsIHBhbk9uU2Nyb2xsID0gZmFsc2UsIHBhbk9uU2Nyb2xsU3BlZWQgPSAwLjUsIHBhbk9uU2Nyb2xsTW9kZSA9IFBhbk9uU2Nyb2xsTW9kZS5GcmVlLCB6b29tT25Eb3VibGVDbGljayA9IHRydWUsIHBhbk9uRHJhZyA9IHRydWUsIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZVNjcm9sbCwgb25QYW5lQ29udGV4dE1lbnUsIGNoaWxkcmVuLCBvbkVkZ2VVcGRhdGUsIG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VEb3VibGVDbGljaywgb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlLCBvbkVkZ2VVcGRhdGVTdGFydCwgb25FZGdlVXBkYXRlRW5kLCBlZGdlVXBkYXRlclJhZGl1cyA9IDEwLCBvbk5vZGVzQ2hhbmdlLCBvbkVkZ2VzQ2hhbmdlLCBub0RyYWdDbGFzc05hbWUgPSAnbm9kcmFnJywgbm9XaGVlbENsYXNzTmFtZSA9ICdub3doZWVsJywgbm9QYW5DbGFzc05hbWUgPSAnbm9wYW4nLCBmaXRWaWV3ID0gZmFsc2UsIGZpdFZpZXdPcHRpb25zLCBjb25uZWN0T25DbGljayA9IHRydWUsIGF0dHJpYnV0aW9uUG9zaXRpb24sIHByb09wdGlvbnMsIGRlZmF1bHRFZGdlT3B0aW9ucywgZWxldmF0ZU5vZGVzT25TZWxlY3QgPSB0cnVlLCBlbGV2YXRlRWRnZXNPblNlbGVjdCA9IGZhbHNlLCBkaXNhYmxlS2V5Ym9hcmRBMTF5ID0gZmFsc2UsIGF1dG9QYW5PbkNvbm5lY3QgPSB0cnVlLCBhdXRvUGFuT25Ob2RlRHJhZyA9IHRydWUsIGNvbm5lY3Rpb25SYWRpdXMgPSAyMCwgaXNWYWxpZENvbm5lY3Rpb24sIG9uRXJyb3IsIHN0eWxlLCBpZCwgbm9kZURyYWdUaHJlc2hvbGQsIC4uLnJlc3QgfSwgcmVmKSA9PiB7XG4gICAgY29uc3QgcmZJZCA9IGlkIHx8ICcxJztcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyAuLi5yZXN0LCBzdHlsZTogeyAuLi5zdHlsZSwgLi4ud3JhcHBlclN0eWxlIH0sIHJlZjogcmVmLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvdycsIGNsYXNzTmFtZV0pLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX3dyYXBwZXJcIiwgaWQ6IGlkIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlciwgbnVsbCxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoR3JhcGhWaWV3JDEsIHsgb25Jbml0OiBvbkluaXQsIG9uTW92ZTogb25Nb3ZlLCBvbk1vdmVTdGFydDogb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZDogb25Nb3ZlRW5kLCBvbk5vZGVDbGljazogb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrOiBvbkVkZ2VDbGljaywgb25Ob2RlTW91c2VFbnRlcjogb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlOiBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmU6IG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51OiBvbk5vZGVDb250ZXh0TWVudSwgb25Ob2RlRG91YmxlQ2xpY2s6IG9uTm9kZURvdWJsZUNsaWNrLCBub2RlVHlwZXM6IG5vZGVUeXBlcywgZWRnZVR5cGVzOiBlZGdlVHlwZXMsIGNvbm5lY3Rpb25MaW5lVHlwZTogY29ubmVjdGlvbkxpbmVUeXBlLCBjb25uZWN0aW9uTGluZVN0eWxlOiBjb25uZWN0aW9uTGluZVN0eWxlLCBjb25uZWN0aW9uTGluZUNvbXBvbmVudDogY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGU6IGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUsIHNlbGVjdGlvbktleUNvZGU6IHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZzogc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLCBkZWxldGVLZXlDb2RlOiBkZWxldGVLZXlDb2RlLCBtdWx0aVNlbGVjdGlvbktleUNvZGU6IG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGU6IHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGU6IHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgb25seVJlbmRlclZpc2libGVFbGVtZW50czogb25seVJlbmRlclZpc2libGVFbGVtZW50cywgc2VsZWN0Tm9kZXNPbkRyYWc6IHNlbGVjdE5vZGVzT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIHByZXZlbnRTY3JvbGxpbmc6IHByZXZlbnRTY3JvbGxpbmcsIHpvb21PblNjcm9sbDogem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaDogem9vbU9uUGluY2gsIHpvb21PbkRvdWJsZUNsaWNrOiB6b29tT25Eb3VibGVDbGljaywgcGFuT25TY3JvbGw6IHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkOiBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGU6IHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25EcmFnOiBwYW5PbkRyYWcsIG9uUGFuZUNsaWNrOiBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlcjogb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlOiBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZVNjcm9sbDogb25QYW5lU2Nyb2xsLCBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25FZGdlVXBkYXRlOiBvbkVkZ2VVcGRhdGUsIG9uRWRnZUNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VNb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgb25FZGdlVXBkYXRlU3RhcnQ6IG9uRWRnZVVwZGF0ZVN0YXJ0LCBvbkVkZ2VVcGRhdGVFbmQ6IG9uRWRnZVVwZGF0ZUVuZCwgZWRnZVVwZGF0ZXJSYWRpdXM6IGVkZ2VVcGRhdGVyUmFkaXVzLCBkZWZhdWx0TWFya2VyQ29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgbm9EcmFnQ2xhc3NOYW1lOiBub0RyYWdDbGFzc05hbWUsIG5vV2hlZWxDbGFzc05hbWU6IG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgZWxldmF0ZUVkZ2VzT25TZWxlY3Q6IGVsZXZhdGVFZGdlc09uU2VsZWN0LCByZklkOiByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50IH0pLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTdG9yZVVwZGF0ZXIsIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMsIGRlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXM6IGRlZmF1bHRFZGdlcywgb25Db25uZWN0OiBvbkNvbm5lY3QsIG9uQ29ubmVjdFN0YXJ0OiBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kOiBvbkNvbm5lY3RFbmQsIG9uQ2xpY2tDb25uZWN0U3RhcnQ6IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kOiBvbkNsaWNrQ29ubmVjdEVuZCwgbm9kZXNEcmFnZ2FibGU6IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlOiBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZTogbm9kZXNGb2N1c2FibGUsIGVkZ2VzRm9jdXNhYmxlOiBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNVcGRhdGFibGU6IGVkZ2VzVXBkYXRhYmxlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCBvbk5vZGVzQ2hhbmdlOiBvbk5vZGVzQ2hhbmdlLCBvbkVkZ2VzQ2hhbmdlOiBvbkVkZ2VzQ2hhbmdlLCBzbmFwVG9HcmlkOiBzbmFwVG9HcmlkLCBzbmFwR3JpZDogc25hcEdyaWQsIGNvbm5lY3Rpb25Nb2RlOiBjb25uZWN0aW9uTW9kZSwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIGNvbm5lY3RPbkNsaWNrOiBjb25uZWN0T25DbGljaywgZGVmYXVsdEVkZ2VPcHRpb25zOiBkZWZhdWx0RWRnZU9wdGlvbnMsIGZpdFZpZXc6IGZpdFZpZXcsIGZpdFZpZXdPcHRpb25zOiBmaXRWaWV3T3B0aW9ucywgb25Ob2Rlc0RlbGV0ZTogb25Ob2Rlc0RlbGV0ZSwgb25FZGdlc0RlbGV0ZTogb25FZGdlc0RlbGV0ZSwgb25Ob2RlRHJhZ1N0YXJ0OiBvbk5vZGVEcmFnU3RhcnQsIG9uTm9kZURyYWc6IG9uTm9kZURyYWcsIG9uTm9kZURyYWdTdG9wOiBvbk5vZGVEcmFnU3RvcCwgb25TZWxlY3Rpb25EcmFnOiBvblNlbGVjdGlvbkRyYWcsIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0OiBvblNlbGVjdGlvbkRyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnU3RvcDogb25TZWxlY3Rpb25EcmFnU3RvcCwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCByZklkOiByZklkLCBhdXRvUGFuT25Db25uZWN0OiBhdXRvUGFuT25Db25uZWN0LCBhdXRvUGFuT25Ob2RlRHJhZzogYXV0b1Bhbk9uTm9kZURyYWcsIG9uRXJyb3I6IG9uRXJyb3IsIGNvbm5lY3Rpb25SYWRpdXM6IGNvbm5lY3Rpb25SYWRpdXMsIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvbiwgbm9kZURyYWdUaHJlc2hvbGQ6IG5vZGVEcmFnVGhyZXNob2xkIH0pLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVyJDEsIHsgb25TZWxlY3Rpb25DaGFuZ2U6IG9uU2VsZWN0aW9uQ2hhbmdlIH0pLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEF0dHJpYnV0aW9uLCB7IHByb09wdGlvbnM6IHByb09wdGlvbnMsIHBvc2l0aW9uOiBhdHRyaWJ1dGlvblBvc2l0aW9uIH0pLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChBMTF5RGVzY3JpcHRpb25zLCB7IHJmSWQ6IHJmSWQsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXkgfSkpKSk7XG59KTtcblJlYWN0Rmxvdy5kaXNwbGF5TmFtZSA9ICdSZWFjdEZsb3cnO1xuXG5jb25zdCBzZWxlY3RvciQxID0gKHMpID0+IHMuZG9tTm9kZT8ucXVlcnlTZWxlY3RvcignLnJlYWN0LWZsb3dfX2VkZ2VsYWJlbC1yZW5kZXJlcicpO1xuZnVuY3Rpb24gRWRnZUxhYmVsUmVuZGVyZXIoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgZWRnZUxhYmVsUmVuZGVyZXIgPSB1c2VTdG9yZShzZWxlY3RvciQxKTtcbiAgICBpZiAoIWVkZ2VMYWJlbFJlbmRlcmVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBlZGdlTGFiZWxSZW5kZXJlcik7XG59XG5cbmZ1bmN0aW9uIHVzZVVwZGF0ZU5vZGVJbnRlcm5hbHMoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoaWQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkb21Ob2RlLCB1cGRhdGVOb2RlRGltZW5zaW9ucyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgdXBkYXRlSWRzID0gQXJyYXkuaXNBcnJheShpZCkgPyBpZCA6IFtpZF07XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSB1cGRhdGVJZHMucmVkdWNlKChyZXMsIHVwZGF0ZUlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlRWxlbWVudCA9IGRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoYC5yZWFjdC1mbG93X19ub2RlW2RhdGEtaWQ9XCIke3VwZGF0ZUlkfVwiXWApO1xuICAgICAgICAgICAgaWYgKG5vZGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goeyBpZDogdXBkYXRlSWQsIG5vZGVFbGVtZW50LCBmb3JjZVVwZGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHVwZGF0ZU5vZGVEaW1lbnNpb25zKHVwZGF0ZXMpKTtcbiAgICB9LCBbXSk7XG59XG5cbmNvbnN0IG5vZGVzU2VsZWN0b3IgPSAoc3RhdGUpID0+IHN0YXRlLmdldE5vZGVzKCk7XG5mdW5jdGlvbiB1c2VOb2RlcygpIHtcbiAgICBjb25zdCBub2RlcyA9IHVzZVN0b3JlKG5vZGVzU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2Rlcztcbn1cblxuY29uc3QgZWRnZXNTZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUuZWRnZXM7XG5mdW5jdGlvbiB1c2VFZGdlcygpIHtcbiAgICBjb25zdCBlZGdlcyA9IHVzZVN0b3JlKGVkZ2VzU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIHJldHVybiBlZGdlcztcbn1cblxuY29uc3Qgdmlld3BvcnRTZWxlY3RvciA9IChzdGF0ZSkgPT4gKHtcbiAgICB4OiBzdGF0ZS50cmFuc2Zvcm1bMF0sXG4gICAgeTogc3RhdGUudHJhbnNmb3JtWzFdLFxuICAgIHpvb206IHN0YXRlLnRyYW5zZm9ybVsyXSxcbn0pO1xuZnVuY3Rpb24gdXNlVmlld3BvcnQoKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB1c2VTdG9yZSh2aWV3cG9ydFNlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gdmlld3BvcnQ7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmZ1bmN0aW9uIGNyZWF0ZVVzZUl0ZW1zU3RhdGUoYXBwbHlDaGFuZ2VzKSB7XG4gICAgcmV0dXJuIChpbml0aWFsSXRlbXMpID0+IHtcbiAgICAgICAgY29uc3QgW2l0ZW1zLCBzZXRJdGVtc10gPSB1c2VTdGF0ZShpbml0aWFsSXRlbXMpO1xuICAgICAgICBjb25zdCBvbkl0ZW1zQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGNoYW5nZXMpID0+IHNldEl0ZW1zKChpdGVtcykgPT4gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIGl0ZW1zKSksIFtdKTtcbiAgICAgICAgcmV0dXJuIFtpdGVtcywgc2V0SXRlbXMsIG9uSXRlbXNDaGFuZ2VdO1xuICAgIH07XG59XG5jb25zdCB1c2VOb2Rlc1N0YXRlID0gY3JlYXRlVXNlSXRlbXNTdGF0ZShhcHBseU5vZGVDaGFuZ2VzKTtcbmNvbnN0IHVzZUVkZ2VzU3RhdGUgPSBjcmVhdGVVc2VJdGVtc1N0YXRlKGFwcGx5RWRnZUNoYW5nZXMpO1xuXG5mdW5jdGlvbiB1c2VPblZpZXdwb3J0Q2hhbmdlKHsgb25TdGFydCwgb25DaGFuZ2UsIG9uRW5kIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblZpZXdwb3J0Q2hhbmdlU3RhcnQ6IG9uU3RhcnQgfSk7XG4gICAgfSwgW29uU3RhcnRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uVmlld3BvcnRDaGFuZ2U6IG9uQ2hhbmdlIH0pO1xuICAgIH0sIFtvbkNoYW5nZV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25WaWV3cG9ydENoYW5nZUVuZDogb25FbmQgfSk7XG4gICAgfSwgW29uRW5kXSk7XG59XG5cbmZ1bmN0aW9uIHVzZU9uU2VsZWN0aW9uQ2hhbmdlKHsgb25DaGFuZ2UgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXh0U2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMgPSBbLi4uc3RvcmUuZ2V0U3RhdGUoKS5vblNlbGVjdGlvbkNoYW5nZSwgb25DaGFuZ2VdO1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uU2VsZWN0aW9uQ2hhbmdlOiBuZXh0U2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXh0SGFuZGxlcnMgPSBzdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlLmZpbHRlcigoZm4pID0+IGZuICE9PSBvbkNoYW5nZSk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uU2VsZWN0aW9uQ2hhbmdlOiBuZXh0SGFuZGxlcnMgfSk7XG4gICAgICAgIH07XG4gICAgfSwgW29uQ2hhbmdlXSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yID0gKG9wdGlvbnMpID0+IChzKSA9PiB7XG4gICAgaWYgKHMubm9kZUludGVybmFscy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNcbiAgICAgICAgLmdldE5vZGVzKClcbiAgICAgICAgLmZpbHRlcigobikgPT4gKG9wdGlvbnMuaW5jbHVkZUhpZGRlbk5vZGVzID8gdHJ1ZSA6ICFuLmhpZGRlbikpXG4gICAgICAgIC5ldmVyeSgobikgPT4gbltpbnRlcm5hbHNTeW1ib2xdPy5oYW5kbGVCb3VuZHMgIT09IHVuZGVmaW5lZCk7XG59O1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgaW5jbHVkZUhpZGRlbk5vZGVzOiBmYWxzZSxcbn07XG5mdW5jdGlvbiB1c2VOb2Rlc0luaXRpYWxpemVkKG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucykge1xuICAgIGNvbnN0IGluaXRpYWxpemVkID0gdXNlU3RvcmUoc2VsZWN0b3Iob3B0aW9ucykpO1xuICAgIHJldHVybiBpbml0aWFsaXplZDtcbn1cblxuZXhwb3J0IHsgQmFzZUVkZ2UsIEJlemllckVkZ2UsIENvbm5lY3Rpb25MaW5lVHlwZSwgQ29ubmVjdGlvbk1vZGUsIEVkZ2VMYWJlbFJlbmRlcmVyLCBFZGdlVGV4dCQxIGFzIEVkZ2VUZXh0LCBIYW5kbGUkMSBhcyBIYW5kbGUsIE1hcmtlclR5cGUsIFBhbk9uU2Nyb2xsTW9kZSwgUGFuZWwsIFBvc2l0aW9uLCBSZWFjdEZsb3csIFJlYWN0Rmxvd1Byb3ZpZGVyLCBTZWxlY3Rpb25Nb2RlLCBTaW1wbGVCZXppZXJFZGdlLCBTbW9vdGhTdGVwRWRnZSwgU3RlcEVkZ2UsIFN0cmFpZ2h0RWRnZSwgYWRkRWRnZSwgYXBwbHlFZGdlQ2hhbmdlcywgYXBwbHlOb2RlQ2hhbmdlcywgYm94VG9SZWN0LCBjbGFtcCwgZ2V0QmV6aWVyUGF0aCwgZ2V0Qm91bmRzT2ZSZWN0cywgZ2V0Q29ubmVjdGVkRWRnZXMsIGdldEluY29tZXJzLCBnZXRNYXJrZXJFbmQsIGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4sIGdldE5vZGVzQm91bmRzLCBnZXRPdXRnb2VycywgZ2V0UmVjdE9mTm9kZXMsIGdldFNpbXBsZUJlemllclBhdGgsIGdldFNtb290aFN0ZXBQYXRoLCBnZXRTdHJhaWdodFBhdGgsIGdldFRyYW5zZm9ybUZvckJvdW5kcywgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIGhhbmRsZVBhcmVudEV4cGFuZCwgaW50ZXJuYWxzU3ltYm9sLCBpc0VkZ2UsIGlzTm9kZSwgcmVjdFRvQm94LCB1cGRhdGVFZGdlLCB1c2VFZGdlcywgdXNlRWRnZXNTdGF0ZSwgdXNlR2V0UG9pbnRlclBvc2l0aW9uLCB1c2VLZXlQcmVzcywgdXNlTm9kZUlkLCB1c2VOb2RlcywgdXNlTm9kZXNJbml0aWFsaXplZCwgdXNlTm9kZXNTdGF0ZSwgdXNlT25TZWxlY3Rpb25DaGFuZ2UsIHVzZU9uVmlld3BvcnRDaGFuZ2UsIHVzZVJlYWN0RmxvdywgdXNlU3RvcmUsIHVzZVN0b3JlQXBpLCB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzLCB1c2VWaWV3cG9ydCB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VNZW1vIiwibWVtbyIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiZm9yd2FyZFJlZiIsInVzZUNhbGxiYWNrIiwiY2MiLCJ1c2VTdG9yZVdpdGhFcXVhbGl0eUZuIiwiY3JlYXRlV2l0aEVxdWFsaXR5Rm4iLCJzaGFsbG93Iiwiem9vbUlkZW50aXR5Iiwiem9vbSIsInNlbGVjdCIsInBvaW50ZXIiLCJkcmFnIiwiY3JlYXRlUG9ydGFsIiwiU3RvcmVDb250ZXh0IiwiUHJvdmlkZXIkMSIsIlByb3ZpZGVyIiwiZXJyb3JNZXNzYWdlcyIsImVycm9yMDAxIiwiZXJyb3IwMDIiLCJlcnJvcjAwMyIsIm5vZGVUeXBlIiwiZXJyb3IwMDQiLCJlcnJvcjAwNSIsImVycm9yMDA2IiwiZXJyb3IwMDciLCJpZCIsImVycm9yMDA5IiwidHlwZSIsImVycm9yMDA4Iiwic291cmNlSGFuZGxlIiwiZWRnZSIsInRhcmdldEhhbmRsZSIsImVycm9yMDEwIiwiZXJyb3IwMTEiLCJlZGdlVHlwZSIsImVycm9yMDEyIiwienVzdGFuZEVycm9yTWVzc2FnZSIsInVzZVN0b3JlIiwic2VsZWN0b3IiLCJlcXVhbGl0eUZuIiwic3RvcmUiLCJFcnJvciIsInVzZVN0b3JlQXBpIiwiZ2V0U3RhdGUiLCJzZXRTdGF0ZSIsInN1YnNjcmliZSIsImRlc3Ryb3kiLCJzZWxlY3RvciRnIiwicyIsInVzZXJTZWxlY3Rpb25BY3RpdmUiLCJQYW5lbCIsInBvc2l0aW9uIiwiY2hpbGRyZW4iLCJjbGFzc05hbWUiLCJzdHlsZSIsInJlc3QiLCJwb2ludGVyRXZlbnRzIiwicG9zaXRpb25DbGFzc2VzIiwic3BsaXQiLCJjcmVhdGVFbGVtZW50IiwiQXR0cmlidXRpb24iLCJwcm9PcHRpb25zIiwiaGlkZUF0dHJpYnV0aW9uIiwiaHJlZiIsInRhcmdldCIsInJlbCIsIkVkZ2VUZXh0IiwieCIsInkiLCJsYWJlbCIsImxhYmVsU3R5bGUiLCJsYWJlbFNob3dCZyIsImxhYmVsQmdTdHlsZSIsImxhYmVsQmdQYWRkaW5nIiwibGFiZWxCZ0JvcmRlclJhZGl1cyIsImVkZ2VSZWYiLCJlZGdlVGV4dEJib3giLCJzZXRFZGdlVGV4dEJib3giLCJ3aWR0aCIsImhlaWdodCIsImVkZ2VUZXh0Q2xhc3NlcyIsImN1cnJlbnQiLCJ0ZXh0QmJveCIsImdldEJCb3giLCJ0cmFuc2Zvcm0iLCJ2aXNpYmlsaXR5IiwicngiLCJyeSIsImR5IiwicmVmIiwiRWRnZVRleHQkMSIsImdldERpbWVuc2lvbnMiLCJub2RlIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJjbGFtcCIsInZhbCIsIm1pbiIsIm1heCIsIk1hdGgiLCJjbGFtcFBvc2l0aW9uIiwiZXh0ZW50IiwiY2FsY0F1dG9QYW5WZWxvY2l0eSIsInZhbHVlIiwiYWJzIiwiY2FsY0F1dG9QYW4iLCJwb3MiLCJib3VuZHMiLCJ4TW92ZW1lbnQiLCJ5TW92ZW1lbnQiLCJnZXRIb3N0Rm9yRWxlbWVudCIsImVsZW1lbnQiLCJnZXRSb290Tm9kZSIsIndpbmRvdyIsImRvY3VtZW50IiwiZ2V0Qm91bmRzT2ZCb3hlcyIsImJveDEiLCJib3gyIiwieDIiLCJ5MiIsInJlY3RUb0JveCIsImJveFRvUmVjdCIsIm5vZGVUb1JlY3QiLCJwb3NpdGlvbkFic29sdXRlIiwiZ2V0Qm91bmRzT2ZSZWN0cyIsInJlY3QxIiwicmVjdDIiLCJnZXRPdmVybGFwcGluZ0FyZWEiLCJyZWN0QSIsInJlY3RCIiwieE92ZXJsYXAiLCJ5T3ZlcmxhcCIsImNlaWwiLCJpc1JlY3RPYmplY3QiLCJvYmoiLCJpc051bWVyaWMiLCJuIiwiaXNOYU4iLCJpc0Zpbml0ZSIsImludGVybmFsc1N5bWJvbCIsIlN5bWJvbCIsImZvciIsImVsZW1lbnRTZWxlY3Rpb25LZXlzIiwiZGV2V2FybiIsIm1lc3NhZ2UiLCJwcm9jZXNzIiwiY29uc29sZSIsIndhcm4iLCJpc1JlYWN0S2V5Ym9hcmRFdmVudCIsImV2ZW50IiwiaXNJbnB1dERPTU5vZGUiLCJrYkV2ZW50IiwibmF0aXZlRXZlbnQiLCJjb21wb3NlZFBhdGgiLCJpc0lucHV0IiwiaW5jbHVkZXMiLCJub2RlTmFtZSIsImhhc0F0dHJpYnV0ZSIsImNsb3Nlc3QiLCJpc01vdXNlRXZlbnQiLCJnZXRFdmVudFBvc2l0aW9uIiwiaXNNb3VzZVRyaWdnZXJlZCIsImV2dFgiLCJjbGllbnRYIiwidG91Y2hlcyIsImV2dFkiLCJjbGllbnRZIiwibGVmdCIsInRvcCIsImlzTWFjT3MiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmRleE9mIiwiQmFzZUVkZ2UiLCJwYXRoIiwibGFiZWxYIiwibGFiZWxZIiwibWFya2VyRW5kIiwibWFya2VyU3RhcnQiLCJpbnRlcmFjdGlvbldpZHRoIiwiRnJhZ21lbnQiLCJkIiwiZmlsbCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsImRpc3BsYXlOYW1lIiwiZ2V0TWFya2VyRW5kIiwibWFya2VyVHlwZSIsIm1hcmtlckVuZElkIiwiZ2V0TW91c2VIYW5kbGVyJDEiLCJoYW5kbGVyIiwidW5kZWZpbmVkIiwiZWRnZXMiLCJmaW5kIiwiZSIsImdldEVkZ2VDZW50ZXIiLCJzb3VyY2VYIiwic291cmNlWSIsInRhcmdldFgiLCJ0YXJnZXRZIiwieE9mZnNldCIsImNlbnRlclgiLCJ5T2Zmc2V0IiwiY2VudGVyWSIsImdldEJlemllckVkZ2VDZW50ZXIiLCJzb3VyY2VDb250cm9sWCIsInNvdXJjZUNvbnRyb2xZIiwidGFyZ2V0Q29udHJvbFgiLCJ0YXJnZXRDb250cm9sWSIsIm9mZnNldFgiLCJvZmZzZXRZIiwiQ29ubmVjdGlvbk1vZGUiLCJQYW5PblNjcm9sbE1vZGUiLCJTZWxlY3Rpb25Nb2RlIiwiQ29ubmVjdGlvbkxpbmVUeXBlIiwiTWFya2VyVHlwZSIsIlBvc2l0aW9uIiwiZ2V0Q29udHJvbCIsIngxIiwieTEiLCJMZWZ0IiwiUmlnaHQiLCJnZXRTaW1wbGVCZXppZXJQYXRoIiwic291cmNlUG9zaXRpb24iLCJCb3R0b20iLCJ0YXJnZXRQb3NpdGlvbiIsIlRvcCIsIlNpbXBsZUJlemllckVkZ2UiLCJoYW5kbGVEaXJlY3Rpb25zIiwiZ2V0RGlyZWN0aW9uIiwic291cmNlIiwiZGlzdGFuY2UiLCJhIiwiYiIsInNxcnQiLCJwb3ciLCJnZXRQb2ludHMiLCJjZW50ZXIiLCJvZmZzZXQiLCJzb3VyY2VEaXIiLCJ0YXJnZXREaXIiLCJzb3VyY2VHYXBwZWQiLCJ0YXJnZXRHYXBwZWQiLCJkaXIiLCJkaXJBY2Nlc3NvciIsImN1cnJEaXIiLCJwb2ludHMiLCJzb3VyY2VHYXBPZmZzZXQiLCJ0YXJnZXRHYXBPZmZzZXQiLCJkZWZhdWx0Q2VudGVyWCIsImRlZmF1bHRDZW50ZXJZIiwiZGVmYXVsdE9mZnNldFgiLCJkZWZhdWx0T2Zmc2V0WSIsInZlcnRpY2FsU3BsaXQiLCJob3Jpem9udGFsU3BsaXQiLCJzb3VyY2VUYXJnZXQiLCJ0YXJnZXRTb3VyY2UiLCJkaWZmIiwiZ2FwT2Zmc2V0IiwiZGlyQWNjZXNzb3JPcHBvc2l0ZSIsImlzU2FtZURpciIsInNvdXJjZUd0VGFyZ2V0T3BwbyIsInNvdXJjZUx0VGFyZ2V0T3BwbyIsImZsaXBTb3VyY2VUYXJnZXQiLCJzb3VyY2VHYXBQb2ludCIsInRhcmdldEdhcFBvaW50IiwibWF4WERpc3RhbmNlIiwibWF4WURpc3RhbmNlIiwicGF0aFBvaW50cyIsImdldEJlbmQiLCJjIiwic2l6ZSIsImJlbmRTaXplIiwieERpciIsInlEaXIiLCJnZXRTbW9vdGhTdGVwUGF0aCIsImJvcmRlclJhZGl1cyIsInJlZHVjZSIsInJlcyIsInAiLCJpIiwic2VnbWVudCIsImxlbmd0aCIsIlNtb290aFN0ZXBFZGdlIiwicGF0aE9wdGlvbnMiLCJTdGVwRWRnZSIsInByb3BzIiwiZ2V0U3RyYWlnaHRQYXRoIiwiU3RyYWlnaHRFZGdlIiwiY2FsY3VsYXRlQ29udHJvbE9mZnNldCIsImN1cnZhdHVyZSIsImdldENvbnRyb2xXaXRoQ3VydmF0dXJlIiwiZ2V0QmV6aWVyUGF0aCIsIkJlemllckVkZ2UiLCJOb2RlSWRDb250ZXh0IiwiQ29uc3VtZXIiLCJ1c2VOb2RlSWQiLCJub2RlSWQiLCJpc0VkZ2UiLCJpc05vZGUiLCJnZXRPdXRnb2VycyIsIm5vZGVzIiwib3V0Z29lcklkcyIsImZpbHRlciIsIm1hcCIsImdldEluY29tZXJzIiwiaW5jb21lcnNJZHMiLCJnZXRFZGdlSWQiLCJnZXRNYXJrZXJJZCIsIm1hcmtlciIsInJmSWQiLCJpZFByZWZpeCIsIk9iamVjdCIsImtleXMiLCJzb3J0Iiwia2V5Iiwiam9pbiIsImNvbm5lY3Rpb25FeGlzdHMiLCJzb21lIiwiZWwiLCJhZGRFZGdlIiwiZWRnZVBhcmFtcyIsImNvbmNhdCIsInVwZGF0ZUVkZ2UiLCJvbGRFZGdlIiwibmV3Q29ubmVjdGlvbiIsIm9wdGlvbnMiLCJzaG91bGRSZXBsYWNlSWQiLCJvbGRFZGdlSWQiLCJmb3VuZEVkZ2UiLCJwb2ludFRvUmVuZGVyZXJQb2ludCIsInR4IiwidHkiLCJ0U2NhbGUiLCJzbmFwVG9HcmlkIiwic25hcFgiLCJzbmFwWSIsInJvdW5kIiwicmVuZGVyZXJQb2ludFRvUG9pbnQiLCJnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luIiwibm9kZU9yaWdpbiIsImdldE5vZGVzQm91bmRzIiwiYm94IiwiY3VyckJveCIsIkluZmluaXR5IiwiZ2V0UmVjdE9mTm9kZXMiLCJnZXROb2Rlc0luc2lkZSIsIm5vZGVJbnRlcm5hbHMiLCJyZWN0IiwicGFydGlhbGx5IiwiZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyIsInBhbmVSZWN0IiwidmlzaWJsZU5vZGVzIiwiZm9yRWFjaCIsInNlbGVjdGFibGUiLCJoaWRkZW4iLCJub2RlUmVjdCIsIm92ZXJsYXBwaW5nQXJlYSIsIm5vdEluaXRpYWxpemVkIiwicGFydGlhbGx5VmlzaWJsZSIsImFyZWEiLCJpc1Zpc2libGUiLCJkcmFnZ2luZyIsInB1c2giLCJnZXRDb25uZWN0ZWRFZGdlcyIsIm5vZGVJZHMiLCJnZXRUcmFuc2Zvcm1Gb3JCb3VuZHMiLCJtaW5ab29tIiwibWF4Wm9vbSIsInBhZGRpbmciLCJnZXRWaWV3cG9ydEZvckJvdW5kcyIsInhab29tIiwieVpvb20iLCJjbGFtcGVkWm9vbSIsImJvdW5kc0NlbnRlclgiLCJib3VuZHNDZW50ZXJZIiwiZ2V0RDNUcmFuc2l0aW9uIiwic2VsZWN0aW9uIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uIiwiZ2V0SGFuZGxlcyIsImhhbmRsZUJvdW5kcyIsImN1cnJlbnRIYW5kbGUiLCJoIiwiZ2V0Q2xvc2VzdEhhbmRsZSIsImRvYyIsImNvbm5lY3Rpb25SYWRpdXMiLCJoYW5kbGVzIiwidmFsaWRhdG9yIiwiZG9tTm9kZXMiLCJlbGVtZW50c0Zyb21Qb2ludCIsImhhbmRsZUJlbG93IiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJoYW5kbGVOb2RlSWQiLCJnZXRBdHRyaWJ1dGUiLCJoYW5kbGVUeXBlIiwiZ2V0SGFuZGxlVHlwZSIsImhhbmRsZUlkIiwidmFsaWRIYW5kbGVSZXN1bHQiLCJoYW5kbGUiLCJjbG9zZXN0SGFuZGxlcyIsIm1pbkRpc3RhbmNlIiwiZGVmYXVsdFJlc3VsdCIsImhhc1ZhbGlkSGFuZGxlIiwiaXNWYWxpZCIsImhhc1RhcmdldEhhbmRsZSIsIm51bGxDb25uZWN0aW9uIiwiaGFuZGxlRG9tTm9kZSIsImNvbm5lY3Rpb24iLCJlbmRIYW5kbGUiLCJpc1ZhbGlkSGFuZGxlIiwiY29ubmVjdGlvbk1vZGUiLCJmcm9tTm9kZUlkIiwiZnJvbUhhbmRsZUlkIiwiZnJvbVR5cGUiLCJpc1ZhbGlkQ29ubmVjdGlvbiIsImlzVGFyZ2V0IiwiaGFuZGxlVG9DaGVjayIsInF1ZXJ5U2VsZWN0b3IiLCJyZXN1bHQiLCJjb25uZWN0YWJsZSIsImNvbm5lY3RhYmxlRW5kIiwiaXNDb25uZWN0YWJsZSIsIlN0cmljdCIsImdldEhhbmRsZUxvb2t1cCIsInNvdXJjZUhhbmRsZXMiLCJ0YXJnZXRIYW5kbGVzIiwiZWRnZVVwZGF0ZXJUeXBlIiwicmVzZXRSZWNlbnRIYW5kbGUiLCJyZW1vdmUiLCJnZXRDb25uZWN0aW9uU3RhdHVzIiwiaXNJbnNpZGVDb25uZWN0aW9uUmFkaXVzIiwiaXNIYW5kbGVWYWxpZCIsImNvbm5lY3Rpb25TdGF0dXMiLCJoYW5kbGVQb2ludGVyRG93biIsIm9uQ29ubmVjdCIsIm9uRWRnZVVwZGF0ZUVuZCIsImRvbU5vZGUiLCJhdXRvUGFuT25Db25uZWN0Iiwib25Db25uZWN0U3RhcnQiLCJwYW5CeSIsImdldE5vZGVzIiwiY2FuY2VsQ29ubmVjdGlvbiIsImF1dG9QYW5JZCIsImNsb3Nlc3RIYW5kbGUiLCJjbGlja2VkSGFuZGxlIiwiZWxlbWVudEZyb21Qb2ludCIsImNvbnRhaW5lckJvdW5kcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInByZXZBY3RpdmVIYW5kbGUiLCJjb25uZWN0aW9uUG9zaXRpb24iLCJhdXRvUGFuU3RhcnRlZCIsImhhbmRsZUxvb2t1cCIsImF1dG9QYW4iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjb25uZWN0aW9uTm9kZUlkIiwiY29ubmVjdGlvbkhhbmRsZUlkIiwiY29ubmVjdGlvbkhhbmRsZVR5cGUiLCJjb25uZWN0aW9uU3RhcnRIYW5kbGUiLCJjb25uZWN0aW9uRW5kSGFuZGxlIiwib25Qb2ludGVyTW92ZSIsImFkZCIsInRvZ2dsZSIsIm9uUG9pbnRlclVwIiwib25Db25uZWN0RW5kIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImFsd2F5c1ZhbGlkIiwic2VsZWN0b3IkZiIsImNvbm5lY3RPbkNsaWNrIiwibm9QYW5DbGFzc05hbWUiLCJjb25uZWN0aW5nU2VsZWN0b3IiLCJzdGF0ZSIsInN0YXJ0SGFuZGxlIiwiY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUiLCJjbGlja0hhbmRsZSIsImNvbm5lY3RpbmciLCJjbGlja0Nvbm5lY3RpbmciLCJIYW5kbGUiLCJpc0Nvbm5lY3RhYmxlU3RhcnQiLCJpc0Nvbm5lY3RhYmxlRW5kIiwib25Nb3VzZURvd24iLCJvblRvdWNoU3RhcnQiLCJvbkVycm9yIiwib25Db25uZWN0RXh0ZW5kZWQiLCJwYXJhbXMiLCJkZWZhdWx0RWRnZU9wdGlvbnMiLCJvbkNvbm5lY3RBY3Rpb24iLCJoYXNEZWZhdWx0RWRnZXMiLCJzZXRFZGdlcyIsIm9uUG9pbnRlckRvd24iLCJidXR0b24iLCJvbkNsaWNrIiwib25DbGlja0Nvbm5lY3RTdGFydCIsIm9uQ2xpY2tDb25uZWN0RW5kIiwiaXNWYWxpZENvbm5lY3Rpb25TdG9yZSIsImlzVmFsaWRDb25uZWN0aW9uSGFuZGxlciIsImNvbm5lY3RhYmxlc3RhcnQiLCJjb25uZWN0YWJsZWVuZCIsImNvbm5lY3Rpb25pbmRpY2F0b3IiLCJIYW5kbGUkMSIsIkRlZmF1bHROb2RlIiwiZGF0YSIsIkRlZmF1bHROb2RlJDEiLCJJbnB1dE5vZGUiLCJJbnB1dE5vZGUkMSIsIk91dHB1dE5vZGUiLCJPdXRwdXROb2RlJDEiLCJHcm91cE5vZGUiLCJzZWxlY3RvciRlIiwic2VsZWN0ZWROb2RlcyIsInNlbGVjdGVkIiwic2VsZWN0ZWRFZGdlcyIsInNlbGVjdElkIiwiYXJlRXF1YWwiLCJTZWxlY3Rpb25MaXN0ZW5lciIsIm9uU2VsZWN0aW9uQ2hhbmdlIiwiZm4iLCJjaGFuZ2VTZWxlY3RvciIsIldyYXBwZXIkMSIsInN0b3JlSGFzU2VsZWN0aW9uQ2hhbmdlIiwic2VsZWN0b3IkZCIsInNldE5vZGVzIiwic2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMiLCJzZXRNaW5ab29tIiwic2V0TWF4Wm9vbSIsInNldFRyYW5zbGF0ZUV4dGVudCIsInNldE5vZGVFeHRlbnQiLCJyZXNldCIsInVzZVN0b3JlVXBkYXRlciIsInNldFN0b3JlU3RhdGUiLCJ1c2VEaXJlY3RTdG9yZVVwZGF0ZXIiLCJTdG9yZVVwZGF0ZXIiLCJkZWZhdWx0Tm9kZXMiLCJkZWZhdWx0RWRnZXMiLCJub2Rlc0RyYWdnYWJsZSIsIm5vZGVzQ29ubmVjdGFibGUiLCJub2Rlc0ZvY3VzYWJsZSIsImVkZ2VzRm9jdXNhYmxlIiwiZWRnZXNVcGRhdGFibGUiLCJlbGV2YXRlTm9kZXNPblNlbGVjdCIsIm5vZGVFeHRlbnQiLCJvbk5vZGVzQ2hhbmdlIiwib25FZGdlc0NoYW5nZSIsImVsZW1lbnRzU2VsZWN0YWJsZSIsInNuYXBHcmlkIiwidHJhbnNsYXRlRXh0ZW50IiwiZml0VmlldyIsImZpdFZpZXdPcHRpb25zIiwib25Ob2Rlc0RlbGV0ZSIsIm9uRWRnZXNEZWxldGUiLCJvbk5vZGVEcmFnIiwib25Ob2RlRHJhZ1N0YXJ0Iiwib25Ob2RlRHJhZ1N0b3AiLCJvblNlbGVjdGlvbkRyYWciLCJvblNlbGVjdGlvbkRyYWdTdGFydCIsIm9uU2VsZWN0aW9uRHJhZ1N0b3AiLCJhdXRvUGFuT25Ob2RlRHJhZyIsIm5vZGVEcmFnVGhyZXNob2xkIiwiZWRnZXNXaXRoRGVmYXVsdHMiLCJkaXNwbGF5IiwiYXJpYUxpdmVTdHlsZSIsIm1hcmdpbiIsImJvcmRlciIsIm92ZXJmbG93IiwiY2xpcCIsImNsaXBQYXRoIiwiQVJJQV9OT0RFX0RFU0NfS0VZIiwiQVJJQV9FREdFX0RFU0NfS0VZIiwiQVJJQV9MSVZFX01FU1NBR0UiLCJzZWxlY3RvciRjIiwiYXJpYUxpdmVNZXNzYWdlIiwiQXJpYUxpdmVNZXNzYWdlIiwiQTExeURlc2NyaXB0aW9ucyIsImRpc2FibGVLZXlib2FyZEExMXkiLCJ1c2VLZXlQcmVzcyIsImtleUNvZGUiLCJhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllciIsImtleVByZXNzZWQiLCJzZXRLZXlQcmVzc2VkIiwibW9kaWZpZXJQcmVzc2VkIiwicHJlc3NlZEtleXMiLCJTZXQiLCJrZXlDb2RlcyIsImtleXNUb1dhdGNoIiwia2V5Q29kZUFyciIsIkFycmF5IiwiaXNBcnJheSIsImtjIiwia2V5c0ZsYXQiLCJpdGVtIiwiZG93bkhhbmRsZXIiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwicHJldmVudEFjdGlvbiIsImtleU9yQ29kZSIsInVzZUtleU9yQ29kZSIsImNvZGUiLCJpc01hdGNoaW5nS2V5IiwicHJldmVudERlZmF1bHQiLCJ1cEhhbmRsZXIiLCJjbGVhciIsImRlbGV0ZSIsInJlc2V0SGFuZGxlciIsImlzVXAiLCJldmVyeSIsImsiLCJoYXMiLCJldmVudENvZGUiLCJjYWxjdWxhdGVYWVpQb3NpdGlvbiIsInBhcmVudE5vZGUiLCJnZXQiLCJwYXJlbnROb2RlUG9zaXRpb24iLCJ6IiwidXBkYXRlQWJzb2x1dGVOb2RlUG9zaXRpb25zIiwicGFyZW50Tm9kZXMiLCJpc1BhcmVudCIsImNyZWF0ZU5vZGVJbnRlcm5hbHMiLCJuZXh0Tm9kZUludGVybmFscyIsIk1hcCIsInNlbGVjdGVkTm9kZVoiLCJ6SW5kZXgiLCJjdXJySW50ZXJuYWxzIiwiaW50ZXJuYWxzIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwic2V0IiwiZDNab29tIiwiZDNTZWxlY3Rpb24iLCJmaXRWaWV3T25Jbml0RG9uZSIsImZpdFZpZXdPbkluaXQiLCJpc0luaXRpYWxGaXRWaWV3IiwiaW5pdGlhbCIsImQzaW5pdGlhbGl6ZWQiLCJpbmNsdWRlSGlkZGVuTm9kZXMiLCJvcHRpb25Ob2RlIiwibm9kZXNJbml0aWFsaXplZCIsIm5leHRUcmFuc2Zvcm0iLCJ0cmFuc2xhdGUiLCJzY2FsZSIsImhhbmRsZUNvbnRyb2xsZWROb2RlU2VsZWN0aW9uQ2hhbmdlIiwibm9kZUNoYW5nZXMiLCJjaGFuZ2UiLCJoYW5kbGVDb250cm9sbGVkRWRnZVNlbGVjdGlvbkNoYW5nZSIsImVkZ2VDaGFuZ2VzIiwidXBkYXRlTm9kZXNBbmRFZGdlc1NlbGVjdGlvbnMiLCJjaGFuZ2VkTm9kZXMiLCJjaGFuZ2VkRWRnZXMiLCJoYXNEZWZhdWx0Tm9kZXMiLCJub29wIiwiaW5pdGlhbFZpZXdwb3J0SGVscGVyIiwiem9vbUluIiwiem9vbU91dCIsInpvb21UbyIsImdldFpvb20iLCJzZXRWaWV3cG9ydCIsImdldFZpZXdwb3J0Iiwic2V0Q2VudGVyIiwiZml0Qm91bmRzIiwicHJvamVjdCIsInNjcmVlblRvRmxvd1Bvc2l0aW9uIiwiZmxvd1RvU2NyZWVuUG9zaXRpb24iLCJ2aWV3cG9ydEluaXRpYWxpemVkIiwic2VsZWN0b3IkYiIsInVzZVZpZXdwb3J0SGVscGVyIiwidmlld3BvcnRIZWxwZXJGdW5jdGlvbnMiLCJzY2FsZUJ5Iiwiem9vbUxldmVsIiwic2NhbGVUbyIsIm5leHRab29tIiwiZG9tWCIsImRvbVkiLCJyZWxhdGl2ZVBvc2l0aW9uIiwicmVuZGVyZXJQb3NpdGlvbiIsInVzZVJlYWN0RmxvdyIsInZpZXdwb3J0SGVscGVyIiwiZ2V0Tm9kZSIsImdldEVkZ2VzIiwiZ2V0RWRnZSIsInBheWxvYWQiLCJuZXh0Tm9kZXMiLCJjaGFuZ2VzIiwibmV4dEVkZ2VzIiwiYWRkTm9kZXMiLCJjdXJyZW50Tm9kZXMiLCJhZGRFZGdlcyIsInRvT2JqZWN0Iiwidmlld3BvcnQiLCJkZWxldGVFbGVtZW50cyIsIm5vZGVzRGVsZXRlZCIsImVkZ2VzRGVsZXRlZCIsImVkZ2VJZHMiLCJub2Rlc1RvUmVtb3ZlIiwicGFyZW50SGl0IiwiZGVsZXRhYmxlIiwiZGVsZXRhYmxlRWRnZXMiLCJpbml0aWFsSGl0RWRnZXMiLCJjb25uZWN0ZWRFZGdlcyIsImVkZ2VzVG9SZW1vdmUiLCJlZGdlSWRzVG9SZW1vdmUiLCJnZXROb2RlUmVjdCIsIm5vZGVPclJlY3QiLCJpc1JlY3QiLCJnZXRJbnRlcnNlY3RpbmdOb2RlcyIsImN1cnJOb2RlUmVjdCIsImlzTm9kZUludGVyc2VjdGluZyIsImRlbGV0ZUtleU9wdGlvbnMiLCJ1c2VHbG9iYWxLZXlIYW5kbGVyIiwiZGVsZXRlS2V5Q29kZSIsIm11bHRpU2VsZWN0aW9uS2V5Q29kZSIsImRlbGV0ZUtleVByZXNzZWQiLCJtdWx0aVNlbGVjdGlvbktleVByZXNzZWQiLCJub2Rlc1NlbGVjdGlvbkFjdGl2ZSIsIm11bHRpU2VsZWN0aW9uQWN0aXZlIiwidXNlUmVzaXplSGFuZGxlciIsInJlbmRlcmVyTm9kZSIsInJlc2l6ZU9ic2VydmVyIiwidXBkYXRlRGltZW5zaW9ucyIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsInVub2JzZXJ2ZSIsImNvbnRhaW5lclN0eWxlIiwidmlld0NoYW5nZWQiLCJwcmV2Vmlld3BvcnQiLCJldmVudFRyYW5zZm9ybSIsImV2ZW50VG9GbG93VHJhbnNmb3JtIiwiaXNXcmFwcGVkV2l0aENsYXNzIiwiaXNSaWdodENsaWNrUGFuIiwicGFuT25EcmFnIiwidXNlZEJ1dHRvbiIsIndoZWVsRGVsdGEiLCJmYWN0b3IiLCJkZWx0YVkiLCJkZWx0YU1vZGUiLCJzZWxlY3RvciRhIiwiZDNab29tSGFuZGxlciIsIlpvb21QYW5lIiwib25Nb3ZlIiwib25Nb3ZlU3RhcnQiLCJvbk1vdmVFbmQiLCJvblBhbmVDb250ZXh0TWVudSIsInpvb21PblNjcm9sbCIsInpvb21PblBpbmNoIiwicGFuT25TY3JvbGwiLCJwYW5PblNjcm9sbFNwZWVkIiwicGFuT25TY3JvbGxNb2RlIiwiRnJlZSIsInpvb21PbkRvdWJsZUNsaWNrIiwiZGVmYXVsdFZpZXdwb3J0Iiwiem9vbUFjdGl2YXRpb25LZXlDb2RlIiwicHJldmVudFNjcm9sbGluZyIsIm5vV2hlZWxDbGFzc05hbWUiLCJ0aW1lcklkIiwiaXNab29taW5nT3JQYW5uaW5nIiwiem9vbWVkV2l0aFJpZ2h0TW91c2VCdXR0b24iLCJ6b29tUGFuZSIsInByZXZUcmFuc2Zvcm0iLCJ6b29tQWN0aXZhdGlvbktleVByZXNzZWQiLCJtb3VzZUJ1dHRvbiIsImlzUGFuU2Nyb2xsaW5nIiwicGFuU2Nyb2xsVGltZW91dCIsImJib3giLCJkM1pvb21JbnN0YW5jZSIsInNjYWxlRXh0ZW50IiwiY2FsbCIsInVwZGF0ZWRUcmFuc2Zvcm0iLCJjb25zdHJhaW5lZFRyYW5zZm9ybSIsImNvbnN0cmFpbiIsIm9uIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiY3VycmVudFpvb20iLCJwcm9wZXJ0eSIsIl9pc01hY09zIiwicG9pbnQiLCJwaW5jaERlbHRhIiwiZGVsdGFOb3JtYWxpemUiLCJkZWx0YVgiLCJWZXJ0aWNhbCIsIkhvcml6b250YWwiLCJ0cmFuc2xhdGVCeSIsImludGVybmFsIiwibmV4dFZpZXdwb3J0Iiwib25WaWV3cG9ydENoYW5nZVN0YXJ0Iiwib25WaWV3cG9ydENoYW5nZSIsIm9uVmlld3BvcnRDaGFuZ2VFbmQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwicGFzc2l2ZSIsInNvdXJjZUV2ZW50IiwiZmxvd1RyYW5zZm9ybSIsInBhbmVEcmFnZ2luZyIsInpvb21TY3JvbGwiLCJwaW5jaFpvb20iLCJidXR0b25BbGxvd2VkIiwic2VsZWN0b3IkOSIsInVzZXJTZWxlY3Rpb25SZWN0IiwiVXNlclNlbGVjdGlvbiIsImlzQWN0aXZlIiwiaGFuZGxlUGFyZW50RXhwYW5kIiwidXBkYXRlSXRlbSIsInBhcmVudCIsImV4dGVuZFdpZHRoIiwiZXh0ZW5kSGVpZ2h0IiwieERpZmYiLCJ5RGlmZiIsImFwcGx5Q2hhbmdlcyIsImVsZW1lbnRzIiwiaW5pdEVsZW1lbnRzIiwiY3VycmVudENoYW5nZXMiLCJjdXJyZW50Q2hhbmdlIiwiZXhwYW5kUGFyZW50IiwiZGltZW5zaW9ucyIsInVwZGF0ZVN0eWxlIiwicmVzaXppbmciLCJhcHBseU5vZGVDaGFuZ2VzIiwiYXBwbHlFZGdlQ2hhbmdlcyIsImNyZWF0ZVNlbGVjdGlvbkNoYW5nZSIsImdldFNlbGVjdGlvbkNoYW5nZXMiLCJpdGVtcyIsInNlbGVjdGVkSWRzIiwid2lsbEJlU2VsZWN0ZWQiLCJ3cmFwSGFuZGxlciIsImNvbnRhaW5lclJlZiIsInNlbGVjdG9yJDgiLCJQYW5lIiwiaXNTZWxlY3RpbmciLCJzZWxlY3Rpb25Nb2RlIiwiRnVsbCIsIm9uU2VsZWN0aW9uU3RhcnQiLCJvblNlbGVjdGlvbkVuZCIsIm9uUGFuZUNsaWNrIiwib25QYW5lU2Nyb2xsIiwib25QYW5lTW91c2VFbnRlciIsIm9uUGFuZU1vdXNlTW92ZSIsIm9uUGFuZU1vdXNlTGVhdmUiLCJjb250YWluZXIiLCJwcmV2U2VsZWN0ZWROb2Rlc0NvdW50IiwicHJldlNlbGVjdGVkRWRnZXNDb3VudCIsInJlc2V0VXNlclNlbGVjdGlvbiIsInJlc2V0U2VsZWN0ZWRFbGVtZW50cyIsIm9uQ29udGV4dE1lbnUiLCJvbldoZWVsIiwic3RhcnRYIiwic3RhcnRZIiwib25Nb3VzZU1vdmUiLCJtb3VzZVBvcyIsIm5leHRVc2VyU2VsZWN0UmVjdCIsIlBhcnRpYWwiLCJzZWxlY3RlZEVkZ2VJZHMiLCJzZWxlY3RlZE5vZGVJZHMiLCJvbk1vdXNlVXAiLCJvbk1vdXNlTGVhdmUiLCJoYXNBY3RpdmVTZWxlY3Rpb24iLCJvbk1vdXNlRW50ZXIiLCJpc1BhcmVudFNlbGVjdGVkIiwiaGFzU2VsZWN0b3IiLCJub2RlUmVmIiwibWF0Y2hlcyIsInBhcmVudEVsZW1lbnQiLCJnZXREcmFnSXRlbXMiLCJmcm9tIiwidmFsdWVzIiwiZHJhZ2dhYmxlIiwiZGVsdGEiLCJjbGFtcE5vZGVFeHRlbnQiLCJjYWxjTmV4dFBvc2l0aW9uIiwibmV4dFBvc2l0aW9uIiwiY2xhbXBlZE5vZGVFeHRlbnQiLCJjdXJyZW50RXh0ZW50IiwicGFyZW50WCIsInBhcmVudFkiLCJwYXJlbnRQb3NpdGlvbiIsImdldEV2ZW50SGFuZGxlclBhcmFtcyIsImRyYWdJdGVtcyIsImV4dGVudGVkRHJhZ0l0ZW1zIiwiZ2V0SGFuZGxlQm91bmRzIiwibm9kZUVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaGFuZGxlc0FycmF5Iiwibm9kZUJvdW5kcyIsIm5vZGVPZmZzZXQiLCJnZXRNb3VzZUhhbmRsZXIiLCJoYW5kbGVOb2RlQ2xpY2siLCJ1bnNlbGVjdCIsImFkZFNlbGVjdGVkTm9kZXMiLCJ1bnNlbGVjdE5vZGVzQW5kRWRnZXMiLCJibHVyIiwidXNlR2V0UG9pbnRlclBvc2l0aW9uIiwiZ2V0UG9pbnRlclBvc2l0aW9uIiwicG9pbnRlclBvcyIsInhTbmFwcGVkIiwieVNuYXBwZWQiLCJ3cmFwU2VsZWN0aW9uRHJhZ0Z1bmMiLCJzZWxlY3Rpb25GdW5jIiwiXyIsInVzZURyYWciLCJkaXNhYmxlZCIsIm5vRHJhZ0NsYXNzTmFtZSIsImhhbmRsZVNlbGVjdG9yIiwiaXNTZWxlY3RhYmxlIiwic2VsZWN0Tm9kZXNPbkRyYWciLCJzZXREcmFnZ2luZyIsImxhc3RQb3MiLCJtb3VzZVBvc2l0aW9uIiwiZHJhZ0V2ZW50IiwiZHJhZ1N0YXJ0ZWQiLCJ1cGRhdGVOb2RlcyIsInVwZGF0ZU5vZGVQb3NpdGlvbnMiLCJoYXNDaGFuZ2UiLCJub2Rlc0JveCIsImFkanVzdGVkTm9kZUV4dGVudCIsInVwZGF0ZWRQb3MiLCJvbkRyYWciLCJjdXJyZW50Tm9kZSIsInN0YXJ0RHJhZyIsIm9uU3RhcnQiLCJkcmFnSGFuZGxlciIsIm9uU3RvcCIsImlzRHJhZ2dhYmxlIiwidXNlVXBkYXRlTm9kZVBvc2l0aW9ucyIsInVwZGF0ZVBvc2l0aW9ucyIsInhWZWxvIiwieVZlbG8iLCJpc1NoaWZ0UHJlc3NlZCIsInBvc2l0aW9uRGlmZlgiLCJwb3NpdGlvbkRpZmZZIiwibm9kZVVwZGF0ZXMiLCJhcnJvd0tleURpZmZzIiwiQXJyb3dVcCIsIkFycm93RG93biIsIkFycm93TGVmdCIsIkFycm93UmlnaHQiLCJ3cmFwTm9kZSIsIk5vZGVDb21wb25lbnQiLCJOb2RlV3JhcHBlciIsInhQb3MiLCJ5UG9zIiwieFBvc09yaWdpbiIsInlQb3NPcmlnaW4iLCJvbkRvdWJsZUNsaWNrIiwiaXNGb2N1c2FibGUiLCJkcmFnSGFuZGxlIiwiaW5pdGlhbGl6ZWQiLCJhcmlhTGFiZWwiLCJwcmV2U291cmNlUG9zaXRpb24iLCJwcmV2VGFyZ2V0UG9zaXRpb24iLCJwcmV2VHlwZSIsImhhc1BvaW50ZXJFdmVudHMiLCJvbk1vdXNlRW50ZXJIYW5kbGVyIiwib25Nb3VzZU1vdmVIYW5kbGVyIiwib25Nb3VzZUxlYXZlSGFuZGxlciIsIm9uQ29udGV4dE1lbnVIYW5kbGVyIiwib25Eb3VibGVDbGlja0hhbmRsZXIiLCJvblNlbGVjdE5vZGVIYW5kbGVyIiwib25LZXlEb3duIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJjdXJyTm9kZSIsInR5cGVDaGFuZ2VkIiwic291cmNlUG9zQ2hhbmdlZCIsInRhcmdldFBvc0NoYW5nZWQiLCJ1cGRhdGVOb2RlRGltZW5zaW9ucyIsImZvcmNlVXBkYXRlIiwidGFiSW5kZXgiLCJyb2xlIiwic2VsZWN0b3IkNyIsInRyYW5zZm9ybVN0cmluZyIsIk5vZGVzU2VsZWN0aW9uIiwib25TZWxlY3Rpb25Db250ZXh0TWVudSIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsIk5vZGVzU2VsZWN0aW9uJDEiLCJzZWxlY3RvciQ2IiwiRmxvd1JlbmRlcmVyIiwic2VsZWN0aW9uS2V5Q29kZSIsInNlbGVjdGlvbk9uRHJhZyIsInBhbkFjdGl2YXRpb25LZXlDb2RlIiwiX3Bhbk9uU2Nyb2xsIiwiX3Bhbk9uRHJhZyIsInNlbGVjdGlvbktleVByZXNzZWQiLCJwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCIsIkZsb3dSZW5kZXJlciQxIiwidXNlVmlzaWJsZU5vZGVzIiwib25seVJlbmRlclZpc2libGUiLCJjcmVhdGVOb2RlVHlwZXMiLCJub2RlVHlwZXMiLCJzdGFuZGFyZFR5cGVzIiwiaW5wdXQiLCJkZWZhdWx0Iiwib3V0cHV0IiwiZ3JvdXAiLCJ3cmFwcGVkVHlwZXMiLCJzcGVjaWFsVHlwZXMiLCJnZXRQb3NpdGlvbldpdGhPcmlnaW4iLCJvcmlnaW4iLCJzZWxlY3RvciQ1IiwiTm9kZVJlbmRlcmVyIiwib25seVJlbmRlclZpc2libGVFbGVtZW50cyIsInJlc2l6ZU9ic2VydmVyUmVmIiwib2JzZXJ2ZXIiLCJlbnRyaWVzIiwidXBkYXRlcyIsImVudHJ5IiwiZGlzY29ubmVjdCIsImZvY3VzYWJsZSIsImNsYW1wZWRQb3NpdGlvbiIsInBvc1giLCJwb3NZIiwicG9zT3JpZ2luIiwib25Ob2RlQ2xpY2siLCJvbk5vZGVNb3VzZUVudGVyIiwib25Ob2RlTW91c2VNb3ZlIiwib25Ob2RlTW91c2VMZWF2ZSIsIm9uTm9kZUNvbnRleHRNZW51Iiwib25Ob2RlRG91YmxlQ2xpY2siLCJOb2RlUmVuZGVyZXIkMSIsInNoaWZ0WCIsInNoaWZ0Iiwic2hpZnRZIiwiRWRnZVVwZGF0ZXJDbGFzc05hbWUiLCJFZGdlQW5jaG9yIiwicmFkaXVzIiwib25Nb3VzZU91dCIsImN4IiwiY3kiLCJyIiwic3Ryb2tlIiwiYWx3YXlzVmFsaWRDb25uZWN0aW9uIiwid3JhcEVkZ2UiLCJFZGdlQ29tcG9uZW50IiwiRWRnZVdyYXBwZXIiLCJvbkVkZ2VEb3VibGVDbGljayIsImFuaW1hdGVkIiwic291cmNlSGFuZGxlSWQiLCJ0YXJnZXRIYW5kbGVJZCIsImVkZ2VVcGRhdGVyUmFkaXVzIiwib25FZGdlVXBkYXRlIiwib25FZGdlVXBkYXRlU3RhcnQiLCJpc1VwZGF0YWJsZSIsInVwZGF0ZUhvdmVyIiwic2V0VXBkYXRlSG92ZXIiLCJ1cGRhdGluZyIsInNldFVwZGF0aW5nIiwibWFya2VyU3RhcnRVcmwiLCJtYXJrZXJFbmRVcmwiLCJvbkVkZ2VDbGljayIsImFkZFNlbGVjdGVkRWRnZXMiLCJvbkVkZ2VEb3VibGVDbGlja0hhbmRsZXIiLCJvbkVkZ2VDb250ZXh0TWVudSIsIm9uRWRnZU1vdXNlRW50ZXIiLCJvbkVkZ2VNb3VzZU1vdmUiLCJvbkVkZ2VNb3VzZUxlYXZlIiwiaGFuZGxlRWRnZVVwZGF0ZXIiLCJpc1NvdXJjZUhhbmRsZSIsIl9vbkVkZ2VVcGRhdGVFbmQiLCJldnQiLCJvbkNvbm5lY3RFZGdlIiwib25FZGdlVXBkYXRlclNvdXJjZU1vdXNlRG93biIsIm9uRWRnZVVwZGF0ZXJUYXJnZXRNb3VzZURvd24iLCJvbkVkZ2VVcGRhdGVyTW91c2VFbnRlciIsIm9uRWRnZVVwZGF0ZXJNb3VzZU91dCIsImluYWN0aXZlIiwiY3JlYXRlRWRnZVR5cGVzIiwiZWRnZVR5cGVzIiwic3RyYWlnaHQiLCJiZXppZXIiLCJzdGVwIiwic21vb3Roc3RlcCIsInNpbXBsZWJlemllciIsImdldEhhbmRsZVBvc2l0aW9uIiwiZ2V0SGFuZGxlIiwiZ2V0RWRnZVBvc2l0aW9ucyIsInNvdXJjZU5vZGVSZWN0IiwidGFyZ2V0Tm9kZVJlY3QiLCJzb3VyY2VIYW5kbGVQb3MiLCJ0YXJnZXRIYW5kbGVQb3MiLCJpc0VkZ2VWaXNpYmxlIiwic291cmNlUG9zIiwidGFyZ2V0UG9zIiwic291cmNlV2lkdGgiLCJzb3VyY2VIZWlnaHQiLCJ0YXJnZXRXaWR0aCIsInRhcmdldEhlaWdodCIsImVkZ2VCb3giLCJ2aWV3Qm94IiwiZ2V0Tm9kZURhdGEiLCJkZWZhdWx0RWRnZVRyZWUiLCJsZXZlbCIsImlzTWF4TGV2ZWwiLCJncm91cEVkZ2VzQnlaTGV2ZWwiLCJlbGV2YXRlRWRnZXNPblNlbGVjdCIsIm1heExldmVsIiwibGV2ZWxMb29rdXAiLCJ0cmVlIiwiaGFzWkluZGV4IiwidGFyZ2V0Tm9kZSIsInNvdXJjZU5vZGUiLCJlZGdlT3JDb25uZWN0ZWROb2RlU2VsZWN0ZWQiLCJzZWxlY3RlZFpJbmRleCIsImVkZ2VUcmVlIiwidXNlVmlzaWJsZUVkZ2VzIiwiQXJyb3dTeW1ib2wiLCJjb2xvciIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsIkFycm93Q2xvc2VkU3ltYm9sIiwiTWFya2VyU3ltYm9scyIsIkFycm93IiwiQXJyb3dDbG9zZWQiLCJ1c2VNYXJrZXJTeW1ib2wiLCJzeW1ib2wiLCJzeW1ib2xFeGlzdHMiLCJNYXJrZXIiLCJtYXJrZXJVbml0cyIsIm9yaWVudCIsIm1hcmtlcldpZHRoIiwibWFya2VySGVpZ2h0IiwicmVmWCIsInJlZlkiLCJtYXJrZXJTZWxlY3RvciIsImRlZmF1bHRDb2xvciIsImlkcyIsIm1hcmtlcnMiLCJtYXJrZXJJZCIsImxvY2FsZUNvbXBhcmUiLCJNYXJrZXJEZWZpbml0aW9ucyIsIm0iLCJNYXJrZXJEZWZpbml0aW9ucyQxIiwic2VsZWN0b3IkNCIsIkVkZ2VSZW5kZXJlciIsImRlZmF1bHRNYXJrZXJDb2xvciIsInNvdXJjZUhhbmRsZUJvdW5kcyIsInNvdXJjZUlzVmFsaWQiLCJ0YXJnZXRIYW5kbGVCb3VuZHMiLCJ0YXJnZXRJc1ZhbGlkIiwidGFyZ2V0Tm9kZUhhbmRsZXMiLCJ1cGRhdGFibGUiLCJFZGdlUmVuZGVyZXIkMSIsInNlbGVjdG9yJDMiLCJWaWV3cG9ydCIsInVzZU9uSW5pdEhhbmRsZXIiLCJvbkluaXQiLCJyZkluc3RhbmNlIiwiaXNJbml0aWFsaXplZCIsIm9wcG9zaXRlUG9zaXRpb24iLCJDb25uZWN0aW9uTGluZSIsIkJlemllciIsIkN1c3RvbUNvbXBvbmVudCIsImZyb21Ob2RlIiwidG9YIiwidG9ZIiwiZnJvbUhhbmRsZUJvdW5kcyIsIkxvb3NlIiwiZnJvbUhhbmRsZSIsImZyb21IYW5kbGVYIiwiZnJvbUhhbmRsZVkiLCJmcm9tWCIsImZyb21ZIiwiZnJvbVBvc2l0aW9uIiwidG9Qb3NpdGlvbiIsImNvbm5lY3Rpb25MaW5lVHlwZSIsImNvbm5lY3Rpb25MaW5lU3R5bGUiLCJkQXR0ciIsInBhdGhQYXJhbXMiLCJTdGVwIiwiU21vb3RoU3RlcCIsIlNpbXBsZUJlemllciIsInNlbGVjdG9yJDIiLCJDb25uZWN0aW9uTGluZVdyYXBwZXIiLCJjb21wb25lbnQiLCJ1c2VOb2RlT3JFZGdlVHlwZXMiLCJub2RlT3JFZGdlVHlwZXMiLCJjcmVhdGVUeXBlcyIsInR5cGVzS2V5c1JlZiIsInR5cGVzUGFyc2VkIiwidHlwZUtleXMiLCJHcmFwaFZpZXciLCJjb25uZWN0aW9uTGluZUNvbXBvbmVudCIsImNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUiLCJub2RlVHlwZXNXcmFwcGVkIiwiZWRnZVR5cGVzV3JhcHBlZCIsIkdyYXBoVmlldyQxIiwiaW5maW5pdGVFeHRlbnQiLCJOdW1iZXIiLCJORUdBVElWRV9JTkZJTklUWSIsIlBPU0lUSVZFX0lORklOSVRZIiwiaW5pdGlhbFN0YXRlIiwiZml0Vmlld09uSW5pdE9wdGlvbnMiLCJjcmVhdGVSRlN0b3JlIiwidmlld3BvcnROb2RlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm0yMiIsIkRPTU1hdHJpeFJlYWRPbmx5IiwidXBkYXRlIiwiZG9VcGRhdGUiLCJuZXh0Rml0Vmlld09uSW5pdERvbmUiLCJub2RlRHJhZ0l0ZW1zIiwicG9zaXRpb25DaGFuZ2VkIiwidHJpZ2dlck5vZGVDaGFuZ2VzIiwiZWRnZUlkIiwic3RvcmVFZGdlcyIsIm5vZGVzVG9VbnNlbGVjdCIsImVkZ2VzVG9VbnNlbGVjdCIsInRyYW5zZm9ybUNoYW5nZWQiLCJpcyIsIlJlYWN0Rmxvd1Byb3ZpZGVyIiwic3RvcmVSZWYiLCJXcmFwcGVyIiwiaXNXcmFwcGVkIiwiZGVmYXVsdE5vZGVUeXBlcyIsImRlZmF1bHRFZGdlVHlwZXMiLCJpbml0Tm9kZU9yaWdpbiIsImluaXRTbmFwR3JpZCIsImluaXREZWZhdWx0Vmlld3BvcnQiLCJ3cmFwcGVyU3R5bGUiLCJSZWFjdEZsb3ciLCJhdHRyaWJ1dGlvblBvc2l0aW9uIiwic2VsZWN0b3IkMSIsIkVkZ2VMYWJlbFJlbmRlcmVyIiwiZWRnZUxhYmVsUmVuZGVyZXIiLCJ1c2VVcGRhdGVOb2RlSW50ZXJuYWxzIiwidXBkYXRlSWRzIiwidXBkYXRlSWQiLCJub2Rlc1NlbGVjdG9yIiwidXNlTm9kZXMiLCJlZGdlc1NlbGVjdG9yIiwidXNlRWRnZXMiLCJ2aWV3cG9ydFNlbGVjdG9yIiwidXNlVmlld3BvcnQiLCJjcmVhdGVVc2VJdGVtc1N0YXRlIiwiaW5pdGlhbEl0ZW1zIiwic2V0SXRlbXMiLCJvbkl0ZW1zQ2hhbmdlIiwidXNlTm9kZXNTdGF0ZSIsInVzZUVkZ2VzU3RhdGUiLCJ1c2VPblZpZXdwb3J0Q2hhbmdlIiwib25DaGFuZ2UiLCJvbkVuZCIsInVzZU9uU2VsZWN0aW9uQ2hhbmdlIiwibmV4dFNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzIiwibmV4dEhhbmRsZXJzIiwiZGVmYXVsdE9wdGlvbnMiLCJ1c2VOb2Rlc0luaXRpYWxpemVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@reactflow/core/dist/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/@reactflow/minimap/dist/esm/index.mjs":
/*!*************************************************************!*\
  !*** ../node_modules/@reactflow/minimap/dist/esm/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MiniMap: () => (/* binding */ MiniMap$1)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classcat */ \"(ssr)/../node_modules/classcat/index.js\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/../node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/../node_modules/d3-zoom/src/index.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ \"(ssr)/../node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ \"(ssr)/../node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var _reactflow_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @reactflow/core */ \"(ssr)/../node_modules/@reactflow/core/dist/esm/index.mjs\");\n\n\n\n\n\n\nconst MiniMapNode = ({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, onClick, selected })=>{\n    const { background, backgroundColor } = style || {};\n    const fill = color || background || backgroundColor;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__minimap-node\",\n            {\n                selected\n            },\n            className\n        ]),\n        x: x,\n        y: y,\n        rx: borderRadius,\n        ry: borderRadius,\n        width: width,\n        height: height,\n        fill: fill,\n        stroke: strokeColor,\n        strokeWidth: strokeWidth,\n        shapeRendering: shapeRendering,\n        onClick: onClick ? (event)=>onClick(event, id) : undefined\n    });\n};\nMiniMapNode.displayName = \"MiniMapNode\";\nvar MiniMapNode$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(MiniMapNode);\n/* eslint-disable @typescript-eslint/ban-ts-comment */ const selector$1 = (s)=>s.nodeOrigin;\nconst selectorNodes = (s)=>s.getNodes().filter((node)=>!node.hidden && node.width && node.height);\nconst getAttrFunction = (func)=>func instanceof Function ? func : ()=>func;\nfunction MiniMapNodes({ nodeStrokeColor = \"transparent\", nodeColor = \"#e2e2e2\", nodeClassName = \"\", nodeBorderRadius = 5, nodeStrokeWidth = 2, // We need to rename the prop to be `CapitalCase` so that JSX will render it as\n// a component properly.\nnodeComponent: NodeComponent = MiniMapNode$1, onClick }) {\n    const nodes = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_3__.useStore)(selectorNodes, zustand_shallow__WEBPACK_IMPORTED_MODULE_4__.shallow);\n    const nodeOrigin = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_3__.useStore)(selector$1);\n    const nodeColorFunc = getAttrFunction(nodeColor);\n    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n    const nodeClassNameFunc = getAttrFunction(nodeClassName);\n    const shapeRendering =  true ? \"crispEdges\" : 0;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, nodes.map((node)=>{\n        const { x, y } = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_3__.getNodePositionWithOrigin)(node, nodeOrigin).positionAbsolute;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NodeComponent, {\n            key: node.id,\n            x: x,\n            y: y,\n            width: node.width,\n            height: node.height,\n            style: node.style,\n            selected: node.selected,\n            className: nodeClassNameFunc(node),\n            color: nodeColorFunc(node),\n            borderRadius: nodeBorderRadius,\n            strokeColor: nodeStrokeColorFunc(node),\n            strokeWidth: nodeStrokeWidth,\n            shapeRendering: shapeRendering,\n            onClick: onClick,\n            id: node.id\n        });\n    }));\n}\nvar MiniMapNodes$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(MiniMapNodes);\n/* eslint-disable @typescript-eslint/ban-ts-comment */ const defaultWidth = 200;\nconst defaultHeight = 150;\nconst selector = (s)=>{\n    const nodes = s.getNodes();\n    const viewBB = {\n        x: -s.transform[0] / s.transform[2],\n        y: -s.transform[1] / s.transform[2],\n        width: s.width / s.transform[2],\n        height: s.height / s.transform[2]\n    };\n    return {\n        viewBB,\n        boundingRect: nodes.length > 0 ? (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_3__.getBoundsOfRects)((0,_reactflow_core__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds)(nodes, s.nodeOrigin), viewBB) : viewBB,\n        rfId: s.rfId\n    };\n};\nconst ARIA_LABEL_KEY = \"react-flow__minimap-desc\";\nfunction MiniMap({ style, className, nodeStrokeColor = \"transparent\", nodeColor = \"#e2e2e2\", nodeClassName = \"\", nodeBorderRadius = 5, nodeStrokeWidth = 2, // We need to rename the prop to be `CapitalCase` so that JSX will render it as\n// a component properly.\nnodeComponent, maskColor = \"rgb(240, 240, 240, 0.6)\", maskStrokeColor = \"none\", maskStrokeWidth = 1, position = \"bottom-right\", onClick, onNodeClick, pannable = false, zoomable = false, ariaLabel = \"React Flow mini map\", inversePan = false, zoomStep = 10, offsetScale = 5 }) {\n    const store = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_3__.useStoreApi)();\n    const svg = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { boundingRect, viewBB, rfId } = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_3__.useStore)(selector, zustand_shallow__WEBPACK_IMPORTED_MODULE_4__.shallow);\n    const elementWidth = style?.width ?? defaultWidth;\n    const elementHeight = style?.height ?? defaultHeight;\n    const scaledWidth = boundingRect.width / elementWidth;\n    const scaledHeight = boundingRect.height / elementHeight;\n    const viewScale = Math.max(scaledWidth, scaledHeight);\n    const viewWidth = viewScale * elementWidth;\n    const viewHeight = viewScale * elementHeight;\n    const offset = offsetScale * viewScale;\n    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n    const width = viewWidth + offset * 2;\n    const height = viewHeight + offset * 2;\n    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;\n    const viewScaleRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    viewScaleRef.current = viewScale;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (svg.current) {\n            const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(svg.current);\n            const zoomHandler = (event)=>{\n                const { transform, d3Selection, d3Zoom } = store.getState();\n                if (event.sourceEvent.type !== \"wheel\" || !d3Selection || !d3Zoom) {\n                    return;\n                }\n                const pinchDelta = -event.sourceEvent.deltaY * (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) * zoomStep;\n                const zoom = transform[2] * Math.pow(2, pinchDelta);\n                d3Zoom.scaleTo(d3Selection, zoom);\n            };\n            const panHandler = (event)=>{\n                const { transform, d3Selection, d3Zoom, translateExtent, width, height } = store.getState();\n                if (event.sourceEvent.type !== \"mousemove\" || !d3Selection || !d3Zoom) {\n                    return;\n                }\n                // @TODO: how to calculate the correct next position? Math.max(1, transform[2]) is a workaround.\n                const moveScale = viewScaleRef.current * Math.max(1, transform[2]) * (inversePan ? -1 : 1);\n                const position = {\n                    x: transform[0] - event.sourceEvent.movementX * moveScale,\n                    y: transform[1] - event.sourceEvent.movementY * moveScale\n                };\n                const extent = [\n                    [\n                        0,\n                        0\n                    ],\n                    [\n                        width,\n                        height\n                    ]\n                ];\n                const nextTransform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(position.x, position.y).scale(transform[2]);\n                const constrainedTransform = d3Zoom.constrain()(nextTransform, extent, translateExtent);\n                d3Zoom.transform(d3Selection, constrainedTransform);\n            };\n            const zoomAndPanHandler = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoom)()// @ts-ignore\n            .on(\"zoom\", pannable ? panHandler : null)// @ts-ignore\n            .on(\"zoom.wheel\", zoomable ? zoomHandler : null);\n            selection.call(zoomAndPanHandler);\n            return ()=>{\n                selection.on(\"zoom\", null);\n            };\n        }\n    }, [\n        pannable,\n        zoomable,\n        inversePan,\n        zoomStep\n    ]);\n    const onSvgClick = onClick ? (event)=>{\n        const rfCoord = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(event);\n        onClick(event, {\n            x: rfCoord[0],\n            y: rfCoord[1]\n        });\n    } : undefined;\n    const onSvgNodeClick = onNodeClick ? (event, nodeId)=>{\n        const node = store.getState().nodeInternals.get(nodeId);\n        onNodeClick(event, node);\n    } : undefined;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_reactflow_core__WEBPACK_IMPORTED_MODULE_3__.Panel, {\n        position: position,\n        style: style,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__minimap\",\n            className\n        ]),\n        \"data-testid\": \"rf__minimap\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        width: elementWidth,\n        height: elementHeight,\n        viewBox: `${x} ${y} ${width} ${height}`,\n        role: \"img\",\n        \"aria-labelledby\": labelledBy,\n        ref: svg,\n        onClick: onSvgClick\n    }, ariaLabel && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"title\", {\n        id: labelledBy\n    }, ariaLabel), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MiniMapNodes$1, {\n        onClick: onSvgNodeClick,\n        nodeColor: nodeColor,\n        nodeStrokeColor: nodeStrokeColor,\n        nodeBorderRadius: nodeBorderRadius,\n        nodeClassName: nodeClassName,\n        nodeStrokeWidth: nodeStrokeWidth,\n        nodeComponent: nodeComponent\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        className: \"react-flow__minimap-mask\",\n        d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z\n        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`,\n        fill: maskColor,\n        fillRule: \"evenodd\",\n        stroke: maskStrokeColor,\n        strokeWidth: maskStrokeWidth,\n        pointerEvents: \"none\"\n    })));\n}\nMiniMap.displayName = \"MiniMap\";\nvar MiniMap$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(MiniMap);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0ByZWFjdGZsb3cvbWluaW1hcC9kaXN0L2VzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBdUQ7QUFDN0I7QUFDZ0I7QUFDRztBQUNFO0FBQzZFO0FBRTVILE1BQU1nQixjQUFjLENBQUMsRUFBRUMsRUFBRSxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsU0FBUyxFQUFFQyxZQUFZLEVBQUVDLGNBQWMsRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUc7SUFDakosTUFBTSxFQUFFQyxVQUFVLEVBQUVDLGVBQWUsRUFBRSxHQUFHVixTQUFTLENBQUM7SUFDbEQsTUFBTVcsT0FBUVYsU0FBU1EsY0FBY0M7SUFDckMscUJBQVFoQyxnREFBbUIsQ0FBQyxRQUFRO1FBQUUwQixXQUFXdEIsb0RBQUVBLENBQUM7WUFBQztZQUE0QjtnQkFBRTBCO1lBQVM7WUFBR0o7U0FBVTtRQUFHUixHQUFHQTtRQUFHQyxHQUFHQTtRQUFHZ0IsSUFBSVI7UUFBY1MsSUFBSVQ7UUFBY1AsT0FBT0E7UUFBT0MsUUFBUUE7UUFBUVksTUFBTUE7UUFBTUksUUFBUWI7UUFBYUMsYUFBYUE7UUFBYUcsZ0JBQWdCQTtRQUFnQkMsU0FBU0EsVUFBVSxDQUFDUyxRQUFVVCxRQUFRUyxPQUFPckIsTUFBTXNCO0lBQVU7QUFDdFY7QUFDQXZCLFlBQVl3QixXQUFXLEdBQUc7QUFDMUIsSUFBSUMsOEJBQWdCeEMsMkNBQUlBLENBQUNlO0FBRXpCLG9EQUFvRCxHQUNwRCxNQUFNMEIsYUFBYSxDQUFDQyxJQUFNQSxFQUFFQyxVQUFVO0FBQ3RDLE1BQU1DLGdCQUFnQixDQUFDRixJQUFNQSxFQUFFRyxRQUFRLEdBQUdDLE1BQU0sQ0FBQyxDQUFDQyxPQUFTLENBQUNBLEtBQUtDLE1BQU0sSUFBSUQsS0FBSzVCLEtBQUssSUFB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SUFBSTBHLDBCQUFZakosMkNBQUlBLENBQUNnRjtBQUVXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGxpZmUtZ3JhcGgvZnJvbnRlbmQyLy4uL25vZGVfbW9kdWxlcy9AcmVhY3RmbG93L21pbmltYXAvZGlzdC9lc20vaW5kZXgubWpzP2I0MzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IG1lbW8sIHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNjIGZyb20gJ2NsYXNzY2F0JztcbmltcG9ydCB7IHNoYWxsb3cgfSBmcm9tICd6dXN0YW5kL3NoYWxsb3cnO1xuaW1wb3J0IHsgem9vbSwgem9vbUlkZW50aXR5IH0gZnJvbSAnZDMtem9vbSc7XG5pbXBvcnQgeyBzZWxlY3QsIHBvaW50ZXIgfSBmcm9tICdkMy1zZWxlY3Rpb24nO1xuaW1wb3J0IHsgdXNlU3RvcmUsIGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4sIHVzZVN0b3JlQXBpLCBQYW5lbCwgZ2V0Qm91bmRzT2ZSZWN0cywgZ2V0Tm9kZXNCb3VuZHMgfSBmcm9tICdAcmVhY3RmbG93L2NvcmUnO1xuXG5jb25zdCBNaW5pTWFwTm9kZSA9ICh7IGlkLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdHlsZSwgY29sb3IsIHN0cm9rZUNvbG9yLCBzdHJva2VXaWR0aCwgY2xhc3NOYW1lLCBib3JkZXJSYWRpdXMsIHNoYXBlUmVuZGVyaW5nLCBvbkNsaWNrLCBzZWxlY3RlZCwgfSkgPT4ge1xuICAgIGNvbnN0IHsgYmFja2dyb3VuZCwgYmFja2dyb3VuZENvbG9yIH0gPSBzdHlsZSB8fCB7fTtcbiAgICBjb25zdCBmaWxsID0gKGNvbG9yIHx8IGJhY2tncm91bmQgfHwgYmFja2dyb3VuZENvbG9yKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX21pbmltYXAtbm9kZScsIHsgc2VsZWN0ZWQgfSwgY2xhc3NOYW1lXSksIHg6IHgsIHk6IHksIHJ4OiBib3JkZXJSYWRpdXMsIHJ5OiBib3JkZXJSYWRpdXMsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIGZpbGw6IGZpbGwsIHN0cm9rZTogc3Ryb2tlQ29sb3IsIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCwgc2hhcGVSZW5kZXJpbmc6IHNoYXBlUmVuZGVyaW5nLCBvbkNsaWNrOiBvbkNsaWNrID8gKGV2ZW50KSA9PiBvbkNsaWNrKGV2ZW50LCBpZCkgOiB1bmRlZmluZWQgfSkpO1xufTtcbk1pbmlNYXBOb2RlLmRpc3BsYXlOYW1lID0gJ01pbmlNYXBOb2RlJztcbnZhciBNaW5pTWFwTm9kZSQxID0gbWVtbyhNaW5pTWFwTm9kZSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCAqL1xuY29uc3Qgc2VsZWN0b3IkMSA9IChzKSA9PiBzLm5vZGVPcmlnaW47XG5jb25zdCBzZWxlY3Rvck5vZGVzID0gKHMpID0+IHMuZ2V0Tm9kZXMoKS5maWx0ZXIoKG5vZGUpID0+ICFub2RlLmhpZGRlbiAmJiBub2RlLndpZHRoICYmIG5vZGUuaGVpZ2h0KTtcbmNvbnN0IGdldEF0dHJGdW5jdGlvbiA9IChmdW5jKSA9PiAoZnVuYyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZnVuYyA6ICgpID0+IGZ1bmMpO1xuZnVuY3Rpb24gTWluaU1hcE5vZGVzKHsgbm9kZVN0cm9rZUNvbG9yID0gJ3RyYW5zcGFyZW50Jywgbm9kZUNvbG9yID0gJyNlMmUyZTInLCBub2RlQ2xhc3NOYW1lID0gJycsIG5vZGVCb3JkZXJSYWRpdXMgPSA1LCBub2RlU3Ryb2tlV2lkdGggPSAyLCBcbi8vIFdlIG5lZWQgdG8gcmVuYW1lIHRoZSBwcm9wIHRvIGJlIGBDYXBpdGFsQ2FzZWAgc28gdGhhdCBKU1ggd2lsbCByZW5kZXIgaXQgYXNcbi8vIGEgY29tcG9uZW50IHByb3Blcmx5Llxubm9kZUNvbXBvbmVudDogTm9kZUNvbXBvbmVudCA9IE1pbmlNYXBOb2RlJDEsIG9uQ2xpY2ssIH0pIHtcbiAgICBjb25zdCBub2RlcyA9IHVzZVN0b3JlKHNlbGVjdG9yTm9kZXMsIHNoYWxsb3cpO1xuICAgIGNvbnN0IG5vZGVPcmlnaW4gPSB1c2VTdG9yZShzZWxlY3RvciQxKTtcbiAgICBjb25zdCBub2RlQ29sb3JGdW5jID0gZ2V0QXR0ckZ1bmN0aW9uKG5vZGVDb2xvcik7XG4gICAgY29uc3Qgbm9kZVN0cm9rZUNvbG9yRnVuYyA9IGdldEF0dHJGdW5jdGlvbihub2RlU3Ryb2tlQ29sb3IpO1xuICAgIGNvbnN0IG5vZGVDbGFzc05hbWVGdW5jID0gZ2V0QXR0ckZ1bmN0aW9uKG5vZGVDbGFzc05hbWUpO1xuICAgIGNvbnN0IHNoYXBlUmVuZGVyaW5nID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgISF3aW5kb3cuY2hyb21lID8gJ2NyaXNwRWRnZXMnIDogJ2dlb21ldHJpY1ByZWNpc2lvbic7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBub2Rlcy5tYXAoKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKG5vZGUsIG5vZGVPcmlnaW4pLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChOb2RlQ29tcG9uZW50LCB7IGtleTogbm9kZS5pZCwgeDogeCwgeTogeSwgd2lkdGg6IG5vZGUud2lkdGgsIGhlaWdodDogbm9kZS5oZWlnaHQsIHN0eWxlOiBub2RlLnN0eWxlLCBzZWxlY3RlZDogbm9kZS5zZWxlY3RlZCwgY2xhc3NOYW1lOiBub2RlQ2xhc3NOYW1lRnVuYyhub2RlKSwgY29sb3I6IG5vZGVDb2xvckZ1bmMobm9kZSksIGJvcmRlclJhZGl1czogbm9kZUJvcmRlclJhZGl1cywgc3Ryb2tlQ29sb3I6IG5vZGVTdHJva2VDb2xvckZ1bmMobm9kZSksIHN0cm9rZVdpZHRoOiBub2RlU3Ryb2tlV2lkdGgsIHNoYXBlUmVuZGVyaW5nOiBzaGFwZVJlbmRlcmluZywgb25DbGljazogb25DbGljaywgaWQ6IG5vZGUuaWQgfSkpO1xuICAgIH0pKSk7XG59XG52YXIgTWluaU1hcE5vZGVzJDEgPSBtZW1vKE1pbmlNYXBOb2Rlcyk7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCAqL1xuY29uc3QgZGVmYXVsdFdpZHRoID0gMjAwO1xuY29uc3QgZGVmYXVsdEhlaWdodCA9IDE1MDtcbmNvbnN0IHNlbGVjdG9yID0gKHMpID0+IHtcbiAgICBjb25zdCBub2RlcyA9IHMuZ2V0Tm9kZXMoKTtcbiAgICBjb25zdCB2aWV3QkIgPSB7XG4gICAgICAgIHg6IC1zLnRyYW5zZm9ybVswXSAvIHMudHJhbnNmb3JtWzJdLFxuICAgICAgICB5OiAtcy50cmFuc2Zvcm1bMV0gLyBzLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgd2lkdGg6IHMud2lkdGggLyBzLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgaGVpZ2h0OiBzLmhlaWdodCAvIHMudHJhbnNmb3JtWzJdLFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmlld0JCLFxuICAgICAgICBib3VuZGluZ1JlY3Q6IG5vZGVzLmxlbmd0aCA+IDAgPyBnZXRCb3VuZHNPZlJlY3RzKGdldE5vZGVzQm91bmRzKG5vZGVzLCBzLm5vZGVPcmlnaW4pLCB2aWV3QkIpIDogdmlld0JCLFxuICAgICAgICByZklkOiBzLnJmSWQsXG4gICAgfTtcbn07XG5jb25zdCBBUklBX0xBQkVMX0tFWSA9ICdyZWFjdC1mbG93X19taW5pbWFwLWRlc2MnO1xuZnVuY3Rpb24gTWluaU1hcCh7IHN0eWxlLCBjbGFzc05hbWUsIG5vZGVTdHJva2VDb2xvciA9ICd0cmFuc3BhcmVudCcsIG5vZGVDb2xvciA9ICcjZTJlMmUyJywgbm9kZUNsYXNzTmFtZSA9ICcnLCBub2RlQm9yZGVyUmFkaXVzID0gNSwgbm9kZVN0cm9rZVdpZHRoID0gMiwgXG4vLyBXZSBuZWVkIHRvIHJlbmFtZSB0aGUgcHJvcCB0byBiZSBgQ2FwaXRhbENhc2VgIHNvIHRoYXQgSlNYIHdpbGwgcmVuZGVyIGl0IGFzXG4vLyBhIGNvbXBvbmVudCBwcm9wZXJseS5cbm5vZGVDb21wb25lbnQsIG1hc2tDb2xvciA9ICdyZ2IoMjQwLCAyNDAsIDI0MCwgMC42KScsIG1hc2tTdHJva2VDb2xvciA9ICdub25lJywgbWFza1N0cm9rZVdpZHRoID0gMSwgcG9zaXRpb24gPSAnYm90dG9tLXJpZ2h0Jywgb25DbGljaywgb25Ob2RlQ2xpY2ssIHBhbm5hYmxlID0gZmFsc2UsIHpvb21hYmxlID0gZmFsc2UsIGFyaWFMYWJlbCA9ICdSZWFjdCBGbG93IG1pbmkgbWFwJywgaW52ZXJzZVBhbiA9IGZhbHNlLCB6b29tU3RlcCA9IDEwLCBvZmZzZXRTY2FsZSA9IDUsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgc3ZnID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHsgYm91bmRpbmdSZWN0LCB2aWV3QkIsIHJmSWQgfSA9IHVzZVN0b3JlKHNlbGVjdG9yLCBzaGFsbG93KTtcbiAgICBjb25zdCBlbGVtZW50V2lkdGggPSBzdHlsZT8ud2lkdGggPz8gZGVmYXVsdFdpZHRoO1xuICAgIGNvbnN0IGVsZW1lbnRIZWlnaHQgPSBzdHlsZT8uaGVpZ2h0ID8/IGRlZmF1bHRIZWlnaHQ7XG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBib3VuZGluZ1JlY3Qud2lkdGggLyBlbGVtZW50V2lkdGg7XG4gICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gYm91bmRpbmdSZWN0LmhlaWdodCAvIGVsZW1lbnRIZWlnaHQ7XG4gICAgY29uc3Qgdmlld1NjYWxlID0gTWF0aC5tYXgoc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gICAgY29uc3Qgdmlld1dpZHRoID0gdmlld1NjYWxlICogZWxlbWVudFdpZHRoO1xuICAgIGNvbnN0IHZpZXdIZWlnaHQgPSB2aWV3U2NhbGUgKiBlbGVtZW50SGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldFNjYWxlICogdmlld1NjYWxlO1xuICAgIGNvbnN0IHggPSBib3VuZGluZ1JlY3QueCAtICh2aWV3V2lkdGggLSBib3VuZGluZ1JlY3Qud2lkdGgpIC8gMiAtIG9mZnNldDtcbiAgICBjb25zdCB5ID0gYm91bmRpbmdSZWN0LnkgLSAodmlld0hlaWdodCAtIGJvdW5kaW5nUmVjdC5oZWlnaHQpIC8gMiAtIG9mZnNldDtcbiAgICBjb25zdCB3aWR0aCA9IHZpZXdXaWR0aCArIG9mZnNldCAqIDI7XG4gICAgY29uc3QgaGVpZ2h0ID0gdmlld0hlaWdodCArIG9mZnNldCAqIDI7XG4gICAgY29uc3QgbGFiZWxsZWRCeSA9IGAke0FSSUFfTEFCRUxfS0VZfS0ke3JmSWR9YDtcbiAgICBjb25zdCB2aWV3U2NhbGVSZWYgPSB1c2VSZWYoMCk7XG4gICAgdmlld1NjYWxlUmVmLmN1cnJlbnQgPSB2aWV3U2NhbGU7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN2Zy5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzZWxlY3Qoc3ZnLmN1cnJlbnQpO1xuICAgICAgICAgICAgY29uc3Qgem9vbUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgZDNTZWxlY3Rpb24sIGQzWm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQudHlwZSAhPT0gJ3doZWVsJyB8fCAhZDNTZWxlY3Rpb24gfHwgIWQzWm9vbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBpbmNoRGVsdGEgPSAtZXZlbnQuc291cmNlRXZlbnQuZGVsdGFZICpcbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50LnNvdXJjZUV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDAuMDUgOiBldmVudC5zb3VyY2VFdmVudC5kZWx0YU1vZGUgPyAxIDogMC4wMDIpICpcbiAgICAgICAgICAgICAgICAgICAgem9vbVN0ZXA7XG4gICAgICAgICAgICAgICAgY29uc3Qgem9vbSA9IHRyYW5zZm9ybVsyXSAqIE1hdGgucG93KDIsIHBpbmNoRGVsdGEpO1xuICAgICAgICAgICAgICAgIGQzWm9vbS5zY2FsZVRvKGQzU2VsZWN0aW9uLCB6b29tKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBwYW5IYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIGQzU2VsZWN0aW9uLCBkM1pvb20sIHRyYW5zbGF0ZUV4dGVudCwgd2lkdGgsIGhlaWdodCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQudHlwZSAhPT0gJ21vdXNlbW92ZScgfHwgIWQzU2VsZWN0aW9uIHx8ICFkM1pvb20pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBAVE9ETzogaG93IHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCBuZXh0IHBvc2l0aW9uPyBNYXRoLm1heCgxLCB0cmFuc2Zvcm1bMl0pIGlzIGEgd29ya2Fyb3VuZC5cbiAgICAgICAgICAgICAgICBjb25zdCBtb3ZlU2NhbGUgPSB2aWV3U2NhbGVSZWYuY3VycmVudCAqIE1hdGgubWF4KDEsIHRyYW5zZm9ybVsyXSkgKiAoaW52ZXJzZVBhbiA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHRyYW5zZm9ybVswXSAtIGV2ZW50LnNvdXJjZUV2ZW50Lm1vdmVtZW50WCAqIG1vdmVTY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgeTogdHJhbnNmb3JtWzFdIC0gZXZlbnQuc291cmNlRXZlbnQubW92ZW1lbnRZICogbW92ZVNjYWxlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgIFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB6b29tSWRlbnRpdHkudHJhbnNsYXRlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpLnNjYWxlKHRyYW5zZm9ybVsyXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uc3RyYWluZWRUcmFuc2Zvcm0gPSBkM1pvb20uY29uc3RyYWluKCkobmV4dFRyYW5zZm9ybSwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgICAgICAgICAgICAgIGQzWm9vbS50cmFuc2Zvcm0oZDNTZWxlY3Rpb24sIGNvbnN0cmFpbmVkVHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB6b29tQW5kUGFuSGFuZGxlciA9IHpvb20oKVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAub24oJ3pvb20nLCBwYW5uYWJsZSA/IHBhbkhhbmRsZXIgOiBudWxsKVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAub24oJ3pvb20ud2hlZWwnLCB6b29tYWJsZSA/IHpvb21IYW5kbGVyIDogbnVsbCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uY2FsbCh6b29tQW5kUGFuSGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5vbignem9vbScsIG51bGwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtwYW5uYWJsZSwgem9vbWFibGUsIGludmVyc2VQYW4sIHpvb21TdGVwXSk7XG4gICAgY29uc3Qgb25TdmdDbGljayA9IG9uQ2xpY2tcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJmQ29vcmQgPSBwb2ludGVyKGV2ZW50KTtcbiAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIHsgeDogcmZDb29yZFswXSwgeTogcmZDb29yZFsxXSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvblN2Z05vZGVDbGljayA9IG9uTm9kZUNsaWNrXG4gICAgICAgID8gKGV2ZW50LCBub2RlSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVJbnRlcm5hbHMuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICBvbk5vZGVDbGljayhldmVudCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFBhbmVsLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgc3R5bGU6IHN0eWxlLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fbWluaW1hcCcsIGNsYXNzTmFtZV0pLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX21pbmltYXBcIiB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgd2lkdGg6IGVsZW1lbnRXaWR0aCwgaGVpZ2h0OiBlbGVtZW50SGVpZ2h0LCB2aWV3Qm94OiBgJHt4fSAke3l9ICR7d2lkdGh9ICR7aGVpZ2h0fWAsIHJvbGU6IFwiaW1nXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGxhYmVsbGVkQnksIHJlZjogc3ZnLCBvbkNsaWNrOiBvblN2Z0NsaWNrIH0sXG4gICAgICAgICAgICBhcmlhTGFiZWwgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcInRpdGxlXCIsIHsgaWQ6IGxhYmVsbGVkQnkgfSwgYXJpYUxhYmVsKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWluaU1hcE5vZGVzJDEsIHsgb25DbGljazogb25TdmdOb2RlQ2xpY2ssIG5vZGVDb2xvcjogbm9kZUNvbG9yLCBub2RlU3Ryb2tlQ29sb3I6IG5vZGVTdHJva2VDb2xvciwgbm9kZUJvcmRlclJhZGl1czogbm9kZUJvcmRlclJhZGl1cywgbm9kZUNsYXNzTmFtZTogbm9kZUNsYXNzTmFtZSwgbm9kZVN0cm9rZVdpZHRoOiBub2RlU3Ryb2tlV2lkdGgsIG5vZGVDb21wb25lbnQ6IG5vZGVDb21wb25lbnQgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19taW5pbWFwLW1hc2tcIiwgZDogYE0ke3ggLSBvZmZzZXR9LCR7eSAtIG9mZnNldH1oJHt3aWR0aCArIG9mZnNldCAqIDJ9diR7aGVpZ2h0ICsgb2Zmc2V0ICogMn1oJHstd2lkdGggLSBvZmZzZXQgKiAyfXpcbiAgICAgICAgTSR7dmlld0JCLnh9LCR7dmlld0JCLnl9aCR7dmlld0JCLndpZHRofXYke3ZpZXdCQi5oZWlnaHR9aCR7LXZpZXdCQi53aWR0aH16YCwgZmlsbDogbWFza0NvbG9yLCBmaWxsUnVsZTogXCJldmVub2RkXCIsIHN0cm9rZTogbWFza1N0cm9rZUNvbG9yLCBzdHJva2VXaWR0aDogbWFza1N0cm9rZVdpZHRoLCBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIiB9KSkpKTtcbn1cbk1pbmlNYXAuZGlzcGxheU5hbWUgPSAnTWluaU1hcCc7XG52YXIgTWluaU1hcCQxID0gbWVtbyhNaW5pTWFwKTtcblxuZXhwb3J0IHsgTWluaU1hcCQxIGFzIE1pbmlNYXAgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIm1lbW8iLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJjYyIsInNoYWxsb3ciLCJ6b29tIiwiem9vbUlkZW50aXR5Iiwic2VsZWN0IiwicG9pbnRlciIsInVzZVN0b3JlIiwiZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbiIsInVzZVN0b3JlQXBpIiwiUGFuZWwiLCJnZXRCb3VuZHNPZlJlY3RzIiwiZ2V0Tm9kZXNCb3VuZHMiLCJNaW5pTWFwTm9kZSIsImlkIiwieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsInN0eWxlIiwiY29sb3IiLCJzdHJva2VDb2xvciIsInN0cm9rZVdpZHRoIiwiY2xhc3NOYW1lIiwiYm9yZGVyUmFkaXVzIiwic2hhcGVSZW5kZXJpbmciLCJvbkNsaWNrIiwic2VsZWN0ZWQiLCJiYWNrZ3JvdW5kIiwiYmFja2dyb3VuZENvbG9yIiwiZmlsbCIsImNyZWF0ZUVsZW1lbnQiLCJyeCIsInJ5Iiwic3Ryb2tlIiwiZXZlbnQiLCJ1bmRlZmluZWQiLCJkaXNwbGF5TmFtZSIsIk1pbmlNYXBOb2RlJDEiLCJzZWxlY3RvciQxIiwicyIsIm5vZGVPcmlnaW4iLCJzZWxlY3Rvck5vZGVzIiwiZ2V0Tm9kZXMiLCJmaWx0ZXIiLCJub2RlIiwiaGlkZGVuIiwiZ2V0QXR0ckZ1bmN0aW9uIiwiZnVuYyIsIkZ1bmN0aW9uIiwiTWluaU1hcE5vZGVzIiwibm9kZVN0cm9rZUNvbG9yIiwibm9kZUNvbG9yIiwibm9kZUNsYXNzTmFtZSIsIm5vZGVCb3JkZXJSYWRpdXMiLCJub2RlU3Ryb2tlV2lkdGgiLCJub2RlQ29tcG9uZW50IiwiTm9kZUNvbXBvbmVudCIsIm5vZGVzIiwibm9kZUNvbG9yRnVuYyIsIm5vZGVTdHJva2VDb2xvckZ1bmMiLCJub2RlQ2xhc3NOYW1lRnVuYyIsIndpbmRvdyIsImNocm9tZSIsIkZyYWdtZW50IiwibWFwIiwicG9zaXRpb25BYnNvbHV0ZSIsImtleSIsIk1pbmlNYXBOb2RlcyQxIiwiZGVmYXVsdFdpZHRoIiwiZGVmYXVsdEhlaWdodCIsInNlbGVjdG9yIiwidmlld0JCIiwidHJhbnNmb3JtIiwiYm91bmRpbmdSZWN0IiwibGVuZ3RoIiwicmZJZCIsIkFSSUFfTEFCRUxfS0VZIiwiTWluaU1hcCIsIm1hc2tDb2xvciIsIm1hc2tTdHJva2VDb2xvciIsIm1hc2tTdHJva2VXaWR0aCIsInBvc2l0aW9uIiwib25Ob2RlQ2xpY2siLCJwYW5uYWJsZSIsInpvb21hYmxlIiwiYXJpYUxhYmVsIiwiaW52ZXJzZVBhbiIsInpvb21TdGVwIiwib2Zmc2V0U2NhbGUiLCJzdG9yZSIsInN2ZyIsImVsZW1lbnRXaWR0aCIsImVsZW1lbnRIZWlnaHQiLCJzY2FsZWRXaWR0aCIsInNjYWxlZEhlaWdodCIsInZpZXdTY2FsZSIsIk1hdGgiLCJtYXgiLCJ2aWV3V2lkdGgiLCJ2aWV3SGVpZ2h0Iiwib2Zmc2V0IiwibGFiZWxsZWRCeSIsInZpZXdTY2FsZVJlZiIsImN1cnJlbnQiLCJzZWxlY3Rpb24iLCJ6b29tSGFuZGxlciIsImQzU2VsZWN0aW9uIiwiZDNab29tIiwiZ2V0U3RhdGUiLCJzb3VyY2VFdmVudCIsInR5cGUiLCJwaW5jaERlbHRhIiwiZGVsdGFZIiwiZGVsdGFNb2RlIiwicG93Iiwic2NhbGVUbyIsInBhbkhhbmRsZXIiLCJ0cmFuc2xhdGVFeHRlbnQiLCJtb3ZlU2NhbGUiLCJtb3ZlbWVudFgiLCJtb3ZlbWVudFkiLCJleHRlbnQiLCJuZXh0VHJhbnNmb3JtIiwidHJhbnNsYXRlIiwic2NhbGUiLCJjb25zdHJhaW5lZFRyYW5zZm9ybSIsImNvbnN0cmFpbiIsInpvb21BbmRQYW5IYW5kbGVyIiwib24iLCJjYWxsIiwib25TdmdDbGljayIsInJmQ29vcmQiLCJvblN2Z05vZGVDbGljayIsIm5vZGVJZCIsIm5vZGVJbnRlcm5hbHMiLCJnZXQiLCJ2aWV3Qm94Iiwicm9sZSIsInJlZiIsImQiLCJmaWxsUnVsZSIsInBvaW50ZXJFdmVudHMiLCJNaW5pTWFwJDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@reactflow/minimap/dist/esm/index.mjs\n");

/***/ })

};
;